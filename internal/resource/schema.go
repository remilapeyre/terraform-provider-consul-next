/*
Code generated by github-terraform-generator; DO NOT EDIT.
Any modifications will be overwritten
*/

package resource

import (
	schema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	booldefault "github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	stringdefault "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	validator "github.com/hashicorp/terraform-plugin-framework/schema/validator"
	types "github.com/hashicorp/terraform-plugin-framework/types"
)

func aclAuthMethodSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"name": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "The name of the ACL auth method.",
			},
			"type": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "The type of the ACL auth method.",
			},
			"display_name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The display name for this ACL auth method.",
				Default:             stringdefault.StaticString(""),
			},
			"description": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The description for this ACL auth method.",
				Default:             stringdefault.StaticString(""),
			},
			"max_token_ttl": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The maximum time-to-live of the tokens this auth method produces.",
				Default:             stringdefault.StaticString("0s"),
			},
			"token_locality": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "token_locality defines the kind of token that this auth method produces. This can be either 'local' or 'global'. If empty 'local' is assumed.",
				Default:             stringdefault.StaticString(""),
			},
			"config": schema.StringAttribute{
				Optional:            true,
				MarkdownDescription: "The configuration for this ACL auth method. This should only contain primitive values and containers (such as lists and maps).",
			},
			"namespace_rules": &schema.ListNestedAttribute{
				Optional:            true,
				MarkdownDescription: "namespace_rules apply only on auth methods defined in the default namespace. Namespacing is a Consul Enterprise feature.",
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"selector": schema.StringAttribute{
							Optional:            true,
							MarkdownDescription: "selector is an expression that matches against verified identity attributes returned from the auth method during login.",
						},
						"bind_namespace": schema.StringAttribute{
							Optional:            true,
							MarkdownDescription: "bind_namespace is the target namespace of the binding. Can be lightly templated using HIL `${foo}` syntax from available field names. If empty it's created in the same namespace as the auth method.",
						},
					}},
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The namespace this ACL auth method is associated with. Namespacing is a Consul Enterprise feature.",
				Default:             stringdefault.StaticString(""),
			},
			"partition": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The partition this ACL auth method is associated with. Partitions are a Consul Enterprise feature.",
				Default:             stringdefault.StaticString(""),
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func aclBindingRuleSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"description": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"auth_method": schema.StringAttribute{
				Required: true,
			},
			"selector": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"bind_type": schema.StringAttribute{
				Required: true,
			},
			"bind_name": schema.StringAttribute{
				Required: true,
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"partition": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func aclPolicySchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"name": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "The name of this ACL policy.",
			},
			"description": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The description of this ACL policy.",
				Default:             stringdefault.StaticString(""),
			},
			"rules": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "The rules of this ACL policy.",
			},
			"datacenters": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				MarkdownDescription: "The datacenters this ACL policy is valid in.",
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The namespace the ACL policy is associated with. Namespacing is a Consul Enterprise feature.",
				Default:             stringdefault.StaticString(""),
			},
			"partition": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The partition the ACL policy is associated with. Partitions are a Consul Enterprise feature.",
				Default:             stringdefault.StaticString(""),
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func aclRoleSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"name": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "The name of this ACL role.",
			},
			"description": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The description of this ACL role.",
				Default:             stringdefault.StaticString(""),
			},
			"policies": &schema.ListNestedAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The policies associated with this ACL role.",
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"id": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							MarkdownDescription: "The ID of the ACL policy associated with this role.",
							Validators:          []validator.String{NewMutuallyExclusiveValidator("name")},
						},
						"name": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							MarkdownDescription: "The name of the ACL policy associated with this role.",
							Validators:          []validator.String{NewMutuallyExclusiveValidator("id")},
						},
					}},
			},
			"service_identities": &schema.ListNestedAttribute{
				Optional:            true,
				MarkdownDescription: "The services associated with this ACL role.",
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"service_name": schema.StringAttribute{
							Required:            true,
							MarkdownDescription: "The service associated with this ACL role.",
						},
						"datacenters": schema.ListAttribute{
							ElementType: types.StringType,
							Optional:    true,
						},
					}},
			},
			"node_identities": &schema.ListNestedAttribute{
				Optional:            true,
				MarkdownDescription: "The nodes associated with this ACL role.",
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"node_name": schema.StringAttribute{
							Required:            true,
							MarkdownDescription: "The node associated with this ACL role.",
						},
						"datacenter": schema.StringAttribute{
							Optional: true,
						},
					}},
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The namespace the ACL role is associated with. Namespacing is a Consul Enterprise feature.",
				Default:             stringdefault.StaticString(""),
			},
			"partition": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The partition the ACL role is associated with. Partitions are a Consul Enterprise feature.",
				Default:             stringdefault.StaticString(""),
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func aclTokenSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"accessor_id": schema.StringAttribute{
				Computed: true,
			},
			"description": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"policies": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"id": schema.StringAttribute{
							Optional:   true,
							Computed:   true,
							Validators: []validator.String{NewMutuallyExclusiveValidator("name")},
						},
						"name": schema.StringAttribute{
							Optional:   true,
							Computed:   true,
							Validators: []validator.String{NewMutuallyExclusiveValidator("id")},
						},
					}},
			},
			"roles": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"id": schema.StringAttribute{
							Optional:   true,
							Computed:   true,
							Validators: []validator.String{NewMutuallyExclusiveValidator("name")},
						},
						"name": schema.StringAttribute{
							Optional:   true,
							Computed:   true,
							Validators: []validator.String{NewMutuallyExclusiveValidator("id")},
						},
					}},
			},
			"service_identities": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"service_name": schema.StringAttribute{
							Required: true,
						},
						"datacenters": schema.ListAttribute{
							ElementType: types.StringType,
							Optional:    true,
						},
					}},
			},
			"node_identities": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"node_name": schema.StringAttribute{
							Required: true,
						},
						"datacenter": schema.StringAttribute{
							Optional: true,
						},
					}},
			},
			"local": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `false`",
				Default:             booldefault.StaticBool(false),
			},
			"auth_method": schema.StringAttribute{
				Computed: true,
			},
			"expiration_ttl": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"0s\"`",
				Default:             stringdefault.StaticString("0s"),
			},
			"expiration_time": schema.StringAttribute{
				Computed: true,
			},
			"create_time": schema.StringAttribute{
				Computed: true,
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"partition": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"auth_method_namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func aclTokenPolicyAttachmentSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"token_id": schema.StringAttribute{
				Required: true,
			},
			"policy": &schema.SingleNestedAttribute{
				Required: true,
				Attributes: map[string]schema.Attribute{
					"id": schema.StringAttribute{
						Optional:   true,
						Computed:   true,
						Validators: []validator.String{NewMutuallyExclusiveValidator("name")},
					},
					"name": schema.StringAttribute{
						Optional:   true,
						Computed:   true,
						Validators: []validator.String{NewMutuallyExclusiveValidator("id")},
					},
				},
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func aclTokenRoleAttachmentSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"token_id": schema.StringAttribute{
				Required: true,
			},
			"role": &schema.SingleNestedAttribute{
				Required: true,
				Attributes: map[string]schema.Attribute{
					"id": schema.StringAttribute{
						Optional:   true,
						Computed:   true,
						Validators: []validator.String{NewMutuallyExclusiveValidator("name")},
					},
					"name": schema.StringAttribute{
						Optional:   true,
						Computed:   true,
						Validators: []validator.String{NewMutuallyExclusiveValidator("id")},
					},
				},
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func adminPartitionSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				Required: true,
			},
			"description": schema.StringAttribute{
				Optional: true,
			},
			"deleted_at": schema.StringAttribute{
				Optional: true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func areaSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"peer_datacenter": schema.StringAttribute{
				Required: true,
			},
			"retry_join": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"use_tls": schema.BoolAttribute{
				Optional: true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func autopilotConfigSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"cleanup_dead_servers": schema.BoolAttribute{
				Optional: true,
				Computed: true,
			},
			"max_trailing_logs": schema.Int64Attribute{
				Optional: true,
				Computed: true,
			},
			"min_quorum": schema.Int64Attribute{
				Optional: true,
				Computed: true,
			},
			"redundancy_zone_tag": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"disable_upgrade_migration": schema.BoolAttribute{
				Optional: true,
				Computed: true,
			},
			"upgrade_version_tag": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func catalogServiceSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Optional: true,
			},
			"node": schema.StringAttribute{
				Optional: true,
			},
			"address": schema.StringAttribute{
				Optional: true,
			},
			"datacenter": schema.StringAttribute{
				Optional: true,
			},
			"tagged_addresses": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"node_meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"service_id": schema.StringAttribute{
				Optional: true,
			},
			"service_name": schema.StringAttribute{
				Optional: true,
			},
			"service_address": schema.StringAttribute{
				Optional: true,
			},
			"service_tagged_addresses": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"address": schema.StringAttribute{
							Optional: true,
						},
						"port": schema.Int64Attribute{
							Optional: true,
						},
					},
				},
			},
			"service_tags": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"service_meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"service_port": schema.Int64Attribute{
				Optional: true,
			},
			"service_weights": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"passing": schema.Int64Attribute{
						Optional: true,
					},
					"warning": schema.Int64Attribute{
						Optional: true,
					},
				},
			},
			"service_enable_tag_override": schema.BoolAttribute{
				Optional: true,
			},
			"service_proxy": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"envoy_extensions": &schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Optional: true,
								},
								"required": schema.BoolAttribute{
									Optional: true,
								},
								"arguments": schema.StringAttribute{
									Optional: true,
								},
								"consul_version": schema.StringAttribute{
									Optional: true,
								},
								"envoy_version": schema.StringAttribute{
									Optional: true,
								},
							}},
					},
					"destination_service_name": schema.StringAttribute{
						Optional: true,
					},
					"destination_service_id": schema.StringAttribute{
						Optional: true,
					},
					"local_service_address": schema.StringAttribute{
						Optional: true,
					},
					"local_service_port": schema.Int64Attribute{
						Optional: true,
					},
					"local_service_socket_path": schema.StringAttribute{
						Optional: true,
					},
					"mode": schema.StringAttribute{
						Optional: true,
					},
					"transparent_proxy": &schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"outbound_listener_port": schema.Int64Attribute{
								Optional: true,
							},
							"dialed_directly": schema.BoolAttribute{
								Optional: true,
							},
						},
					},
					"config": schema.StringAttribute{
						Optional: true,
					},
					"upstreams": &schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"destination_type": schema.StringAttribute{
									Optional: true,
								},
								"destination_partition": schema.StringAttribute{
									Optional: true,
								},
								"destination_namespace": schema.StringAttribute{
									Optional: true,
								},
								"destination_peer": schema.StringAttribute{
									Optional: true,
								},
								"destination_name": schema.StringAttribute{
									Optional: true,
								},
								"datacenter": schema.StringAttribute{
									Optional: true,
								},
								"local_bind_address": schema.StringAttribute{
									Optional: true,
								},
								"local_bind_port": schema.Int64Attribute{
									Optional: true,
								},
								"local_bind_socket_path": schema.StringAttribute{
									Optional: true,
								},
								"local_bind_socket_mode": schema.StringAttribute{
									Optional: true,
								},
								"config": schema.StringAttribute{
									Optional: true,
								},
								"mesh_gateway": &schema.SingleNestedAttribute{
									Optional: true,
									Attributes: map[string]schema.Attribute{
										"mode": schema.StringAttribute{
											Optional: true,
										},
									},
								},
								"centrally_configured": schema.BoolAttribute{
									Optional: true,
								},
							}},
					},
					"mesh_gateway": &schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"mode": schema.StringAttribute{
								Optional: true,
							},
						},
					},
					"expose": &schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"checks": schema.BoolAttribute{
								Optional: true,
							},
							"paths": &schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"listener_port": schema.Int64Attribute{
											Optional: true,
										},
										"path": schema.StringAttribute{
											Optional: true,
										},
										"local_path_port": schema.Int64Attribute{
											Optional: true,
										},
										"protocol": schema.StringAttribute{
											Optional: true,
										},
										"parsed_from_check": schema.BoolAttribute{
											Optional: true,
										},
									}},
							},
						},
					},
					"access_logs": &schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional: true,
							},
							"disable_listener_logs": schema.BoolAttribute{
								Optional: true,
							},
							"type": schema.StringAttribute{
								Optional: true,
							},
							"path": schema.StringAttribute{
								Optional: true,
							},
							"json_format": schema.StringAttribute{
								Optional: true,
							},
							"text_format": schema.StringAttribute{
								Optional: true,
							},
						},
					},
				},
			},
			"service_locality": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"region": schema.StringAttribute{
						Optional: true,
					},
					"zone": schema.StringAttribute{
						Optional: true,
					},
				},
			},
			"create_index": schema.Int64Attribute{
				Optional: true,
			},
			"checks": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"node": schema.StringAttribute{
							Optional: true,
						},
						"check_id": schema.StringAttribute{
							Optional: true,
						},
						"name": schema.StringAttribute{
							Optional: true,
						},
						"status": schema.StringAttribute{
							Optional: true,
						},
						"notes": schema.StringAttribute{
							Optional: true,
						},
						"output": schema.StringAttribute{
							Optional: true,
						},
						"service_id": schema.StringAttribute{
							Optional: true,
						},
						"service_name": schema.StringAttribute{
							Optional: true,
						},
						"service_tags": schema.ListAttribute{
							ElementType: types.StringType,
							Optional:    true,
						},
						"type": schema.StringAttribute{
							Optional: true,
						},
						"namespace": schema.StringAttribute{
							Optional: true,
						},
						"partition": schema.StringAttribute{
							Optional: true,
						},
						"exposed_port": schema.Int64Attribute{
							Optional: true,
						},
						"peer_name": schema.StringAttribute{
							Optional: true,
						},
						"definition": &schema.SingleNestedAttribute{
							Optional: true,
							Attributes: map[string]schema.Attribute{
								"http": schema.StringAttribute{
									Optional: true,
								},
								"header": schema.MapAttribute{
									ElementType: types.ListType{
										ElemType: types.StringType,
									},
									Optional: true,
								},
								"method": schema.StringAttribute{
									Optional: true,
								},
								"body": schema.StringAttribute{
									Optional: true,
								},
								"tls_server_name": schema.StringAttribute{
									Optional: true,
								},
								"tls_skip_verify": schema.BoolAttribute{
									Optional: true,
								},
								"tcp": schema.StringAttribute{
									Optional: true,
								},
								"udp": schema.StringAttribute{
									Optional: true,
								},
								"grpc": schema.StringAttribute{
									Optional: true,
								},
								"os_service": schema.StringAttribute{
									Optional: true,
								},
								"grpc_use_tls": schema.BoolAttribute{
									Optional: true,
								},
								"interval_duration": schema.StringAttribute{
									Optional: true,
								},
								"timeout_duration": schema.StringAttribute{
									Optional: true,
								},
								"deregister_critical_service_after_duration": schema.StringAttribute{
									Optional: true,
								},
							},
						},
					}},
			},
			"modify_index": schema.Int64Attribute{
				Optional: true,
			},
			"namespace": schema.StringAttribute{
				Optional: true,
			},
			"partition": schema.StringAttribute{
				Optional: true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func certificateAuthoritySchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"connect_provider": schema.StringAttribute{
				Required: true,
			},
			"config": schema.StringAttribute{
				Optional: true,
			},
			"state": schema.MapAttribute{
				ElementType: types.StringType,
				Computed:    true,
			},
			"force_without_cross_signing": schema.BoolAttribute{
				Optional: true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func configEntrySchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"kind": schema.StringAttribute{
				Optional: true,
			},
			"name": schema.StringAttribute{
				Optional: true,
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"partition": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"config": schema.StringAttribute{
				Optional: true,
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func namespaceSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				Required: true,
			},
			"description": schema.StringAttribute{
				Optional: true,
			},
			"ac_ls": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"policy_defaults": &schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"id": schema.StringAttribute{
									Optional:   true,
									Computed:   true,
									Validators: []validator.String{NewMutuallyExclusiveValidator("name")},
								},
								"name": schema.StringAttribute{
									Optional:   true,
									Computed:   true,
									Validators: []validator.String{NewMutuallyExclusiveValidator("id")},
								},
							}},
					},
					"role_defaults": &schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"id": schema.StringAttribute{
									Optional:   true,
									Computed:   true,
									Validators: []validator.String{NewMutuallyExclusiveValidator("name")},
								},
								"name": schema.StringAttribute{
									Optional:   true,
									Computed:   true,
									Validators: []validator.String{NewMutuallyExclusiveValidator("id")},
								},
							}},
					},
				},
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"deleted_at": schema.StringAttribute{
				Optional: true,
			},
			"partition": schema.StringAttribute{
				Optional: true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func namespacePolicyAttachmentSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"namespace": schema.StringAttribute{
				Required: true,
			},
			"policy": &schema.SingleNestedAttribute{
				Required: true,
				Attributes: map[string]schema.Attribute{
					"id": schema.StringAttribute{
						Optional:   true,
						Computed:   true,
						Validators: []validator.String{NewMutuallyExclusiveValidator("name")},
					},
					"name": schema.StringAttribute{
						Optional:   true,
						Computed:   true,
						Validators: []validator.String{NewMutuallyExclusiveValidator("id")},
					},
				},
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func namespaceRoleAttachmentSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"namespace": schema.StringAttribute{
				Required: true,
			},
			"role": &schema.SingleNestedAttribute{
				Required: true,
				Attributes: map[string]schema.Attribute{
					"id": schema.StringAttribute{
						Optional:   true,
						Computed:   true,
						Validators: []validator.String{NewMutuallyExclusiveValidator("name")},
					},
					"name": schema.StringAttribute{
						Optional:   true,
						Computed:   true,
						Validators: []validator.String{NewMutuallyExclusiveValidator("id")},
					},
				},
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func nodeSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"services": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"id": schema.StringAttribute{
							Optional: true,
						},
					},
				},
			},
			"id": schema.StringAttribute{
				Optional: true,
			},
			"node": schema.StringAttribute{
				Optional: true,
			},
			"address": schema.StringAttribute{
				Optional: true,
			},
			"datacenter": schema.StringAttribute{
				Optional: true,
			},
			"tagged_addresses": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"partition": schema.StringAttribute{
				Optional: true,
			},
			"peer_name": schema.StringAttribute{
				Optional: true,
			},
			"locality": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"region": schema.StringAttribute{
						Optional: true,
					},
					"zone": schema.StringAttribute{
						Optional: true,
					},
				},
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func peeringSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"peering_token": schema.StringAttribute{
				Optional:  true,
				Sensitive: true,
			},
			"id": schema.StringAttribute{
				Optional: true,
			},
			"name": schema.StringAttribute{
				Optional: true,
			},
			"partition": schema.StringAttribute{
				Optional: true,
			},
			"deleted_at": schema.StringAttribute{
				Optional: true,
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"state": schema.StringAttribute{
				Optional: true,
			},
			"peer_id": schema.StringAttribute{
				Optional: true,
			},
			"peer_ca_pems": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"peer_server_name": schema.StringAttribute{
				Optional: true,
			},
			"peer_server_addresses": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"stream_status": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"imported_services": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"exported_services": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"last_heartbeat": schema.StringAttribute{
						Optional: true,
					},
					"last_receive": schema.StringAttribute{
						Optional: true,
					},
					"last_send": schema.StringAttribute{
						Optional: true,
					},
				},
			},
			"remote": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"partition": schema.StringAttribute{
						Optional: true,
					},
					"datacenter": schema.StringAttribute{
						Optional: true,
					},
					"locality": &schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"region": schema.StringAttribute{
								Optional: true,
							},
							"zone": schema.StringAttribute{
								Optional: true,
							},
						},
					},
				},
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func peeringTokenSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"peer_name": schema.StringAttribute{
				Optional: true,
			},
			"partition": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"server_external_addresses": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"peering_token": schema.StringAttribute{
				Computed: true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func preparedQueryDefinitionSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"name": schema.StringAttribute{
				Optional: true,
			},
			"session": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"token": schema.StringAttribute{
				Optional: true,
			},
			"service": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						Optional: true,
					},
					"sameness_group": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						MarkdownDescription: "This defaults to `\"\"`",
						Default:             stringdefault.StaticString(""),
					},
					"namespace": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						MarkdownDescription: "This defaults to `\"\"`",
						Default:             stringdefault.StaticString(""),
					},
					"partition": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						MarkdownDescription: "This defaults to `\"\"`",
						Default:             stringdefault.StaticString(""),
					},
					"near": schema.StringAttribute{
						Optional: true,
					},
					"failover": &schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"nearest_n": schema.Int64Attribute{
								Optional: true,
							},
							"datacenters": schema.ListAttribute{
								ElementType: types.StringType,
								Optional:    true,
							},
							"targets": &schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"peer": schema.StringAttribute{
											Optional: true,
										},
										"datacenter": schema.StringAttribute{
											Optional: true,
										},
										"partition": schema.StringAttribute{
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											Optional: true,
										},
									}},
							},
						},
					},
					"ignore_check_ids": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"only_passing": schema.BoolAttribute{
						Optional: true,
					},
					"tags": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"node_meta": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"service_meta": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"connect": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						MarkdownDescription: "This defaults to `false`",
						Default:             booldefault.StaticBool(false),
					},
				},
			},
			"dns": &schema.SingleNestedAttribute{
				Optional: true,
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"ttl": schema.StringAttribute{
						Optional: true,
					},
				},
			},
			"template": &schema.SingleNestedAttribute{
				Optional: true,
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"type": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						MarkdownDescription: "This defaults to `\"\"`",
						Default:             stringdefault.StaticString(""),
					},
					"regexp": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						MarkdownDescription: "This defaults to `\"\"`",
						Default:             stringdefault.StaticString(""),
					},
					"remove_empty_tags": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						MarkdownDescription: "This defaults to `false`",
						Default:             booldefault.StaticBool(false),
					},
				},
			},
		},
		Blocks: map[string]schema.Block{},
	}
}
