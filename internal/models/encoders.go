/*
Code generated by github-terraform-generator; DO NOT EDIT.
Any modifications will be overwritten
*/

package models

import (
	"context"
	"encoding/json"
	"fmt"
	api "github.com/hashicorp/consul/api"
	diag "github.com/hashicorp/terraform-plugin-framework/diag"
	types "github.com/hashicorp/terraform-plugin-framework/types"
	structs "github.com/remilapeyre/terraform-provider-consul-next/internal/structs"
	"time"
)

type Setter interface {
	Set(context.Context, interface{}) diag.Diagnostics
}

func Set[Model *structs.ACLAuthMethod | *api.ACLBindingRule | *api.ACLPolicy | *api.ACLRole | *structs.ACLToken | *structs.ACLTokenPolicyAttachment | *structs.ACLTokenRoleAttachment | *structs.ACLTokenSecretID | *structs.AgentConfig | *api.Area | *structs.AutopilotConfig | *structs.AutopilotHealth | *structs.CAConfig | *api.CatalogNode | *api.CatalogService | *api.Config | *structs.ConfigEntry | *structs.Datacenters | *structs.KeyPrefix | *structs.Keys | *api.Namespace | *structs.NamespacePolicyAttachment | *structs.NamespaceRoleAttachment | *structs.NetworkAreaMembers | *structs.NetworkSegments | *structs.Nodes | *api.OperatorHealthReply | *api.Partition | *api.Peering | *structs.PeeringResource | *structs.PeeringToken | *structs.Peerings | *api.PreparedQueryDefinition | *structs.ServiceHealth](ctx context.Context, setter Setter, obj Model) diag.Diagnostics {
	var diags diag.Diagnostics
	var converted interface{}
	switch o := any(obj).(type) {
	case *structs.ACLAuthMethod:
		converted, diags = EncodeACLAuthMethod(o)
	case *api.ACLBindingRule:
		converted, diags = EncodeACLBindingRule(o)
	case *api.ACLPolicy:
		converted, diags = EncodeACLPolicy(o)
	case *api.ACLRole:
		converted, diags = EncodeACLRole(o)
	case *structs.ACLToken:
		converted, diags = EncodeACLToken(o)
	case *structs.ACLTokenPolicyAttachment:
		converted, diags = EncodeACLTokenPolicyAttachment(o)
	case *structs.ACLTokenRoleAttachment:
		converted, diags = EncodeACLTokenRoleAttachment(o)
	case *structs.ACLTokenSecretID:
		converted, diags = EncodeACLTokenSecretID(o)
	case *structs.AgentConfig:
		converted, diags = EncodeAgentConfig(o)
	case *api.Area:
		converted, diags = EncodeArea(o)
	case *structs.AutopilotConfig:
		converted, diags = EncodeAutopilotConfig(o)
	case *structs.AutopilotHealth:
		converted, diags = EncodeAutopilotHealth(o)
	case *structs.CAConfig:
		converted, diags = EncodeCAConfig(o)
	case *api.CatalogNode:
		converted, diags = EncodeCatalogNode(o)
	case *api.CatalogService:
		converted, diags = EncodeCatalogService(o)
	case *api.Config:
		converted, diags = EncodeConfig(o)
	case *structs.ConfigEntry:
		converted, diags = EncodeConfigEntry(o)
	case *structs.Datacenters:
		converted, diags = EncodeDatacenters(o)
	case *structs.KeyPrefix:
		converted, diags = EncodeKeyPrefix(o)
	case *structs.Keys:
		converted, diags = EncodeKeys(o)
	case *api.Namespace:
		converted, diags = EncodeNamespace(o)
	case *structs.NamespacePolicyAttachment:
		converted, diags = EncodeNamespacePolicyAttachment(o)
	case *structs.NamespaceRoleAttachment:
		converted, diags = EncodeNamespaceRoleAttachment(o)
	case *structs.NetworkAreaMembers:
		converted, diags = EncodeNetworkAreaMembers(o)
	case *structs.NetworkSegments:
		converted, diags = EncodeNetworkSegments(o)
	case *structs.Nodes:
		converted, diags = EncodeNodes(o)
	case *api.OperatorHealthReply:
		converted, diags = EncodeOperatorHealthReply(o)
	case *api.Partition:
		converted, diags = EncodePartition(o)
	case *api.Peering:
		converted, diags = EncodePeering(o)
	case *structs.PeeringResource:
		converted, diags = EncodePeeringResource(o)
	case *structs.PeeringToken:
		converted, diags = EncodePeeringToken(o)
	case *structs.Peerings:
		converted, diags = EncodePeerings(o)
	case *api.PreparedQueryDefinition:
		converted, diags = EncodePreparedQueryDefinition(o)
	case *structs.ServiceHealth:
		converted, diags = EncodeServiceHealth(o)
	default:
		diags.AddError("unsupported object type", fmt.Sprintf("%T is not supported in %s.Set(). Please report this issue to the provider developers.", obj, "models"))
		return diags
	}
	diags.Append(setter.Set(ctx, converted)...)
	return diags
}

func EncodeACLAuthMethod(aclAuthMethod *structs.ACLAuthMethod) (*ACLAuthMethod, diag.Diagnostics) {
	if aclAuthMethod == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ACLAuthMethod{}
	res.ID = types.StringValue(aclAuthMethod.ID)
	res.Name = types.StringValue(aclAuthMethod.Method.Name)
	res.Type = types.StringValue(aclAuthMethod.Method.Type)
	res.DisplayName = types.StringValue(aclAuthMethod.Method.DisplayName)
	res.Description = types.StringValue(aclAuthMethod.Method.Description)
	res.MaxTokenTTL = types.StringValue(aclAuthMethod.Method.MaxTokenTTL.String())
	res.TokenLocality = types.StringValue(aclAuthMethod.Method.TokenLocality)
	if aclAuthMethod.Method.Config != nil {
		data, err := json.Marshal(aclAuthMethod.Method.Config)
		if err != nil {
			panic(err)
		}
		res.Config = types.StringValue(string(data))
	}
	if aclAuthMethod.Method.NamespaceRules != nil {
		res.NamespaceRules = make([]*ACLAuthMethodNamespaceRule, len(aclAuthMethod.Method.NamespaceRules))
		for i, attr := range aclAuthMethod.Method.NamespaceRules {
			{
				data, d := encodeACLAuthMethodNamespaceRule(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.NamespaceRules[i] = data
				}
			}
		}
	}
	res.Namespace = types.StringValue(aclAuthMethod.Method.Namespace)
	res.Partition = types.StringValue(aclAuthMethod.Method.Partition)
	return &res, diags
}

func EncodeACLBindingRule(aclBindingRule *api.ACLBindingRule) (*ACLBindingRule, diag.Diagnostics) {
	if aclBindingRule == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ACLBindingRule{}
	res.ID = types.StringValue(aclBindingRule.ID)
	res.Description = types.StringValue(aclBindingRule.Description)
	res.AuthMethod = types.StringValue(aclBindingRule.AuthMethod)
	res.Selector = types.StringValue(aclBindingRule.Selector)
	res.BindType = types.StringValue(string(aclBindingRule.BindType))
	res.BindName = types.StringValue(aclBindingRule.BindName)
	res.Namespace = types.StringValue(aclBindingRule.Namespace)
	res.Partition = types.StringValue(aclBindingRule.Partition)
	return &res, diags
}

func EncodeACLPolicy(aclPolicy *api.ACLPolicy) (*ACLPolicy, diag.Diagnostics) {
	if aclPolicy == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ACLPolicy{}
	res.ID = types.StringValue(aclPolicy.ID)
	res.Name = types.StringValue(aclPolicy.Name)
	res.Description = types.StringValue(aclPolicy.Description)
	res.Rules = types.StringValue(aclPolicy.Rules)
	if aclPolicy.Datacenters != nil {
		res.Datacenters = make([]types.String, len(aclPolicy.Datacenters))
		for i, attr := range aclPolicy.Datacenters {
			res.Datacenters[i] = types.StringValue(attr)
		}
	}
	res.Namespace = types.StringValue(aclPolicy.Namespace)
	res.Partition = types.StringValue(aclPolicy.Partition)
	return &res, diags
}

func EncodeACLRole(aclRole *api.ACLRole) (*ACLRole, diag.Diagnostics) {
	if aclRole == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ACLRole{}
	res.ID = types.StringValue(aclRole.ID)
	res.Name = types.StringValue(aclRole.Name)
	res.Description = types.StringValue(aclRole.Description)
	if aclRole.Policies != nil {
		res.Policies = make([]*ACLLink, len(aclRole.Policies))
		for i, attr := range aclRole.Policies {
			{
				data, d := encodeACLLink(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Policies[i] = data
				}
			}
		}
	}
	if aclRole.ServiceIdentities != nil {
		res.ServiceIdentities = make([]*ACLServiceIdentity, len(aclRole.ServiceIdentities))
		for i, attr := range aclRole.ServiceIdentities {
			{
				data, d := encodeACLServiceIdentity(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.ServiceIdentities[i] = data
				}
			}
		}
	}
	if aclRole.NodeIdentities != nil {
		res.NodeIdentities = make([]*ACLNodeIdentity, len(aclRole.NodeIdentities))
		for i, attr := range aclRole.NodeIdentities {
			{
				data, d := encodeACLNodeIdentity(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.NodeIdentities[i] = data
				}
			}
		}
	}
	res.Namespace = types.StringValue(aclRole.Namespace)
	res.Partition = types.StringValue(aclRole.Partition)
	return &res, diags
}

func EncodeACLToken(aclToken *structs.ACLToken) (*ACLToken, diag.Diagnostics) {
	if aclToken == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ACLToken{}
	res.ID = types.StringValue(aclToken.ID)
	res.AccessorID = types.StringValue(aclToken.Token.AccessorID)
	res.Description = types.StringValue(aclToken.Token.Description)
	if aclToken.Token.Policies != nil {
		res.Policies = make([]*ACLLink, len(aclToken.Token.Policies))
		for i, attr := range aclToken.Token.Policies {
			{
				data, d := encodeACLLink(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Policies[i] = data
				}
			}
		}
	}
	if aclToken.Token.Roles != nil {
		res.Roles = make([]*ACLLink, len(aclToken.Token.Roles))
		for i, attr := range aclToken.Token.Roles {
			{
				data, d := encodeACLLink(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Roles[i] = data
				}
			}
		}
	}
	if aclToken.Token.ServiceIdentities != nil {
		res.ServiceIdentities = make([]*ACLServiceIdentity, len(aclToken.Token.ServiceIdentities))
		for i, attr := range aclToken.Token.ServiceIdentities {
			{
				data, d := encodeACLServiceIdentity(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.ServiceIdentities[i] = data
				}
			}
		}
	}
	if aclToken.Token.NodeIdentities != nil {
		res.NodeIdentities = make([]*ACLNodeIdentity, len(aclToken.Token.NodeIdentities))
		for i, attr := range aclToken.Token.NodeIdentities {
			{
				data, d := encodeACLNodeIdentity(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.NodeIdentities[i] = data
				}
			}
		}
	}
	res.Local = types.BoolValue(aclToken.Token.Local)
	res.AuthMethod = types.StringValue(aclToken.Token.AuthMethod)
	res.ExpirationTTL = types.StringValue(aclToken.Token.ExpirationTTL.String())
	if aclToken.Token.ExpirationTime != nil {
		res.ExpirationTime = types.StringValue(aclToken.Token.ExpirationTime.Format(time.RFC3339))
	}
	res.CreateTime = types.StringValue(aclToken.Token.CreateTime.Format(time.RFC3339))
	res.Namespace = types.StringValue(aclToken.Token.Namespace)
	res.Partition = types.StringValue(aclToken.Token.Partition)
	res.AuthMethodNamespace = types.StringValue(aclToken.Token.AuthMethodNamespace)
	return &res, diags
}

func EncodeACLTokenPolicyAttachment(aclTokenPolicyAttachment *structs.ACLTokenPolicyAttachment) (*ACLTokenPolicyAttachment, diag.Diagnostics) {
	if aclTokenPolicyAttachment == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ACLTokenPolicyAttachment{}
	res.ID = types.StringValue(aclTokenPolicyAttachment.ID)
	res.TokenID = types.StringValue(aclTokenPolicyAttachment.TokenID)
	{
		data, d := encodeACLLink(&aclTokenPolicyAttachment.Policy)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Policy = data
		}
	}
	return &res, diags
}

func EncodeACLTokenRoleAttachment(aclTokenRoleAttachment *structs.ACLTokenRoleAttachment) (*ACLTokenRoleAttachment, diag.Diagnostics) {
	if aclTokenRoleAttachment == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ACLTokenRoleAttachment{}
	res.ID = types.StringValue(aclTokenRoleAttachment.ID)
	res.TokenID = types.StringValue(aclTokenRoleAttachment.TokenID)
	{
		data, d := encodeACLLink(&aclTokenRoleAttachment.Role)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Role = data
		}
	}
	return &res, diags
}

func EncodeACLTokenSecretID(aclTokenSecretId *structs.ACLTokenSecretID) (*ACLTokenSecretID, diag.Diagnostics) {
	if aclTokenSecretId == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ACLTokenSecretID{}
	res.ID = types.StringValue(aclTokenSecretId.ID)
	res.AccessorID = types.StringValue(aclTokenSecretId.AccessorID)
	res.SecretID = types.StringValue(aclTokenSecretId.SecretID)
	res.Partition = types.StringValue(aclTokenSecretId.Partition)
	res.Namespace = types.StringValue(aclTokenSecretId.Namespace)
	res.PGPKey = types.StringValue(aclTokenSecretId.PGPKey)
	return &res, diags
}

func EncodeAgentConfig(agentConfig *structs.AgentConfig) (*AgentConfig, diag.Diagnostics) {
	if agentConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := AgentConfig{}
	res.ID = types.StringValue(agentConfig.ID)
	res.Datacenter = types.StringValue(agentConfig.Datacenter)
	res.PrimaryDatacenter = types.StringValue(agentConfig.PrimaryDatacenter)
	res.NodeName = types.StringValue(agentConfig.NodeName)
	res.NodeID = types.StringValue(agentConfig.NodeID)
	res.Partition = types.StringPointerValue(agentConfig.Partition)
	res.Revision = types.StringValue(agentConfig.Revision)
	res.Server = types.BoolValue(agentConfig.Server)
	res.Version = types.StringValue(agentConfig.Version)
	res.BuildDate = types.StringValue(agentConfig.BuildDate)
	return &res, diags
}

func EncodeArea(area *api.Area) (*Area, diag.Diagnostics) {
	if area == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Area{}
	res.ID = types.StringValue(area.ID)
	res.PeerDatacenter = types.StringValue(area.PeerDatacenter)
	if area.RetryJoin != nil {
		res.RetryJoin = make([]types.String, len(area.RetryJoin))
		for i, attr := range area.RetryJoin {
			res.RetryJoin[i] = types.StringValue(attr)
		}
	}
	res.UseTLS = types.BoolValue(area.UseTLS)
	return &res, diags
}

func EncodeAutopilotConfig(autopilotConfig *structs.AutopilotConfig) (*AutopilotConfig, diag.Diagnostics) {
	if autopilotConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := AutopilotConfig{}
	res.ID = types.StringValue(autopilotConfig.ID)
	res.CleanupDeadServers = types.BoolValue(autopilotConfig.Config.CleanupDeadServers)
	res.MaxTrailingLogs = types.Int64Value(int64(autopilotConfig.Config.MaxTrailingLogs))
	res.MinQuorum = types.Int64Value(int64(autopilotConfig.Config.MinQuorum))
	res.RedundancyZoneTag = types.StringValue(autopilotConfig.Config.RedundancyZoneTag)
	res.DisableUpgradeMigration = types.BoolValue(autopilotConfig.Config.DisableUpgradeMigration)
	res.UpgradeVersionTag = types.StringValue(autopilotConfig.Config.UpgradeVersionTag)
	return &res, diags
}

func EncodeAutopilotHealth(autopilotHealth *structs.AutopilotHealth) (*AutopilotHealth, diag.Diagnostics) {
	if autopilotHealth == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := AutopilotHealth{}
	res.ID = types.StringValue(autopilotHealth.ID)
	res.Healthy = types.BoolValue(autopilotHealth.AutopilotHealth.Healthy)
	res.FailureTolerance = types.Int64Value(int64(autopilotHealth.AutopilotHealth.FailureTolerance))
	if autopilotHealth.AutopilotHealth.Servers != nil {
		res.Servers = make([]*ServerHealth, len(autopilotHealth.AutopilotHealth.Servers))
		for i, attr := range autopilotHealth.AutopilotHealth.Servers {
			{
				data, d := encodeServerHealth(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Servers[i] = data
				}
			}
		}
	}
	return &res, diags
}

func EncodeCAConfig(caConfig *structs.CAConfig) (*CAConfig, diag.Diagnostics) {
	if caConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := CAConfig{}
	res.ID = types.StringValue(caConfig.ID)
	res.Provider = types.StringValue(caConfig.Config.Provider)
	if caConfig.Config.Config != nil {
		data, err := json.Marshal(caConfig.Config.Config)
		if err != nil {
			panic(err)
		}
		res.Config = types.StringValue(string(data))
	}
	if caConfig.Config.State != nil {
		res.State = map[string]types.String{}
		for k, v := range caConfig.Config.State {
			res.State[k] = types.StringValue(v)
		}
	}
	res.ForceWithoutCrossSigning = types.BoolValue(caConfig.Config.ForceWithoutCrossSigning)
	return &res, diags
}

func EncodeCatalogNode(catalogNode *api.CatalogNode) (*CatalogNode, diag.Diagnostics) {
	if catalogNode == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := CatalogNode{}
	if catalogNode.Services != nil {
		res.Services = map[string]*AgentService{}
		for k, v := range catalogNode.Services {
			{
				data, d := encodeAgentService(v)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Services[k] = data
				}
			}
		}
	}
	res.ID = types.StringValue(catalogNode.Node.ID)
	res.Node = types.StringValue(catalogNode.Node.Node)
	res.Address = types.StringValue(catalogNode.Node.Address)
	res.Datacenter = types.StringValue(catalogNode.Node.Datacenter)
	if catalogNode.Node.TaggedAddresses != nil {
		res.TaggedAddresses = map[string]types.String{}
		for k, v := range catalogNode.Node.TaggedAddresses {
			res.TaggedAddresses[k] = types.StringValue(v)
		}
	}
	if catalogNode.Node.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range catalogNode.Node.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	res.Partition = types.StringValue(catalogNode.Node.Partition)
	res.PeerName = types.StringValue(catalogNode.Node.PeerName)
	{
		data, d := encodeLocality(catalogNode.Node.Locality)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Locality = data
		}
	}
	return &res, diags
}

func EncodeCatalogService(catalogService *api.CatalogService) (*CatalogService, diag.Diagnostics) {
	if catalogService == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := CatalogService{}
	res.ID = types.StringValue(catalogService.ID)
	res.Node = types.StringValue(catalogService.Node)
	res.Address = types.StringValue(catalogService.Address)
	res.Datacenter = types.StringValue(catalogService.Datacenter)
	if catalogService.TaggedAddresses != nil {
		res.TaggedAddresses = map[string]types.String{}
		for k, v := range catalogService.TaggedAddresses {
			res.TaggedAddresses[k] = types.StringValue(v)
		}
	}
	if catalogService.NodeMeta != nil {
		res.NodeMeta = map[string]types.String{}
		for k, v := range catalogService.NodeMeta {
			res.NodeMeta[k] = types.StringValue(v)
		}
	}
	res.ServiceID = types.StringValue(catalogService.ServiceID)
	res.ServiceName = types.StringValue(catalogService.ServiceName)
	res.ServiceAddress = types.StringValue(catalogService.ServiceAddress)
	if catalogService.ServiceTaggedAddresses != nil {
		res.ServiceTaggedAddresses = map[string]*ServiceAddress{}
		for k, v := range catalogService.ServiceTaggedAddresses {
			{
				data, d := encodeServiceAddress(&v)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.ServiceTaggedAddresses[k] = data
				}
			}
		}
	}
	if catalogService.ServiceTags != nil {
		res.ServiceTags = make([]types.String, len(catalogService.ServiceTags))
		for i, attr := range catalogService.ServiceTags {
			res.ServiceTags[i] = types.StringValue(attr)
		}
	}
	if catalogService.ServiceMeta != nil {
		res.ServiceMeta = map[string]types.String{}
		for k, v := range catalogService.ServiceMeta {
			res.ServiceMeta[k] = types.StringValue(v)
		}
	}
	res.ServicePort = types.Int64Value(int64(catalogService.ServicePort))
	{
		data, d := encodeWeights(&catalogService.ServiceWeights)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.ServiceWeights = data
		}
	}
	res.ServiceEnableTagOverride = types.BoolValue(catalogService.ServiceEnableTagOverride)
	{
		data, d := encodeAgentServiceConnectProxyConfig(catalogService.ServiceProxy)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.ServiceProxy = data
		}
	}
	{
		data, d := encodeLocality(catalogService.ServiceLocality)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.ServiceLocality = data
		}
	}
	res.CreateIndex = types.Int64Value(int64(catalogService.CreateIndex))
	if catalogService.Checks != nil {
		res.Checks = make([]*HealthCheck, len(catalogService.Checks))
		for i, attr := range catalogService.Checks {
			{
				data, d := encodeHealthCheck(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Checks[i] = data
				}
			}
		}
	}
	res.ModifyIndex = types.Int64Value(int64(catalogService.ModifyIndex))
	res.Namespace = types.StringValue(catalogService.Namespace)
	res.Partition = types.StringValue(catalogService.Partition)
	return &res, diags
}

func EncodeConfig(config *api.Config) (*Config, diag.Diagnostics) {
	if config == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Config{}
	res.Address = types.StringValue(config.Address)
	res.Scheme = types.StringValue(config.Scheme)
	res.PathPrefix = types.StringValue(config.PathPrefix)
	res.Datacenter = types.StringValue(config.Datacenter)
	{
		data, d := encodeHttpBasicAuth(config.HttpAuth)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.HttpAuth = data
		}
	}
	res.Token = types.StringValue(config.Token)
	res.TokenFile = types.StringValue(config.TokenFile)
	res.Namespace = types.StringValue(config.Namespace)
	res.Partition = types.StringValue(config.Partition)
	{
		data, d := encodeTLSConfig(&config.TLSConfig)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.TLSConfig = data
		}
	}
	return &res, diags
}

func EncodeConfigEntry(configEntry *structs.ConfigEntry) (*ConfigEntry, diag.Diagnostics) {
	if configEntry == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ConfigEntry{}
	res.ID = types.StringValue(configEntry.ID)
	res.Kind = types.StringValue(configEntry.Kind)
	res.Name = types.StringValue(configEntry.Name)
	res.Namespace = types.StringValue(configEntry.Namespace)
	res.Partition = types.StringValue(configEntry.Partition)
	if configEntry.Config != nil {
		data, err := json.Marshal(configEntry.Config)
		if err != nil {
			panic(err)
		}
		res.Config = types.StringValue(string(data))
	}
	if configEntry.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range configEntry.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	return &res, diags
}

func EncodeDatacenters(datacenters *structs.Datacenters) (*Datacenters, diag.Diagnostics) {
	if datacenters == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Datacenters{}
	res.ID = types.StringValue(datacenters.ID)
	if datacenters.Datacenters != nil {
		res.Datacenters = make([]types.String, len(datacenters.Datacenters))
		for i, attr := range datacenters.Datacenters {
			res.Datacenters[i] = types.StringValue(attr)
		}
	}
	return &res, diags
}

func EncodeKeyPrefix(keyPrefix *structs.KeyPrefix) (*KeyPrefix, diag.Diagnostics) {
	if keyPrefix == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := KeyPrefix{}
	res.ID = types.StringValue(keyPrefix.ID)
	return &res, diags
}

func EncodeKeys(keys *structs.Keys) (*Keys, diag.Diagnostics) {
	if keys == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Keys{}
	res.ID = types.StringValue(keys.ID)
	if keys.Keys != nil {
		res.Keys = make([]*KVPair, len(keys.Keys))
		for i, attr := range keys.Keys {
			{
				data, d := encodeKVPair(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Keys[i] = data
				}
			}
		}
	}
	return &res, diags
}

func EncodeNamespace(namespace *api.Namespace) (*Namespace, diag.Diagnostics) {
	if namespace == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Namespace{}
	res.Name = types.StringValue(namespace.Name)
	res.Description = types.StringValue(namespace.Description)
	{
		data, d := encodeNamespaceACLConfig(namespace.ACLs)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.ACLs = data
		}
	}
	if namespace.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range namespace.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	if namespace.DeletedAt != nil {
		res.DeletedAt = types.StringValue(namespace.DeletedAt.Format(time.RFC3339))
	}
	res.Partition = types.StringValue(namespace.Partition)
	return &res, diags
}

func EncodeNamespacePolicyAttachment(namespacePolicyAttachment *structs.NamespacePolicyAttachment) (*NamespacePolicyAttachment, diag.Diagnostics) {
	if namespacePolicyAttachment == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := NamespacePolicyAttachment{}
	res.ID = types.StringValue(namespacePolicyAttachment.ID)
	res.Namespace = types.StringValue(namespacePolicyAttachment.Namespace)
	{
		data, d := encodeACLLink(&namespacePolicyAttachment.Policy)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Policy = data
		}
	}
	return &res, diags
}

func EncodeNamespaceRoleAttachment(namespaceRoleAttachment *structs.NamespaceRoleAttachment) (*NamespaceRoleAttachment, diag.Diagnostics) {
	if namespaceRoleAttachment == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := NamespaceRoleAttachment{}
	res.ID = types.StringValue(namespaceRoleAttachment.ID)
	res.Namespace = types.StringValue(namespaceRoleAttachment.Namespace)
	{
		data, d := encodeACLLink(&namespaceRoleAttachment.Role)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Role = data
		}
	}
	return &res, diags
}

func EncodeNetworkAreaMembers(networkAreaMembers *structs.NetworkAreaMembers) (*NetworkAreaMembers, diag.Diagnostics) {
	if networkAreaMembers == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := NetworkAreaMembers{}
	res.ID = types.StringValue(networkAreaMembers.ID)
	if networkAreaMembers.Members != nil {
		res.Members = make([]*SerfMember, len(networkAreaMembers.Members))
		for i, attr := range networkAreaMembers.Members {
			{
				data, d := encodeSerfMember(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Members[i] = data
				}
			}
		}
	}
	return &res, diags
}

func EncodeNetworkSegments(networkSegments *structs.NetworkSegments) (*NetworkSegments, diag.Diagnostics) {
	if networkSegments == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := NetworkSegments{}
	res.ID = types.StringValue(networkSegments.ID)
	if networkSegments.Segments != nil {
		res.Segments = make([]types.String, len(networkSegments.Segments))
		for i, attr := range networkSegments.Segments {
			res.Segments[i] = types.StringValue(attr)
		}
	}
	return &res, diags
}

func EncodeNodes(nodes *structs.Nodes) (*Nodes, diag.Diagnostics) {
	if nodes == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Nodes{}
	res.ID = types.StringValue(nodes.ID)
	if nodes.Nodes != nil {
		res.Nodes = make([]*Node, len(nodes.Nodes))
		for i, attr := range nodes.Nodes {
			{
				data, d := encodeNode(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Nodes[i] = data
				}
			}
		}
	}
	return &res, diags
}

func EncodeOperatorHealthReply(operatorHealthReply *api.OperatorHealthReply) (*OperatorHealthReply, diag.Diagnostics) {
	if operatorHealthReply == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := OperatorHealthReply{}
	res.Healthy = types.BoolValue(operatorHealthReply.Healthy)
	res.FailureTolerance = types.Int64Value(int64(operatorHealthReply.FailureTolerance))
	if operatorHealthReply.Servers != nil {
		res.Servers = make([]*ServerHealth, len(operatorHealthReply.Servers))
		for i, attr := range operatorHealthReply.Servers {
			{
				data, d := encodeServerHealth(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Servers[i] = data
				}
			}
		}
	}
	return &res, diags
}

func EncodePartition(partition *api.Partition) (*Partition, diag.Diagnostics) {
	if partition == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Partition{}
	res.Name = types.StringValue(partition.Name)
	res.Description = types.StringValue(partition.Description)
	if partition.DeletedAt != nil {
		res.DeletedAt = types.StringValue(partition.DeletedAt.Format(time.RFC3339))
	}
	return &res, diags
}

func EncodePeering(peering *api.Peering) (*Peering, diag.Diagnostics) {
	if peering == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Peering{}
	res.ID = types.StringValue(peering.ID)
	res.Name = types.StringValue(peering.Name)
	res.Partition = types.StringValue(peering.Partition)
	if peering.DeletedAt != nil {
		res.DeletedAt = types.StringValue(peering.DeletedAt.Format(time.RFC3339))
	}
	if peering.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range peering.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	res.State = types.StringValue(string(peering.State))
	res.PeerID = types.StringValue(peering.PeerID)
	if peering.PeerCAPems != nil {
		res.PeerCAPems = make([]types.String, len(peering.PeerCAPems))
		for i, attr := range peering.PeerCAPems {
			res.PeerCAPems[i] = types.StringValue(attr)
		}
	}
	res.PeerServerName = types.StringValue(peering.PeerServerName)
	if peering.PeerServerAddresses != nil {
		res.PeerServerAddresses = make([]types.String, len(peering.PeerServerAddresses))
		for i, attr := range peering.PeerServerAddresses {
			res.PeerServerAddresses[i] = types.StringValue(attr)
		}
	}
	{
		data, d := encodePeeringStreamStatus(&peering.StreamStatus)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.StreamStatus = data
		}
	}
	{
		data, d := encodePeeringRemoteInfo(&peering.Remote)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Remote = data
		}
	}
	return &res, diags
}

func EncodePeeringResource(peeringResource *structs.PeeringResource) (*PeeringResource, diag.Diagnostics) {
	if peeringResource == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := PeeringResource{}
	res.PeeringToken = types.StringValue(peeringResource.PeeringToken)
	res.ID = types.StringValue(peeringResource.Peering.ID)
	res.Name = types.StringValue(peeringResource.Peering.Name)
	res.Partition = types.StringValue(peeringResource.Peering.Partition)
	if peeringResource.Peering.DeletedAt != nil {
		res.DeletedAt = types.StringValue(peeringResource.Peering.DeletedAt.Format(time.RFC3339))
	}
	if peeringResource.Peering.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range peeringResource.Peering.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	res.State = types.StringValue(string(peeringResource.Peering.State))
	res.PeerID = types.StringValue(peeringResource.Peering.PeerID)
	if peeringResource.Peering.PeerCAPems != nil {
		res.PeerCAPems = make([]types.String, len(peeringResource.Peering.PeerCAPems))
		for i, attr := range peeringResource.Peering.PeerCAPems {
			res.PeerCAPems[i] = types.StringValue(attr)
		}
	}
	res.PeerServerName = types.StringValue(peeringResource.Peering.PeerServerName)
	if peeringResource.Peering.PeerServerAddresses != nil {
		res.PeerServerAddresses = make([]types.String, len(peeringResource.Peering.PeerServerAddresses))
		for i, attr := range peeringResource.Peering.PeerServerAddresses {
			res.PeerServerAddresses[i] = types.StringValue(attr)
		}
	}
	{
		data, d := encodePeeringStreamStatus(&peeringResource.Peering.StreamStatus)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.StreamStatus = data
		}
	}
	{
		data, d := encodePeeringRemoteInfo(&peeringResource.Peering.Remote)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Remote = data
		}
	}
	return &res, diags
}

func EncodePeeringToken(peeringToken *structs.PeeringToken) (*PeeringToken, diag.Diagnostics) {
	if peeringToken == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := PeeringToken{}
	res.ID = types.StringValue(peeringToken.ID)
	res.PeerName = types.StringValue(peeringToken.Request.PeerName)
	res.Partition = types.StringValue(peeringToken.Request.Partition)
	if peeringToken.Request.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range peeringToken.Request.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	if peeringToken.Request.ServerExternalAddresses != nil {
		res.ServerExternalAddresses = make([]types.String, len(peeringToken.Request.ServerExternalAddresses))
		for i, attr := range peeringToken.Request.ServerExternalAddresses {
			res.ServerExternalAddresses[i] = types.StringValue(attr)
		}
	}
	res.PeeringToken = types.StringValue(peeringToken.Response.PeeringToken)
	return &res, diags
}

func EncodePeerings(peerings *structs.Peerings) (*Peerings, diag.Diagnostics) {
	if peerings == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Peerings{}
	res.ID = types.StringValue(peerings.ID)
	if peerings.Peerings != nil {
		res.Peerings = make([]*Peering, len(peerings.Peerings))
		for i, attr := range peerings.Peerings {
			{
				data, d := EncodePeering(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Peerings[i] = data
				}
			}
		}
	}
	return &res, diags
}

func EncodePreparedQueryDefinition(preparedQueryDefinition *api.PreparedQueryDefinition) (*PreparedQueryDefinition, diag.Diagnostics) {
	if preparedQueryDefinition == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := PreparedQueryDefinition{}
	res.ID = types.StringValue(preparedQueryDefinition.ID)
	res.Name = types.StringValue(preparedQueryDefinition.Name)
	res.Session = types.StringValue(preparedQueryDefinition.Session)
	res.Token = types.StringValue(preparedQueryDefinition.Token)
	{
		data, d := encodeServiceQuery(&preparedQueryDefinition.Service)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Service = data
		}
	}
	{
		data, d := encodeQueryDNSOptions(&preparedQueryDefinition.DNS)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.DNS = data
		}
	}
	{
		data, d := encodeQueryTemplate(&preparedQueryDefinition.Template)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Template = data
		}
	}
	return &res, diags
}

func EncodeServiceHealth(serviceHealth *structs.ServiceHealth) (*ServiceHealth, diag.Diagnostics) {
	if serviceHealth == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceHealth{}
	res.ID = types.StringValue(serviceHealth.ID)
	if serviceHealth.Services != nil {
		res.Services = make([]*ServiceEntry, len(serviceHealth.Services))
		for i, attr := range serviceHealth.Services {
			{
				data, d := encodeServiceEntry(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Services[i] = data
				}
			}
		}
	}
	return &res, diags
}

func encodeACLAuthMethodNamespaceRule(aclAuthMethodNamespaceRule *api.ACLAuthMethodNamespaceRule) (*ACLAuthMethodNamespaceRule, diag.Diagnostics) {
	if aclAuthMethodNamespaceRule == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ACLAuthMethodNamespaceRule{}
	res.Selector = types.StringValue(aclAuthMethodNamespaceRule.Selector)
	res.BindNamespace = types.StringValue(aclAuthMethodNamespaceRule.BindNamespace)
	return &res, diags
}

func encodeACLLink(aclLink *api.ACLLink) (*ACLLink, diag.Diagnostics) {
	if aclLink == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ACLLink{}
	res.ID = types.StringValue(aclLink.ID)
	res.Name = types.StringValue(aclLink.Name)
	return &res, diags
}

func encodeACLServiceIdentity(aclServiceIdentity *api.ACLServiceIdentity) (*ACLServiceIdentity, diag.Diagnostics) {
	if aclServiceIdentity == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ACLServiceIdentity{}
	res.ServiceName = types.StringValue(aclServiceIdentity.ServiceName)
	if aclServiceIdentity.Datacenters != nil {
		res.Datacenters = make([]types.String, len(aclServiceIdentity.Datacenters))
		for i, attr := range aclServiceIdentity.Datacenters {
			res.Datacenters[i] = types.StringValue(attr)
		}
	}
	return &res, diags
}

func encodeACLNodeIdentity(aclNodeIdentity *api.ACLNodeIdentity) (*ACLNodeIdentity, diag.Diagnostics) {
	if aclNodeIdentity == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ACLNodeIdentity{}
	res.NodeName = types.StringValue(aclNodeIdentity.NodeName)
	res.Datacenter = types.StringValue(aclNodeIdentity.Datacenter)
	return &res, diags
}

func encodeServerHealth(serverHealth *api.ServerHealth) (*ServerHealth, diag.Diagnostics) {
	if serverHealth == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServerHealth{}
	res.ID = types.StringValue(serverHealth.ID)
	res.Name = types.StringValue(serverHealth.Name)
	res.Address = types.StringValue(serverHealth.Address)
	res.SerfStatus = types.StringValue(serverHealth.SerfStatus)
	res.Version = types.StringValue(serverHealth.Version)
	res.Leader = types.BoolValue(serverHealth.Leader)
	res.LastTerm = types.Int64Value(int64(serverHealth.LastTerm))
	res.LastIndex = types.Int64Value(int64(serverHealth.LastIndex))
	res.Healthy = types.BoolValue(serverHealth.Healthy)
	res.Voter = types.BoolValue(serverHealth.Voter)
	res.StableSince = types.StringValue(serverHealth.StableSince.Format(time.RFC3339))
	return &res, diags
}

func encodeAgentService(agentService *api.AgentService) (*AgentService, diag.Diagnostics) {
	if agentService == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := AgentService{}
	res.ID = types.StringValue(agentService.ID)
	return &res, diags
}

func encodeLocality(locality *api.Locality) (*Locality, diag.Diagnostics) {
	if locality == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Locality{}
	res.Region = types.StringValue(locality.Region)
	res.Zone = types.StringValue(locality.Zone)
	return &res, diags
}

func encodeServiceAddress(serviceAddress *api.ServiceAddress) (*ServiceAddress, diag.Diagnostics) {
	if serviceAddress == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceAddress{}
	res.Address = types.StringValue(serviceAddress.Address)
	res.Port = types.Int64Value(int64(serviceAddress.Port))
	return &res, diags
}

func encodeWeights(weights *api.Weights) (*Weights, diag.Diagnostics) {
	if weights == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Weights{}
	res.Passing = types.Int64Value(int64(weights.Passing))
	res.Warning = types.Int64Value(int64(weights.Warning))
	return &res, diags
}

func encodeAgentServiceConnectProxyConfig(agentServiceConnectProxyConfig *api.AgentServiceConnectProxyConfig) (*AgentServiceConnectProxyConfig, diag.Diagnostics) {
	if agentServiceConnectProxyConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := AgentServiceConnectProxyConfig{}
	if agentServiceConnectProxyConfig.EnvoyExtensions != nil {
		res.EnvoyExtensions = make([]*EnvoyExtension, len(agentServiceConnectProxyConfig.EnvoyExtensions))
		for i, attr := range agentServiceConnectProxyConfig.EnvoyExtensions {
			{
				data, d := encodeEnvoyExtension(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.EnvoyExtensions[i] = data
				}
			}
		}
	}
	res.DestinationServiceName = types.StringValue(agentServiceConnectProxyConfig.DestinationServiceName)
	res.DestinationServiceID = types.StringValue(agentServiceConnectProxyConfig.DestinationServiceID)
	res.LocalServiceAddress = types.StringValue(agentServiceConnectProxyConfig.LocalServiceAddress)
	res.LocalServicePort = types.Int64Value(int64(agentServiceConnectProxyConfig.LocalServicePort))
	res.LocalServiceSocketPath = types.StringValue(agentServiceConnectProxyConfig.LocalServiceSocketPath)
	res.Mode = types.StringValue(string(agentServiceConnectProxyConfig.Mode))
	{
		data, d := encodeTransparentProxyConfig(agentServiceConnectProxyConfig.TransparentProxy)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.TransparentProxy = data
		}
	}
	if agentServiceConnectProxyConfig.Config != nil {
		data, err := json.Marshal(agentServiceConnectProxyConfig.Config)
		if err != nil {
			panic(err)
		}
		res.Config = types.StringValue(string(data))
	}
	if agentServiceConnectProxyConfig.Upstreams != nil {
		res.Upstreams = make([]*Upstream, len(agentServiceConnectProxyConfig.Upstreams))
		for i, attr := range agentServiceConnectProxyConfig.Upstreams {
			{
				data, d := encodeUpstream(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Upstreams[i] = data
				}
			}
		}
	}
	{
		data, d := encodeMeshGatewayConfig(&agentServiceConnectProxyConfig.MeshGateway)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.MeshGateway = data
		}
	}
	{
		data, d := encodeExposeConfig(&agentServiceConnectProxyConfig.Expose)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Expose = data
		}
	}
	{
		data, d := encodeAccessLogsConfig(agentServiceConnectProxyConfig.AccessLogs)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.AccessLogs = data
		}
	}
	return &res, diags
}

func encodeHealthCheck(healthCheck *api.HealthCheck) (*HealthCheck, diag.Diagnostics) {
	if healthCheck == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := HealthCheck{}
	res.Node = types.StringValue(healthCheck.Node)
	res.CheckID = types.StringValue(healthCheck.CheckID)
	res.Name = types.StringValue(healthCheck.Name)
	res.Status = types.StringValue(healthCheck.Status)
	res.Notes = types.StringValue(healthCheck.Notes)
	res.Output = types.StringValue(healthCheck.Output)
	res.ServiceID = types.StringValue(healthCheck.ServiceID)
	res.ServiceName = types.StringValue(healthCheck.ServiceName)
	if healthCheck.ServiceTags != nil {
		res.ServiceTags = make([]types.String, len(healthCheck.ServiceTags))
		for i, attr := range healthCheck.ServiceTags {
			res.ServiceTags[i] = types.StringValue(attr)
		}
	}
	res.Type = types.StringValue(healthCheck.Type)
	res.Namespace = types.StringValue(healthCheck.Namespace)
	res.Partition = types.StringValue(healthCheck.Partition)
	res.ExposedPort = types.Int64Value(int64(healthCheck.ExposedPort))
	res.PeerName = types.StringValue(healthCheck.PeerName)
	{
		data, d := encodeHealthCheckDefinition(&healthCheck.Definition)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Definition = data
		}
	}
	return &res, diags
}

func encodeHttpBasicAuth(httpBasicAuth *api.HttpBasicAuth) (*HttpBasicAuth, diag.Diagnostics) {
	if httpBasicAuth == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := HttpBasicAuth{}
	res.Username = types.StringValue(httpBasicAuth.Username)
	res.Password = types.StringValue(httpBasicAuth.Password)
	return &res, diags
}

func encodeTLSConfig(tlsConfig *api.TLSConfig) (*TLSConfig, diag.Diagnostics) {
	if tlsConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := TLSConfig{}
	res.Address = types.StringValue(tlsConfig.Address)
	res.CAFile = types.StringValue(tlsConfig.CAFile)
	res.CAPath = types.StringValue(tlsConfig.CAPath)
	res.CAPem = types.StringValue(string(tlsConfig.CAPem))
	res.CertFile = types.StringValue(tlsConfig.CertFile)
	res.CertPEM = types.StringValue(string(tlsConfig.CertPEM))
	res.KeyFile = types.StringValue(tlsConfig.KeyFile)
	res.KeyPEM = types.StringValue(string(tlsConfig.KeyPEM))
	res.InsecureSkipVerify = types.BoolValue(tlsConfig.InsecureSkipVerify)
	return &res, diags
}

func encodeKVPair(kvPair *api.KVPair) (*KVPair, diag.Diagnostics) {
	if kvPair == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := KVPair{}
	res.Key = types.StringValue(kvPair.Key)
	res.Flags = types.Int64Value(int64(kvPair.Flags))
	res.Value = types.StringValue(string(kvPair.Value))
	res.Namespace = types.StringValue(kvPair.Namespace)
	res.Partition = types.StringValue(kvPair.Partition)
	return &res, diags
}

func encodeNamespaceACLConfig(namespaceAclConfig *api.NamespaceACLConfig) (*NamespaceACLConfig, diag.Diagnostics) {
	if namespaceAclConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := NamespaceACLConfig{}
	if namespaceAclConfig.PolicyDefaults != nil {
		res.PolicyDefaults = make([]*ACLLink, len(namespaceAclConfig.PolicyDefaults))
		for i, attr := range namespaceAclConfig.PolicyDefaults {
			{
				data, d := encodeACLLink(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.PolicyDefaults[i] = data
				}
			}
		}
	}
	if namespaceAclConfig.RoleDefaults != nil {
		res.RoleDefaults = make([]*ACLLink, len(namespaceAclConfig.RoleDefaults))
		for i, attr := range namespaceAclConfig.RoleDefaults {
			{
				data, d := encodeACLLink(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.RoleDefaults[i] = data
				}
			}
		}
	}
	return &res, diags
}

func encodeSerfMember(serfMember *api.SerfMember) (*SerfMember, diag.Diagnostics) {
	if serfMember == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := SerfMember{}
	res.ID = types.StringValue(serfMember.ID)
	res.Name = types.StringValue(serfMember.Name)
	res.Port = types.Int64Value(int64(serfMember.Port))
	res.Datacenter = types.StringValue(serfMember.Datacenter)
	res.Role = types.StringValue(serfMember.Role)
	res.Build = types.StringValue(serfMember.Build)
	res.Protocol = types.Int64Value(int64(serfMember.Protocol))
	res.Status = types.StringValue(serfMember.Status)
	res.RTT = types.StringValue(serfMember.RTT.String())
	return &res, diags
}

func encodeNode(node *api.Node) (*Node, diag.Diagnostics) {
	if node == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Node{}
	res.ID = types.StringValue(node.ID)
	res.Node = types.StringValue(node.Node)
	res.Address = types.StringValue(node.Address)
	res.Datacenter = types.StringValue(node.Datacenter)
	if node.TaggedAddresses != nil {
		res.TaggedAddresses = map[string]types.String{}
		for k, v := range node.TaggedAddresses {
			res.TaggedAddresses[k] = types.StringValue(v)
		}
	}
	if node.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range node.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	res.Partition = types.StringValue(node.Partition)
	res.PeerName = types.StringValue(node.PeerName)
	{
		data, d := encodeLocality(node.Locality)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Locality = data
		}
	}
	return &res, diags
}

func encodePeeringStreamStatus(peeringStreamStatus *api.PeeringStreamStatus) (*PeeringStreamStatus, diag.Diagnostics) {
	if peeringStreamStatus == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := PeeringStreamStatus{}
	if peeringStreamStatus.ImportedServices != nil {
		res.ImportedServices = make([]types.String, len(peeringStreamStatus.ImportedServices))
		for i, attr := range peeringStreamStatus.ImportedServices {
			res.ImportedServices[i] = types.StringValue(attr)
		}
	}
	if peeringStreamStatus.ExportedServices != nil {
		res.ExportedServices = make([]types.String, len(peeringStreamStatus.ExportedServices))
		for i, attr := range peeringStreamStatus.ExportedServices {
			res.ExportedServices[i] = types.StringValue(attr)
		}
	}
	if peeringStreamStatus.LastHeartbeat != nil {
		res.LastHeartbeat = types.StringValue(peeringStreamStatus.LastHeartbeat.Format(time.RFC3339))
	}
	if peeringStreamStatus.LastReceive != nil {
		res.LastReceive = types.StringValue(peeringStreamStatus.LastReceive.Format(time.RFC3339))
	}
	if peeringStreamStatus.LastSend != nil {
		res.LastSend = types.StringValue(peeringStreamStatus.LastSend.Format(time.RFC3339))
	}
	return &res, diags
}

func encodePeeringRemoteInfo(peeringRemoteInfo *api.PeeringRemoteInfo) (*PeeringRemoteInfo, diag.Diagnostics) {
	if peeringRemoteInfo == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := PeeringRemoteInfo{}
	res.Partition = types.StringValue(peeringRemoteInfo.Partition)
	res.Datacenter = types.StringValue(peeringRemoteInfo.Datacenter)
	{
		data, d := encodeLocality(peeringRemoteInfo.Locality)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Locality = data
		}
	}
	return &res, diags
}

func encodeServiceQuery(serviceQuery *api.ServiceQuery) (*ServiceQuery, diag.Diagnostics) {
	if serviceQuery == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceQuery{}
	res.Service = types.StringValue(serviceQuery.Service)
	res.SamenessGroup = types.StringValue(serviceQuery.SamenessGroup)
	res.Namespace = types.StringValue(serviceQuery.Namespace)
	res.Partition = types.StringValue(serviceQuery.Partition)
	res.Near = types.StringValue(serviceQuery.Near)
	{
		data, d := encodeQueryFailoverOptions(&serviceQuery.Failover)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Failover = data
		}
	}
	if serviceQuery.IgnoreCheckIDs != nil {
		res.IgnoreCheckIDs = make([]types.String, len(serviceQuery.IgnoreCheckIDs))
		for i, attr := range serviceQuery.IgnoreCheckIDs {
			res.IgnoreCheckIDs[i] = types.StringValue(attr)
		}
	}
	res.OnlyPassing = types.BoolValue(serviceQuery.OnlyPassing)
	if serviceQuery.Tags != nil {
		res.Tags = make([]types.String, len(serviceQuery.Tags))
		for i, attr := range serviceQuery.Tags {
			res.Tags[i] = types.StringValue(attr)
		}
	}
	if serviceQuery.NodeMeta != nil {
		res.NodeMeta = map[string]types.String{}
		for k, v := range serviceQuery.NodeMeta {
			res.NodeMeta[k] = types.StringValue(v)
		}
	}
	if serviceQuery.ServiceMeta != nil {
		res.ServiceMeta = map[string]types.String{}
		for k, v := range serviceQuery.ServiceMeta {
			res.ServiceMeta[k] = types.StringValue(v)
		}
	}
	res.Connect = types.BoolValue(serviceQuery.Connect)
	return &res, diags
}

func encodeQueryDNSOptions(queryDnsOptions *api.QueryDNSOptions) (*QueryDNSOptions, diag.Diagnostics) {
	if queryDnsOptions == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := QueryDNSOptions{}
	res.TTL = types.StringValue(queryDnsOptions.TTL)
	return &res, diags
}

func encodeQueryTemplate(queryTemplate *api.QueryTemplate) (*QueryTemplate, diag.Diagnostics) {
	if queryTemplate == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := QueryTemplate{}
	res.Type = types.StringValue(queryTemplate.Type)
	res.Regexp = types.StringValue(queryTemplate.Regexp)
	res.RemoveEmptyTags = types.BoolValue(queryTemplate.RemoveEmptyTags)
	return &res, diags
}

func encodeServiceEntry(serviceEntry *api.ServiceEntry) (*ServiceEntry, diag.Diagnostics) {
	if serviceEntry == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceEntry{}
	return &res, diags
}

func encodeEnvoyExtension(envoyExtension *api.EnvoyExtension) (*EnvoyExtension, diag.Diagnostics) {
	if envoyExtension == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := EnvoyExtension{}
	res.Name = types.StringValue(envoyExtension.Name)
	res.Required = types.BoolValue(envoyExtension.Required)
	if envoyExtension.Arguments != nil {
		data, err := json.Marshal(envoyExtension.Arguments)
		if err != nil {
			panic(err)
		}
		res.Arguments = types.StringValue(string(data))
	}
	res.ConsulVersion = types.StringValue(envoyExtension.ConsulVersion)
	res.EnvoyVersion = types.StringValue(envoyExtension.EnvoyVersion)
	return &res, diags
}

func encodeTransparentProxyConfig(transparentProxyConfig *api.TransparentProxyConfig) (*TransparentProxyConfig, diag.Diagnostics) {
	if transparentProxyConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := TransparentProxyConfig{}
	res.OutboundListenerPort = types.Int64Value(int64(transparentProxyConfig.OutboundListenerPort))
	res.DialedDirectly = types.BoolValue(transparentProxyConfig.DialedDirectly)
	return &res, diags
}

func encodeUpstream(upstream *api.Upstream) (*Upstream, diag.Diagnostics) {
	if upstream == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Upstream{}
	res.DestinationType = types.StringValue(string(upstream.DestinationType))
	res.DestinationPartition = types.StringValue(upstream.DestinationPartition)
	res.DestinationNamespace = types.StringValue(upstream.DestinationNamespace)
	res.DestinationPeer = types.StringValue(upstream.DestinationPeer)
	res.DestinationName = types.StringValue(upstream.DestinationName)
	res.Datacenter = types.StringValue(upstream.Datacenter)
	res.LocalBindAddress = types.StringValue(upstream.LocalBindAddress)
	res.LocalBindPort = types.Int64Value(int64(upstream.LocalBindPort))
	res.LocalBindSocketPath = types.StringValue(upstream.LocalBindSocketPath)
	res.LocalBindSocketMode = types.StringValue(upstream.LocalBindSocketMode)
	if upstream.Config != nil {
		data, err := json.Marshal(upstream.Config)
		if err != nil {
			panic(err)
		}
		res.Config = types.StringValue(string(data))
	}
	{
		data, d := encodeMeshGatewayConfig(&upstream.MeshGateway)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.MeshGateway = data
		}
	}
	res.CentrallyConfigured = types.BoolValue(upstream.CentrallyConfigured)
	return &res, diags
}

func encodeMeshGatewayConfig(meshGatewayConfig *api.MeshGatewayConfig) (*MeshGatewayConfig, diag.Diagnostics) {
	if meshGatewayConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := MeshGatewayConfig{}
	res.Mode = types.StringValue(string(meshGatewayConfig.Mode))
	return &res, diags
}

func encodeExposeConfig(exposeConfig *api.ExposeConfig) (*ExposeConfig, diag.Diagnostics) {
	if exposeConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ExposeConfig{}
	res.Checks = types.BoolValue(exposeConfig.Checks)
	if exposeConfig.Paths != nil {
		res.Paths = make([]*ExposePath, len(exposeConfig.Paths))
		for i, attr := range exposeConfig.Paths {
			{
				data, d := encodeExposePath(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Paths[i] = data
				}
			}
		}
	}
	return &res, diags
}

func encodeAccessLogsConfig(accessLogsConfig *api.AccessLogsConfig) (*AccessLogsConfig, diag.Diagnostics) {
	if accessLogsConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := AccessLogsConfig{}
	res.Enabled = types.BoolValue(accessLogsConfig.Enabled)
	res.DisableListenerLogs = types.BoolValue(accessLogsConfig.DisableListenerLogs)
	res.Type = types.StringValue(string(accessLogsConfig.Type))
	res.Path = types.StringValue(accessLogsConfig.Path)
	res.JSONFormat = types.StringValue(accessLogsConfig.JSONFormat)
	res.TextFormat = types.StringValue(accessLogsConfig.TextFormat)
	return &res, diags
}

func encodeHealthCheckDefinition(healthCheckDefinition *api.HealthCheckDefinition) (*HealthCheckDefinition, diag.Diagnostics) {
	if healthCheckDefinition == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := HealthCheckDefinition{}
	res.HTTP = types.StringValue(healthCheckDefinition.HTTP)
	if healthCheckDefinition.Header != nil {
		res.Header = map[string][]types.String{}
		for k, v := range healthCheckDefinition.Header {
			if v != nil {
				res.Header[k] = make([]types.String, len(v))
				for i, attr := range v {
					res.Header[k][i] = types.StringValue(attr)
				}
			}
		}
	}
	res.Method = types.StringValue(healthCheckDefinition.Method)
	res.Body = types.StringValue(healthCheckDefinition.Body)
	res.TLSServerName = types.StringValue(healthCheckDefinition.TLSServerName)
	res.TLSSkipVerify = types.BoolValue(healthCheckDefinition.TLSSkipVerify)
	res.TCP = types.StringValue(healthCheckDefinition.TCP)
	res.UDP = types.StringValue(healthCheckDefinition.UDP)
	res.GRPC = types.StringValue(healthCheckDefinition.GRPC)
	res.OSService = types.StringValue(healthCheckDefinition.OSService)
	res.GRPCUseTLS = types.BoolValue(healthCheckDefinition.GRPCUseTLS)
	res.IntervalDuration = types.StringValue(healthCheckDefinition.IntervalDuration.String())
	res.TimeoutDuration = types.StringValue(healthCheckDefinition.TimeoutDuration.String())
	res.DeregisterCriticalServiceAfterDuration = types.StringValue(healthCheckDefinition.DeregisterCriticalServiceAfterDuration.String())
	return &res, diags
}

func encodeQueryFailoverOptions(queryFailoverOptions *api.QueryFailoverOptions) (*QueryFailoverOptions, diag.Diagnostics) {
	if queryFailoverOptions == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := QueryFailoverOptions{}
	res.NearestN = types.Int64Value(int64(queryFailoverOptions.NearestN))
	if queryFailoverOptions.Datacenters != nil {
		res.Datacenters = make([]types.String, len(queryFailoverOptions.Datacenters))
		for i, attr := range queryFailoverOptions.Datacenters {
			res.Datacenters[i] = types.StringValue(attr)
		}
	}
	if queryFailoverOptions.Targets != nil {
		res.Targets = make([]*QueryFailoverTarget, len(queryFailoverOptions.Targets))
		for i, attr := range queryFailoverOptions.Targets {
			{
				data, d := encodeQueryFailoverTarget(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Targets[i] = data
				}
			}
		}
	}
	return &res, diags
}

func encodeExposePath(exposePath *api.ExposePath) (*ExposePath, diag.Diagnostics) {
	if exposePath == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ExposePath{}
	res.ListenerPort = types.Int64Value(int64(exposePath.ListenerPort))
	res.Path = types.StringValue(exposePath.Path)
	res.LocalPathPort = types.Int64Value(int64(exposePath.LocalPathPort))
	res.Protocol = types.StringValue(exposePath.Protocol)
	res.ParsedFromCheck = types.BoolValue(exposePath.ParsedFromCheck)
	return &res, diags
}

func encodeQueryFailoverTarget(queryFailoverTarget *api.QueryFailoverTarget) (*QueryFailoverTarget, diag.Diagnostics) {
	if queryFailoverTarget == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := QueryFailoverTarget{}
	res.Peer = types.StringValue(queryFailoverTarget.Peer)
	res.Datacenter = types.StringValue(queryFailoverTarget.Datacenter)
	res.Partition = types.StringValue(queryFailoverTarget.Partition)
	res.Namespace = types.StringValue(queryFailoverTarget.Namespace)
	return &res, diags
}
