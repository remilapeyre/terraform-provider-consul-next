/*
Code generated by github-terraform-generator; DO NOT EDIT.
Any modifications will be overwritten
*/

package models

import (
	"context"
	"encoding/json"
	"fmt"
	api "github.com/hashicorp/consul/api"
	diag "github.com/hashicorp/terraform-plugin-framework/diag"
	types "github.com/hashicorp/terraform-plugin-framework/types"
	structs "github.com/remilapeyre/terraform-provider-consul-next/internal/structs"
	"time"
)

type Setter interface {
	Set(context.Context, interface{}) diag.Diagnostics
}

func Set[Model *structs.ACLAuthMethod | *api.ACLBindingRule | *api.ACLPolicy | *api.ACLRole | *structs.ACLToken | *structs.ACLTokenPolicyAttachment | *structs.ACLTokenRoleAttachment | *structs.ACLTokenSecretID | *api.APIGatewayConfigEntry | *structs.AgentConfig | *api.Area | *structs.AutopilotConfig | *structs.AutopilotHealth | *structs.CAConfig | *api.CatalogNode | *api.CatalogService | *api.Config | *structs.ConfigEntry | *structs.Datacenters | *api.ExportedServicesConfigEntry | *api.HTTPRouteConfigEntry | *api.IngressGatewayConfigEntry | *api.InlineCertificateConfigEntry | *api.JWTProviderConfigEntry | *structs.KeyPrefix | *structs.Keys | *api.MeshConfigEntry | *api.Namespace | *structs.NamespacePolicyAttachment | *structs.NamespaceRoleAttachment | *structs.NetworkAreaMembers | *structs.NetworkSegments | *structs.Nodes | *api.OperatorHealthReply | *api.Partition | *api.Peering | *structs.PeeringResource | *structs.PeeringToken | *structs.Peerings | *api.PreparedQueryDefinition | *structs.ProxyConfigEntry | *api.RateLimitIPConfigEntry | *api.SamenessGroupConfigEntry | *structs.ServiceConfigEntry | *structs.ServiceHealth | *api.ServiceIntentionsConfigEntry | *api.ServiceResolverConfigEntry | *structs.ServiceRouterConfigEntry | *api.ServiceSplitterConfigEntry | *api.TCPRouteConfigEntry | *api.TerminatingGatewayConfigEntry](ctx context.Context, setter Setter, obj Model) diag.Diagnostics {
	var diags diag.Diagnostics
	var converted interface{}
	switch o := any(obj).(type) {
	case *structs.ACLAuthMethod:
		converted, diags = EncodeACLAuthMethod(o)
	case *api.ACLBindingRule:
		converted, diags = EncodeACLBindingRule(o)
	case *api.ACLPolicy:
		converted, diags = EncodeACLPolicy(o)
	case *api.ACLRole:
		converted, diags = EncodeACLRole(o)
	case *structs.ACLToken:
		converted, diags = EncodeACLToken(o)
	case *structs.ACLTokenPolicyAttachment:
		converted, diags = EncodeACLTokenPolicyAttachment(o)
	case *structs.ACLTokenRoleAttachment:
		converted, diags = EncodeACLTokenRoleAttachment(o)
	case *structs.ACLTokenSecretID:
		converted, diags = EncodeACLTokenSecretID(o)
	case *api.APIGatewayConfigEntry:
		converted, diags = EncodeAPIGatewayConfigEntry(o)
	case *structs.AgentConfig:
		converted, diags = EncodeAgentConfig(o)
	case *api.Area:
		converted, diags = EncodeArea(o)
	case *structs.AutopilotConfig:
		converted, diags = EncodeAutopilotConfig(o)
	case *structs.AutopilotHealth:
		converted, diags = EncodeAutopilotHealth(o)
	case *structs.CAConfig:
		converted, diags = EncodeCAConfig(o)
	case *api.CatalogNode:
		converted, diags = EncodeCatalogNode(o)
	case *api.CatalogService:
		converted, diags = EncodeCatalogService(o)
	case *api.Config:
		converted, diags = EncodeConfig(o)
	case *structs.ConfigEntry:
		converted, diags = EncodeConfigEntry(o)
	case *structs.Datacenters:
		converted, diags = EncodeDatacenters(o)
	case *api.ExportedServicesConfigEntry:
		converted, diags = EncodeExportedServicesConfigEntry(o)
	case *api.HTTPRouteConfigEntry:
		converted, diags = EncodeHTTPRouteConfigEntry(o)
	case *api.IngressGatewayConfigEntry:
		converted, diags = EncodeIngressGatewayConfigEntry(o)
	case *api.InlineCertificateConfigEntry:
		converted, diags = EncodeInlineCertificateConfigEntry(o)
	case *api.JWTProviderConfigEntry:
		converted, diags = EncodeJWTProviderConfigEntry(o)
	case *structs.KeyPrefix:
		converted, diags = EncodeKeyPrefix(o)
	case *structs.Keys:
		converted, diags = EncodeKeys(o)
	case *api.MeshConfigEntry:
		converted, diags = EncodeMeshConfigEntry(o)
	case *api.Namespace:
		converted, diags = EncodeNamespace(o)
	case *structs.NamespacePolicyAttachment:
		converted, diags = EncodeNamespacePolicyAttachment(o)
	case *structs.NamespaceRoleAttachment:
		converted, diags = EncodeNamespaceRoleAttachment(o)
	case *structs.NetworkAreaMembers:
		converted, diags = EncodeNetworkAreaMembers(o)
	case *structs.NetworkSegments:
		converted, diags = EncodeNetworkSegments(o)
	case *structs.Nodes:
		converted, diags = EncodeNodes(o)
	case *api.OperatorHealthReply:
		converted, diags = EncodeOperatorHealthReply(o)
	case *api.Partition:
		converted, diags = EncodePartition(o)
	case *api.Peering:
		converted, diags = EncodePeering(o)
	case *structs.PeeringResource:
		converted, diags = EncodePeeringResource(o)
	case *structs.PeeringToken:
		converted, diags = EncodePeeringToken(o)
	case *structs.Peerings:
		converted, diags = EncodePeerings(o)
	case *api.PreparedQueryDefinition:
		converted, diags = EncodePreparedQueryDefinition(o)
	case *structs.ProxyConfigEntry:
		converted, diags = EncodeProxyConfigEntry(o)
	case *api.RateLimitIPConfigEntry:
		converted, diags = EncodeRateLimitIPConfigEntry(o)
	case *api.SamenessGroupConfigEntry:
		converted, diags = EncodeSamenessGroupConfigEntry(o)
	case *structs.ServiceConfigEntry:
		converted, diags = EncodeServiceConfigEntry(o)
	case *structs.ServiceHealth:
		converted, diags = EncodeServiceHealth(o)
	case *api.ServiceIntentionsConfigEntry:
		converted, diags = EncodeServiceIntentionsConfigEntry(o)
	case *api.ServiceResolverConfigEntry:
		converted, diags = EncodeServiceResolverConfigEntry(o)
	case *structs.ServiceRouterConfigEntry:
		converted, diags = EncodeServiceRouterConfigEntry(o)
	case *api.ServiceSplitterConfigEntry:
		converted, diags = EncodeServiceSplitterConfigEntry(o)
	case *api.TCPRouteConfigEntry:
		converted, diags = EncodeTCPRouteConfigEntry(o)
	case *api.TerminatingGatewayConfigEntry:
		converted, diags = EncodeTerminatingGatewayConfigEntry(o)
	default:
		diags.AddError("unsupported object type", fmt.Sprintf("%T is not supported in %s.Set(). Please report this issue to the provider developers.", obj, "models"))
		return diags
	}
	diags.Append(setter.Set(ctx, converted)...)
	return diags
}

func EncodeACLAuthMethod(aclAuthMethod *structs.ACLAuthMethod) (*ACLAuthMethod, diag.Diagnostics) {
	if aclAuthMethod == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ACLAuthMethod{}
	res.ID = types.StringValue(aclAuthMethod.ID)
	res.Name = types.StringValue(aclAuthMethod.Method.Name)
	res.Type = types.StringValue(aclAuthMethod.Method.Type)
	res.DisplayName = types.StringValue(aclAuthMethod.Method.DisplayName)
	res.Description = types.StringValue(aclAuthMethod.Method.Description)
	res.MaxTokenTTL = types.StringValue(aclAuthMethod.Method.MaxTokenTTL.String())
	res.TokenLocality = types.StringValue(aclAuthMethod.Method.TokenLocality)
	if aclAuthMethod.Method.Config != nil {
		data, err := json.Marshal(aclAuthMethod.Method.Config)
		if err != nil {
			panic(err)
		}
		res.Config = types.StringValue(string(data))
	}
	if aclAuthMethod.Method.NamespaceRules != nil {
		res.NamespaceRules = make([]*ACLAuthMethodNamespaceRule, len(aclAuthMethod.Method.NamespaceRules))
		for i, attr := range aclAuthMethod.Method.NamespaceRules {
			{
				data, d := encodeACLAuthMethodNamespaceRule(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.NamespaceRules[i] = data
				}
			}
		}
	}
	res.Namespace = types.StringValue(aclAuthMethod.Method.Namespace)
	res.Partition = types.StringValue(aclAuthMethod.Method.Partition)
	return &res, diags
}

func EncodeACLBindingRule(aclBindingRule *api.ACLBindingRule) (*ACLBindingRule, diag.Diagnostics) {
	if aclBindingRule == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ACLBindingRule{}
	res.ID = types.StringValue(aclBindingRule.ID)
	res.Description = types.StringValue(aclBindingRule.Description)
	res.AuthMethod = types.StringValue(aclBindingRule.AuthMethod)
	res.Selector = types.StringValue(aclBindingRule.Selector)
	res.BindType = types.StringValue(string(aclBindingRule.BindType))
	res.BindName = types.StringValue(aclBindingRule.BindName)
	res.Namespace = types.StringValue(aclBindingRule.Namespace)
	res.Partition = types.StringValue(aclBindingRule.Partition)
	return &res, diags
}

func EncodeACLPolicy(aclPolicy *api.ACLPolicy) (*ACLPolicy, diag.Diagnostics) {
	if aclPolicy == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ACLPolicy{}
	res.ID = types.StringValue(aclPolicy.ID)
	res.Name = types.StringValue(aclPolicy.Name)
	res.Description = types.StringValue(aclPolicy.Description)
	res.Rules = types.StringValue(aclPolicy.Rules)
	if aclPolicy.Datacenters != nil {
		res.Datacenters = make([]types.String, len(aclPolicy.Datacenters))
		for i, attr := range aclPolicy.Datacenters {
			res.Datacenters[i] = types.StringValue(attr)
		}
	}
	res.Namespace = types.StringValue(aclPolicy.Namespace)
	res.Partition = types.StringValue(aclPolicy.Partition)
	return &res, diags
}

func EncodeACLRole(aclRole *api.ACLRole) (*ACLRole, diag.Diagnostics) {
	if aclRole == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ACLRole{}
	res.ID = types.StringValue(aclRole.ID)
	res.Name = types.StringValue(aclRole.Name)
	res.Description = types.StringValue(aclRole.Description)
	if aclRole.Policies != nil {
		res.Policies = make([]*ACLLink, len(aclRole.Policies))
		for i, attr := range aclRole.Policies {
			{
				data, d := encodeACLLink(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Policies[i] = data
				}
			}
		}
	}
	if aclRole.ServiceIdentities != nil {
		res.ServiceIdentities = make([]*ACLServiceIdentity, len(aclRole.ServiceIdentities))
		for i, attr := range aclRole.ServiceIdentities {
			{
				data, d := encodeACLServiceIdentity(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.ServiceIdentities[i] = data
				}
			}
		}
	}
	if aclRole.NodeIdentities != nil {
		res.NodeIdentities = make([]*ACLNodeIdentity, len(aclRole.NodeIdentities))
		for i, attr := range aclRole.NodeIdentities {
			{
				data, d := encodeACLNodeIdentity(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.NodeIdentities[i] = data
				}
			}
		}
	}
	res.Namespace = types.StringValue(aclRole.Namespace)
	res.Partition = types.StringValue(aclRole.Partition)
	return &res, diags
}

func EncodeACLToken(aclToken *structs.ACLToken) (*ACLToken, diag.Diagnostics) {
	if aclToken == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ACLToken{}
	res.ID = types.StringValue(aclToken.ID)
	res.AccessorID = types.StringValue(aclToken.Token.AccessorID)
	res.Description = types.StringValue(aclToken.Token.Description)
	if aclToken.Token.Policies != nil {
		res.Policies = make([]*ACLLink, len(aclToken.Token.Policies))
		for i, attr := range aclToken.Token.Policies {
			{
				data, d := encodeACLLink(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Policies[i] = data
				}
			}
		}
	}
	if aclToken.Token.Roles != nil {
		res.Roles = make([]*ACLLink, len(aclToken.Token.Roles))
		for i, attr := range aclToken.Token.Roles {
			{
				data, d := encodeACLLink(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Roles[i] = data
				}
			}
		}
	}
	if aclToken.Token.ServiceIdentities != nil {
		res.ServiceIdentities = make([]*ACLServiceIdentity, len(aclToken.Token.ServiceIdentities))
		for i, attr := range aclToken.Token.ServiceIdentities {
			{
				data, d := encodeACLServiceIdentity(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.ServiceIdentities[i] = data
				}
			}
		}
	}
	if aclToken.Token.NodeIdentities != nil {
		res.NodeIdentities = make([]*ACLNodeIdentity, len(aclToken.Token.NodeIdentities))
		for i, attr := range aclToken.Token.NodeIdentities {
			{
				data, d := encodeACLNodeIdentity(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.NodeIdentities[i] = data
				}
			}
		}
	}
	res.Local = types.BoolValue(aclToken.Token.Local)
	res.AuthMethod = types.StringValue(aclToken.Token.AuthMethod)
	res.ExpirationTTL = types.StringValue(aclToken.Token.ExpirationTTL.String())
	if aclToken.Token.ExpirationTime != nil {
		res.ExpirationTime = types.StringValue(aclToken.Token.ExpirationTime.Format(time.RFC3339))
	}
	res.CreateTime = types.StringValue(aclToken.Token.CreateTime.Format(time.RFC3339))
	res.Namespace = types.StringValue(aclToken.Token.Namespace)
	res.Partition = types.StringValue(aclToken.Token.Partition)
	res.AuthMethodNamespace = types.StringValue(aclToken.Token.AuthMethodNamespace)
	return &res, diags
}

func EncodeACLTokenPolicyAttachment(aclTokenPolicyAttachment *structs.ACLTokenPolicyAttachment) (*ACLTokenPolicyAttachment, diag.Diagnostics) {
	if aclTokenPolicyAttachment == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ACLTokenPolicyAttachment{}
	res.ID = types.StringValue(aclTokenPolicyAttachment.ID)
	res.TokenID = types.StringValue(aclTokenPolicyAttachment.TokenID)
	{
		data, d := encodeACLLink(&aclTokenPolicyAttachment.Policy)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Policy = data
		}
	}
	return &res, diags
}

func EncodeACLTokenRoleAttachment(aclTokenRoleAttachment *structs.ACLTokenRoleAttachment) (*ACLTokenRoleAttachment, diag.Diagnostics) {
	if aclTokenRoleAttachment == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ACLTokenRoleAttachment{}
	res.ID = types.StringValue(aclTokenRoleAttachment.ID)
	res.TokenID = types.StringValue(aclTokenRoleAttachment.TokenID)
	{
		data, d := encodeACLLink(&aclTokenRoleAttachment.Role)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Role = data
		}
	}
	return &res, diags
}

func EncodeACLTokenSecretID(aclTokenSecretId *structs.ACLTokenSecretID) (*ACLTokenSecretID, diag.Diagnostics) {
	if aclTokenSecretId == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ACLTokenSecretID{}
	res.ID = types.StringValue(aclTokenSecretId.ID)
	res.AccessorID = types.StringValue(aclTokenSecretId.AccessorID)
	res.SecretID = types.StringValue(aclTokenSecretId.SecretID)
	res.Partition = types.StringValue(aclTokenSecretId.Partition)
	res.Namespace = types.StringValue(aclTokenSecretId.Namespace)
	res.PGPKey = types.StringValue(aclTokenSecretId.PGPKey)
	return &res, diags
}

func EncodeAPIGatewayConfigEntry(apiGatewayConfigEntry *api.APIGatewayConfigEntry) (*APIGatewayConfigEntry, diag.Diagnostics) {
	if apiGatewayConfigEntry == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := APIGatewayConfigEntry{}
	res.Name = types.StringValue(apiGatewayConfigEntry.Name)
	if apiGatewayConfigEntry.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range apiGatewayConfigEntry.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	if apiGatewayConfigEntry.Listeners != nil {
		res.Listeners = make([]*APIGatewayListener, len(apiGatewayConfigEntry.Listeners))
		for i, attr := range apiGatewayConfigEntry.Listeners {
			{
				data, d := encodeAPIGatewayListener(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Listeners[i] = data
				}
			}
		}
	}
	{
		data, d := encodeConfigEntryStatus(&apiGatewayConfigEntry.Status)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Status = data
		}
	}
	res.Partition = types.StringValue(apiGatewayConfigEntry.Partition)
	res.Namespace = types.StringValue(apiGatewayConfigEntry.Namespace)
	return &res, diags
}

func EncodeAgentConfig(agentConfig *structs.AgentConfig) (*AgentConfig, diag.Diagnostics) {
	if agentConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := AgentConfig{}
	res.ID = types.StringValue(agentConfig.ID)
	res.Datacenter = types.StringValue(agentConfig.Datacenter)
	res.PrimaryDatacenter = types.StringValue(agentConfig.PrimaryDatacenter)
	res.NodeName = types.StringValue(agentConfig.NodeName)
	res.NodeID = types.StringValue(agentConfig.NodeID)
	res.Partition = types.StringPointerValue(agentConfig.Partition)
	res.Revision = types.StringValue(agentConfig.Revision)
	res.Server = types.BoolValue(agentConfig.Server)
	res.Version = types.StringValue(agentConfig.Version)
	res.BuildDate = types.StringValue(agentConfig.BuildDate)
	return &res, diags
}

func EncodeArea(area *api.Area) (*Area, diag.Diagnostics) {
	if area == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Area{}
	res.ID = types.StringValue(area.ID)
	res.PeerDatacenter = types.StringValue(area.PeerDatacenter)
	if area.RetryJoin != nil {
		res.RetryJoin = make([]types.String, len(area.RetryJoin))
		for i, attr := range area.RetryJoin {
			res.RetryJoin[i] = types.StringValue(attr)
		}
	}
	res.UseTLS = types.BoolValue(area.UseTLS)
	return &res, diags
}

func EncodeAutopilotConfig(autopilotConfig *structs.AutopilotConfig) (*AutopilotConfig, diag.Diagnostics) {
	if autopilotConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := AutopilotConfig{}
	res.ID = types.StringValue(autopilotConfig.ID)
	res.CleanupDeadServers = types.BoolValue(autopilotConfig.Config.CleanupDeadServers)
	res.MaxTrailingLogs = types.Int64Value(int64(autopilotConfig.Config.MaxTrailingLogs))
	res.MinQuorum = types.Int64Value(int64(autopilotConfig.Config.MinQuorum))
	res.RedundancyZoneTag = types.StringValue(autopilotConfig.Config.RedundancyZoneTag)
	res.DisableUpgradeMigration = types.BoolValue(autopilotConfig.Config.DisableUpgradeMigration)
	res.UpgradeVersionTag = types.StringValue(autopilotConfig.Config.UpgradeVersionTag)
	return &res, diags
}

func EncodeAutopilotHealth(autopilotHealth *structs.AutopilotHealth) (*AutopilotHealth, diag.Diagnostics) {
	if autopilotHealth == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := AutopilotHealth{}
	res.ID = types.StringValue(autopilotHealth.ID)
	res.Healthy = types.BoolValue(autopilotHealth.AutopilotHealth.Healthy)
	res.FailureTolerance = types.Int64Value(int64(autopilotHealth.AutopilotHealth.FailureTolerance))
	if autopilotHealth.AutopilotHealth.Servers != nil {
		res.Servers = make([]*ServerHealth, len(autopilotHealth.AutopilotHealth.Servers))
		for i, attr := range autopilotHealth.AutopilotHealth.Servers {
			{
				data, d := encodeServerHealth(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Servers[i] = data
				}
			}
		}
	}
	return &res, diags
}

func EncodeCAConfig(caConfig *structs.CAConfig) (*CAConfig, diag.Diagnostics) {
	if caConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := CAConfig{}
	res.ID = types.StringValue(caConfig.ID)
	res.Provider = types.StringValue(caConfig.Config.Provider)
	if caConfig.Config.Config != nil {
		data, err := json.Marshal(caConfig.Config.Config)
		if err != nil {
			panic(err)
		}
		res.Config = types.StringValue(string(data))
	}
	if caConfig.Config.State != nil {
		res.State = map[string]types.String{}
		for k, v := range caConfig.Config.State {
			res.State[k] = types.StringValue(v)
		}
	}
	res.ForceWithoutCrossSigning = types.BoolValue(caConfig.Config.ForceWithoutCrossSigning)
	return &res, diags
}

func EncodeCatalogNode(catalogNode *api.CatalogNode) (*CatalogNode, diag.Diagnostics) {
	if catalogNode == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := CatalogNode{}
	if catalogNode.Services != nil {
		res.Services = map[string]*AgentService{}
		for k, v := range catalogNode.Services {
			{
				data, d := encodeAgentService(v)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Services[k] = data
				}
			}
		}
	}
	res.ID = types.StringValue(catalogNode.Node.ID)
	res.Node = types.StringValue(catalogNode.Node.Node)
	res.Address = types.StringValue(catalogNode.Node.Address)
	res.Datacenter = types.StringValue(catalogNode.Node.Datacenter)
	if catalogNode.Node.TaggedAddresses != nil {
		res.TaggedAddresses = map[string]types.String{}
		for k, v := range catalogNode.Node.TaggedAddresses {
			res.TaggedAddresses[k] = types.StringValue(v)
		}
	}
	if catalogNode.Node.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range catalogNode.Node.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	res.Partition = types.StringValue(catalogNode.Node.Partition)
	res.PeerName = types.StringValue(catalogNode.Node.PeerName)
	{
		data, d := encodeLocality(catalogNode.Node.Locality)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Locality = data
		}
	}
	return &res, diags
}

func EncodeCatalogService(catalogService *api.CatalogService) (*CatalogService, diag.Diagnostics) {
	if catalogService == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := CatalogService{}
	res.ID = types.StringValue(catalogService.ID)
	res.Node = types.StringValue(catalogService.Node)
	res.Address = types.StringValue(catalogService.Address)
	res.Datacenter = types.StringValue(catalogService.Datacenter)
	if catalogService.TaggedAddresses != nil {
		res.TaggedAddresses = map[string]types.String{}
		for k, v := range catalogService.TaggedAddresses {
			res.TaggedAddresses[k] = types.StringValue(v)
		}
	}
	if catalogService.NodeMeta != nil {
		res.NodeMeta = map[string]types.String{}
		for k, v := range catalogService.NodeMeta {
			res.NodeMeta[k] = types.StringValue(v)
		}
	}
	res.ServiceID = types.StringValue(catalogService.ServiceID)
	res.ServiceName = types.StringValue(catalogService.ServiceName)
	res.ServiceAddress = types.StringValue(catalogService.ServiceAddress)
	if catalogService.ServiceTaggedAddresses != nil {
		res.ServiceTaggedAddresses = map[string]*ServiceAddress{}
		for k, v := range catalogService.ServiceTaggedAddresses {
			{
				data, d := encodeServiceAddress(&v)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.ServiceTaggedAddresses[k] = data
				}
			}
		}
	}
	if catalogService.ServiceTags != nil {
		res.ServiceTags = make([]types.String, len(catalogService.ServiceTags))
		for i, attr := range catalogService.ServiceTags {
			res.ServiceTags[i] = types.StringValue(attr)
		}
	}
	if catalogService.ServiceMeta != nil {
		res.ServiceMeta = map[string]types.String{}
		for k, v := range catalogService.ServiceMeta {
			res.ServiceMeta[k] = types.StringValue(v)
		}
	}
	res.ServicePort = types.Int64Value(int64(catalogService.ServicePort))
	{
		data, d := encodeWeights(&catalogService.ServiceWeights)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.ServiceWeights = data
		}
	}
	res.ServiceEnableTagOverride = types.BoolValue(catalogService.ServiceEnableTagOverride)
	{
		data, d := encodeAgentServiceConnectProxyConfig(catalogService.ServiceProxy)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.ServiceProxy = data
		}
	}
	{
		data, d := encodeLocality(catalogService.ServiceLocality)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.ServiceLocality = data
		}
	}
	res.CreateIndex = types.Int64Value(int64(catalogService.CreateIndex))
	if catalogService.Checks != nil {
		res.Checks = make([]*HealthCheck, len(catalogService.Checks))
		for i, attr := range catalogService.Checks {
			{
				data, d := encodeHealthCheck(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Checks[i] = data
				}
			}
		}
	}
	res.ModifyIndex = types.Int64Value(int64(catalogService.ModifyIndex))
	res.Namespace = types.StringValue(catalogService.Namespace)
	res.Partition = types.StringValue(catalogService.Partition)
	return &res, diags
}

func EncodeConfig(config *api.Config) (*Config, diag.Diagnostics) {
	if config == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Config{}
	res.Address = types.StringValue(config.Address)
	res.Scheme = types.StringValue(config.Scheme)
	res.PathPrefix = types.StringValue(config.PathPrefix)
	res.Datacenter = types.StringValue(config.Datacenter)
	{
		data, d := encodeHttpBasicAuth(config.HttpAuth)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.HttpAuth = data
		}
	}
	res.Token = types.StringValue(config.Token)
	res.TokenFile = types.StringValue(config.TokenFile)
	res.Namespace = types.StringValue(config.Namespace)
	res.Partition = types.StringValue(config.Partition)
	{
		data, d := encodeTLSConfig(&config.TLSConfig)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.TLSConfig = data
		}
	}
	return &res, diags
}

func EncodeConfigEntry(configEntry *structs.ConfigEntry) (*ConfigEntry, diag.Diagnostics) {
	if configEntry == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ConfigEntry{}
	res.ID = types.StringValue(configEntry.ID)
	res.Kind = types.StringValue(configEntry.Kind)
	res.Name = types.StringValue(configEntry.Name)
	res.Namespace = types.StringValue(configEntry.Namespace)
	res.Partition = types.StringValue(configEntry.Partition)
	if configEntry.Config != nil {
		data, err := json.Marshal(configEntry.Config)
		if err != nil {
			panic(err)
		}
		res.Config = types.StringValue(string(data))
	}
	if configEntry.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range configEntry.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	return &res, diags
}

func EncodeDatacenters(datacenters *structs.Datacenters) (*Datacenters, diag.Diagnostics) {
	if datacenters == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Datacenters{}
	res.ID = types.StringValue(datacenters.ID)
	if datacenters.Datacenters != nil {
		res.Datacenters = make([]types.String, len(datacenters.Datacenters))
		for i, attr := range datacenters.Datacenters {
			res.Datacenters[i] = types.StringValue(attr)
		}
	}
	return &res, diags
}

func EncodeExportedServicesConfigEntry(exportedServicesConfigEntry *api.ExportedServicesConfigEntry) (*ExportedServicesConfigEntry, diag.Diagnostics) {
	if exportedServicesConfigEntry == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ExportedServicesConfigEntry{}
	res.Name = types.StringValue(exportedServicesConfigEntry.Name)
	res.Partition = types.StringValue(exportedServicesConfigEntry.Partition)
	if exportedServicesConfigEntry.Services != nil {
		res.Services = make([]*ExportedService, len(exportedServicesConfigEntry.Services))
		for i, attr := range exportedServicesConfigEntry.Services {
			{
				data, d := encodeExportedService(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Services[i] = data
				}
			}
		}
	}
	if exportedServicesConfigEntry.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range exportedServicesConfigEntry.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	return &res, diags
}

func EncodeHTTPRouteConfigEntry(httpRouteConfigEntry *api.HTTPRouteConfigEntry) (*HTTPRouteConfigEntry, diag.Diagnostics) {
	if httpRouteConfigEntry == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := HTTPRouteConfigEntry{}
	res.Name = types.StringValue(httpRouteConfigEntry.Name)
	if httpRouteConfigEntry.Parents != nil {
		res.Parents = make([]*ResourceReference, len(httpRouteConfigEntry.Parents))
		for i, attr := range httpRouteConfigEntry.Parents {
			{
				data, d := encodeResourceReference(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Parents[i] = data
				}
			}
		}
	}
	if httpRouteConfigEntry.Rules != nil {
		res.Rules = make([]*HTTPRouteRule, len(httpRouteConfigEntry.Rules))
		for i, attr := range httpRouteConfigEntry.Rules {
			{
				data, d := encodeHTTPRouteRule(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Rules[i] = data
				}
			}
		}
	}
	if httpRouteConfigEntry.Hostnames != nil {
		res.Hostnames = make([]types.String, len(httpRouteConfigEntry.Hostnames))
		for i, attr := range httpRouteConfigEntry.Hostnames {
			res.Hostnames[i] = types.StringValue(attr)
		}
	}
	if httpRouteConfigEntry.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range httpRouteConfigEntry.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	res.Partition = types.StringValue(httpRouteConfigEntry.Partition)
	res.Namespace = types.StringValue(httpRouteConfigEntry.Namespace)
	{
		data, d := encodeConfigEntryStatus(&httpRouteConfigEntry.Status)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Status = data
		}
	}
	return &res, diags
}

func EncodeIngressGatewayConfigEntry(ingressGatewayConfigEntry *api.IngressGatewayConfigEntry) (*IngressGatewayConfigEntry, diag.Diagnostics) {
	if ingressGatewayConfigEntry == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := IngressGatewayConfigEntry{}
	res.Name = types.StringValue(ingressGatewayConfigEntry.Name)
	res.Partition = types.StringValue(ingressGatewayConfigEntry.Partition)
	res.Namespace = types.StringValue(ingressGatewayConfigEntry.Namespace)
	{
		data, d := encodeGatewayTLSConfig(&ingressGatewayConfigEntry.TLS)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.TLS = data
		}
	}
	if ingressGatewayConfigEntry.Listeners != nil {
		res.Listeners = make([]*IngressListener, len(ingressGatewayConfigEntry.Listeners))
		for i, attr := range ingressGatewayConfigEntry.Listeners {
			{
				data, d := encodeIngressListener(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Listeners[i] = data
				}
			}
		}
	}
	if ingressGatewayConfigEntry.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range ingressGatewayConfigEntry.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	{
		data, d := encodeIngressServiceConfig(ingressGatewayConfigEntry.Defaults)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Defaults = data
		}
	}
	return &res, diags
}

func EncodeInlineCertificateConfigEntry(inlineCertificateConfigEntry *api.InlineCertificateConfigEntry) (*InlineCertificateConfigEntry, diag.Diagnostics) {
	if inlineCertificateConfigEntry == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := InlineCertificateConfigEntry{}
	res.Name = types.StringValue(inlineCertificateConfigEntry.Name)
	res.Certificate = types.StringValue(inlineCertificateConfigEntry.Certificate)
	res.PrivateKey = types.StringValue(inlineCertificateConfigEntry.PrivateKey)
	if inlineCertificateConfigEntry.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range inlineCertificateConfigEntry.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	res.Partition = types.StringValue(inlineCertificateConfigEntry.Partition)
	res.Namespace = types.StringValue(inlineCertificateConfigEntry.Namespace)
	return &res, diags
}

func EncodeJWTProviderConfigEntry(jwtProviderConfigEntry *api.JWTProviderConfigEntry) (*JWTProviderConfigEntry, diag.Diagnostics) {
	if jwtProviderConfigEntry == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := JWTProviderConfigEntry{}
	res.Name = types.StringValue(jwtProviderConfigEntry.Name)
	{
		data, d := encodeJSONWebKeySet(jwtProviderConfigEntry.JSONWebKeySet)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.JSONWebKeySet = data
		}
	}
	res.Issuer = types.StringValue(jwtProviderConfigEntry.Issuer)
	if jwtProviderConfigEntry.Audiences != nil {
		res.Audiences = make([]types.String, len(jwtProviderConfigEntry.Audiences))
		for i, attr := range jwtProviderConfigEntry.Audiences {
			res.Audiences[i] = types.StringValue(attr)
		}
	}
	if jwtProviderConfigEntry.Locations != nil {
		res.Locations = make([]*JWTLocation, len(jwtProviderConfigEntry.Locations))
		for i, attr := range jwtProviderConfigEntry.Locations {
			{
				data, d := encodeJWTLocation(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Locations[i] = data
				}
			}
		}
	}
	{
		data, d := encodeJWTForwardingConfig(jwtProviderConfigEntry.Forwarding)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Forwarding = data
		}
	}
	res.ClockSkewSeconds = types.Int64Value(int64(jwtProviderConfigEntry.ClockSkewSeconds))
	{
		data, d := encodeJWTCacheConfig(jwtProviderConfigEntry.CacheConfig)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.CacheConfig = data
		}
	}
	if jwtProviderConfigEntry.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range jwtProviderConfigEntry.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	res.Partition = types.StringValue(jwtProviderConfigEntry.Partition)
	res.Namespace = types.StringValue(jwtProviderConfigEntry.Namespace)
	return &res, diags
}

func EncodeKeyPrefix(keyPrefix *structs.KeyPrefix) (*KeyPrefix, diag.Diagnostics) {
	if keyPrefix == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := KeyPrefix{}
	res.ID = types.StringValue(keyPrefix.ID)
	return &res, diags
}

func EncodeKeys(keys *structs.Keys) (*Keys, diag.Diagnostics) {
	if keys == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Keys{}
	res.ID = types.StringValue(keys.ID)
	if keys.Keys != nil {
		res.Keys = make([]*KVPair, len(keys.Keys))
		for i, attr := range keys.Keys {
			{
				data, d := encodeKVPair(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Keys[i] = data
				}
			}
		}
	}
	return &res, diags
}

func EncodeMeshConfigEntry(meshConfigEntry *api.MeshConfigEntry) (*MeshConfigEntry, diag.Diagnostics) {
	if meshConfigEntry == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := MeshConfigEntry{}
	res.Partition = types.StringValue(meshConfigEntry.Partition)
	res.Namespace = types.StringValue(meshConfigEntry.Namespace)
	{
		data, d := encodeTransparentProxyMeshConfig(&meshConfigEntry.TransparentProxy)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.TransparentProxy = data
		}
	}
	res.AllowEnablingPermissiveMutualTLS = types.BoolValue(meshConfigEntry.AllowEnablingPermissiveMutualTLS)
	{
		data, d := encodeMeshTLSConfig(meshConfigEntry.TLS)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.TLS = data
		}
	}
	{
		data, d := encodeMeshHTTPConfig(meshConfigEntry.HTTP)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.HTTP = data
		}
	}
	{
		data, d := encodePeeringMeshConfig(meshConfigEntry.Peering)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Peering = data
		}
	}
	if meshConfigEntry.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range meshConfigEntry.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	return &res, diags
}

func EncodeNamespace(namespace *api.Namespace) (*Namespace, diag.Diagnostics) {
	if namespace == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Namespace{}
	res.Name = types.StringValue(namespace.Name)
	res.Description = types.StringValue(namespace.Description)
	{
		data, d := encodeNamespaceACLConfig(namespace.ACLs)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.ACLs = data
		}
	}
	if namespace.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range namespace.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	if namespace.DeletedAt != nil {
		res.DeletedAt = types.StringValue(namespace.DeletedAt.Format(time.RFC3339))
	}
	res.Partition = types.StringValue(namespace.Partition)
	return &res, diags
}

func EncodeNamespacePolicyAttachment(namespacePolicyAttachment *structs.NamespacePolicyAttachment) (*NamespacePolicyAttachment, diag.Diagnostics) {
	if namespacePolicyAttachment == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := NamespacePolicyAttachment{}
	res.ID = types.StringValue(namespacePolicyAttachment.ID)
	res.Namespace = types.StringValue(namespacePolicyAttachment.Namespace)
	{
		data, d := encodeACLLink(&namespacePolicyAttachment.Policy)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Policy = data
		}
	}
	return &res, diags
}

func EncodeNamespaceRoleAttachment(namespaceRoleAttachment *structs.NamespaceRoleAttachment) (*NamespaceRoleAttachment, diag.Diagnostics) {
	if namespaceRoleAttachment == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := NamespaceRoleAttachment{}
	res.ID = types.StringValue(namespaceRoleAttachment.ID)
	res.Namespace = types.StringValue(namespaceRoleAttachment.Namespace)
	{
		data, d := encodeACLLink(&namespaceRoleAttachment.Role)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Role = data
		}
	}
	return &res, diags
}

func EncodeNetworkAreaMembers(networkAreaMembers *structs.NetworkAreaMembers) (*NetworkAreaMembers, diag.Diagnostics) {
	if networkAreaMembers == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := NetworkAreaMembers{}
	res.ID = types.StringValue(networkAreaMembers.ID)
	if networkAreaMembers.Members != nil {
		res.Members = make([]*SerfMember, len(networkAreaMembers.Members))
		for i, attr := range networkAreaMembers.Members {
			{
				data, d := encodeSerfMember(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Members[i] = data
				}
			}
		}
	}
	return &res, diags
}

func EncodeNetworkSegments(networkSegments *structs.NetworkSegments) (*NetworkSegments, diag.Diagnostics) {
	if networkSegments == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := NetworkSegments{}
	res.ID = types.StringValue(networkSegments.ID)
	if networkSegments.Segments != nil {
		res.Segments = make([]types.String, len(networkSegments.Segments))
		for i, attr := range networkSegments.Segments {
			res.Segments[i] = types.StringValue(attr)
		}
	}
	return &res, diags
}

func EncodeNodes(nodes *structs.Nodes) (*Nodes, diag.Diagnostics) {
	if nodes == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Nodes{}
	res.ID = types.StringValue(nodes.ID)
	if nodes.Nodes != nil {
		res.Nodes = make([]*Node, len(nodes.Nodes))
		for i, attr := range nodes.Nodes {
			{
				data, d := encodeNode(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Nodes[i] = data
				}
			}
		}
	}
	return &res, diags
}

func EncodeOperatorHealthReply(operatorHealthReply *api.OperatorHealthReply) (*OperatorHealthReply, diag.Diagnostics) {
	if operatorHealthReply == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := OperatorHealthReply{}
	res.Healthy = types.BoolValue(operatorHealthReply.Healthy)
	res.FailureTolerance = types.Int64Value(int64(operatorHealthReply.FailureTolerance))
	if operatorHealthReply.Servers != nil {
		res.Servers = make([]*ServerHealth, len(operatorHealthReply.Servers))
		for i, attr := range operatorHealthReply.Servers {
			{
				data, d := encodeServerHealth(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Servers[i] = data
				}
			}
		}
	}
	return &res, diags
}

func EncodePartition(partition *api.Partition) (*Partition, diag.Diagnostics) {
	if partition == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Partition{}
	res.Name = types.StringValue(partition.Name)
	res.Description = types.StringValue(partition.Description)
	if partition.DeletedAt != nil {
		res.DeletedAt = types.StringValue(partition.DeletedAt.Format(time.RFC3339))
	}
	return &res, diags
}

func EncodePeering(peering *api.Peering) (*Peering, diag.Diagnostics) {
	if peering == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Peering{}
	res.ID = types.StringValue(peering.ID)
	res.Name = types.StringValue(peering.Name)
	res.Partition = types.StringValue(peering.Partition)
	if peering.DeletedAt != nil {
		res.DeletedAt = types.StringValue(peering.DeletedAt.Format(time.RFC3339))
	}
	if peering.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range peering.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	res.State = types.StringValue(string(peering.State))
	res.PeerID = types.StringValue(peering.PeerID)
	if peering.PeerCAPems != nil {
		res.PeerCAPems = make([]types.String, len(peering.PeerCAPems))
		for i, attr := range peering.PeerCAPems {
			res.PeerCAPems[i] = types.StringValue(attr)
		}
	}
	res.PeerServerName = types.StringValue(peering.PeerServerName)
	if peering.PeerServerAddresses != nil {
		res.PeerServerAddresses = make([]types.String, len(peering.PeerServerAddresses))
		for i, attr := range peering.PeerServerAddresses {
			res.PeerServerAddresses[i] = types.StringValue(attr)
		}
	}
	{
		data, d := encodePeeringStreamStatus(&peering.StreamStatus)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.StreamStatus = data
		}
	}
	{
		data, d := encodePeeringRemoteInfo(&peering.Remote)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Remote = data
		}
	}
	return &res, diags
}

func EncodePeeringResource(peeringResource *structs.PeeringResource) (*PeeringResource, diag.Diagnostics) {
	if peeringResource == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := PeeringResource{}
	res.PeeringToken = types.StringValue(peeringResource.PeeringToken)
	res.ID = types.StringValue(peeringResource.Peering.ID)
	res.Name = types.StringValue(peeringResource.Peering.Name)
	res.Partition = types.StringValue(peeringResource.Peering.Partition)
	if peeringResource.Peering.DeletedAt != nil {
		res.DeletedAt = types.StringValue(peeringResource.Peering.DeletedAt.Format(time.RFC3339))
	}
	if peeringResource.Peering.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range peeringResource.Peering.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	res.State = types.StringValue(string(peeringResource.Peering.State))
	res.PeerID = types.StringValue(peeringResource.Peering.PeerID)
	if peeringResource.Peering.PeerCAPems != nil {
		res.PeerCAPems = make([]types.String, len(peeringResource.Peering.PeerCAPems))
		for i, attr := range peeringResource.Peering.PeerCAPems {
			res.PeerCAPems[i] = types.StringValue(attr)
		}
	}
	res.PeerServerName = types.StringValue(peeringResource.Peering.PeerServerName)
	if peeringResource.Peering.PeerServerAddresses != nil {
		res.PeerServerAddresses = make([]types.String, len(peeringResource.Peering.PeerServerAddresses))
		for i, attr := range peeringResource.Peering.PeerServerAddresses {
			res.PeerServerAddresses[i] = types.StringValue(attr)
		}
	}
	{
		data, d := encodePeeringStreamStatus(&peeringResource.Peering.StreamStatus)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.StreamStatus = data
		}
	}
	{
		data, d := encodePeeringRemoteInfo(&peeringResource.Peering.Remote)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Remote = data
		}
	}
	return &res, diags
}

func EncodePeeringToken(peeringToken *structs.PeeringToken) (*PeeringToken, diag.Diagnostics) {
	if peeringToken == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := PeeringToken{}
	res.ID = types.StringValue(peeringToken.ID)
	res.PeerName = types.StringValue(peeringToken.Request.PeerName)
	res.Partition = types.StringValue(peeringToken.Request.Partition)
	if peeringToken.Request.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range peeringToken.Request.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	if peeringToken.Request.ServerExternalAddresses != nil {
		res.ServerExternalAddresses = make([]types.String, len(peeringToken.Request.ServerExternalAddresses))
		for i, attr := range peeringToken.Request.ServerExternalAddresses {
			res.ServerExternalAddresses[i] = types.StringValue(attr)
		}
	}
	res.PeeringToken = types.StringValue(peeringToken.Response.PeeringToken)
	return &res, diags
}

func EncodePeerings(peerings *structs.Peerings) (*Peerings, diag.Diagnostics) {
	if peerings == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Peerings{}
	res.ID = types.StringValue(peerings.ID)
	if peerings.Peerings != nil {
		res.Peerings = make([]*Peering, len(peerings.Peerings))
		for i, attr := range peerings.Peerings {
			{
				data, d := EncodePeering(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Peerings[i] = data
				}
			}
		}
	}
	return &res, diags
}

func EncodePreparedQueryDefinition(preparedQueryDefinition *api.PreparedQueryDefinition) (*PreparedQueryDefinition, diag.Diagnostics) {
	if preparedQueryDefinition == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := PreparedQueryDefinition{}
	res.ID = types.StringValue(preparedQueryDefinition.ID)
	res.Name = types.StringValue(preparedQueryDefinition.Name)
	res.Session = types.StringValue(preparedQueryDefinition.Session)
	res.Token = types.StringValue(preparedQueryDefinition.Token)
	{
		data, d := encodeServiceQuery(&preparedQueryDefinition.Service)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Service = data
		}
	}
	{
		data, d := encodeQueryDNSOptions(&preparedQueryDefinition.DNS)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.DNS = data
		}
	}
	{
		data, d := encodeQueryTemplate(&preparedQueryDefinition.Template)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Template = data
		}
	}
	return &res, diags
}

func EncodeProxyConfigEntry(proxyConfigEntry *structs.ProxyConfigEntry) (*ProxyConfigEntry, diag.Diagnostics) {
	if proxyConfigEntry == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ProxyConfigEntry{}
	res.ID = types.StringValue(proxyConfigEntry.ID)
	res.Name = types.StringValue(proxyConfigEntry.Entry.Name)
	res.Partition = types.StringValue(proxyConfigEntry.Entry.Partition)
	res.Namespace = types.StringValue(proxyConfigEntry.Entry.Namespace)
	res.Mode = types.StringValue(string(proxyConfigEntry.Entry.Mode))
	{
		data, d := encodeTransparentProxyConfig(proxyConfigEntry.Entry.TransparentProxy)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.TransparentProxy = data
		}
	}
	res.MutualTLSMode = types.StringValue(string(proxyConfigEntry.Entry.MutualTLSMode))
	if proxyConfigEntry.Entry.Config != nil {
		data, err := json.Marshal(proxyConfigEntry.Entry.Config)
		if err != nil {
			panic(err)
		}
		res.Config = types.StringValue(string(data))
	}
	{
		data, d := encodeMeshGatewayConfig(&proxyConfigEntry.Entry.MeshGateway)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.MeshGateway = data
		}
	}
	{
		data, d := encodeExposeConfig(&proxyConfigEntry.Entry.Expose)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Expose = data
		}
	}
	{
		data, d := encodeAccessLogsConfig(proxyConfigEntry.Entry.AccessLogs)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.AccessLogs = data
		}
	}
	if proxyConfigEntry.Entry.EnvoyExtensions != nil {
		res.EnvoyExtensions = make([]*EnvoyExtension, len(proxyConfigEntry.Entry.EnvoyExtensions))
		for i, attr := range proxyConfigEntry.Entry.EnvoyExtensions {
			{
				data, d := encodeEnvoyExtension(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.EnvoyExtensions[i] = data
				}
			}
		}
	}
	{
		data, d := encodeServiceResolverFailoverPolicy(proxyConfigEntry.Entry.FailoverPolicy)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.FailoverPolicy = data
		}
	}
	{
		data, d := encodeServiceResolverPrioritizeByLocality(proxyConfigEntry.Entry.PrioritizeByLocality)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.PrioritizeByLocality = data
		}
	}
	if proxyConfigEntry.Entry.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range proxyConfigEntry.Entry.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	return &res, diags
}

func EncodeRateLimitIPConfigEntry(rateLimitIpConfigEntry *api.RateLimitIPConfigEntry) (*RateLimitIPConfigEntry, diag.Diagnostics) {
	if rateLimitIpConfigEntry == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := RateLimitIPConfigEntry{}
	res.Name = types.StringValue(rateLimitIpConfigEntry.Name)
	res.Mode = types.StringValue(rateLimitIpConfigEntry.Mode)
	if rateLimitIpConfigEntry.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range rateLimitIpConfigEntry.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	res.ReadRate = types.Float64Value(float64(rateLimitIpConfigEntry.ReadRate))
	res.WriteRate = types.Float64Value(float64(rateLimitIpConfigEntry.WriteRate))
	{
		data, d := encodeReadWriteRatesConfig(rateLimitIpConfigEntry.ACL)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.ACL = data
		}
	}
	{
		data, d := encodeReadWriteRatesConfig(rateLimitIpConfigEntry.Catalog)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Catalog = data
		}
	}
	{
		data, d := encodeReadWriteRatesConfig(rateLimitIpConfigEntry.ConfigEntry)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.ConfigEntry = data
		}
	}
	{
		data, d := encodeReadWriteRatesConfig(rateLimitIpConfigEntry.ConnectCA)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.ConnectCA = data
		}
	}
	{
		data, d := encodeReadWriteRatesConfig(rateLimitIpConfigEntry.Coordinate)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Coordinate = data
		}
	}
	{
		data, d := encodeReadWriteRatesConfig(rateLimitIpConfigEntry.DiscoveryChain)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.DiscoveryChain = data
		}
	}
	{
		data, d := encodeReadWriteRatesConfig(rateLimitIpConfigEntry.ServerDiscovery)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.ServerDiscovery = data
		}
	}
	{
		data, d := encodeReadWriteRatesConfig(rateLimitIpConfigEntry.Health)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Health = data
		}
	}
	{
		data, d := encodeReadWriteRatesConfig(rateLimitIpConfigEntry.Intention)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Intention = data
		}
	}
	{
		data, d := encodeReadWriteRatesConfig(rateLimitIpConfigEntry.KV)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.KV = data
		}
	}
	{
		data, d := encodeReadWriteRatesConfig(rateLimitIpConfigEntry.Tenancy)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Tenancy = data
		}
	}
	{
		data, d := encodeReadWriteRatesConfig(rateLimitIpConfigEntry.PreparedQuery)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.PreparedQuery = data
		}
	}
	{
		data, d := encodeReadWriteRatesConfig(rateLimitIpConfigEntry.Session)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Session = data
		}
	}
	{
		data, d := encodeReadWriteRatesConfig(rateLimitIpConfigEntry.Txn)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Txn = data
		}
	}
	{
		data, d := encodeReadWriteRatesConfig(rateLimitIpConfigEntry.AutoConfig)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.AutoConfig = data
		}
	}
	{
		data, d := encodeReadWriteRatesConfig(rateLimitIpConfigEntry.FederationState)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.FederationState = data
		}
	}
	{
		data, d := encodeReadWriteRatesConfig(rateLimitIpConfigEntry.Internal)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Internal = data
		}
	}
	{
		data, d := encodeReadWriteRatesConfig(rateLimitIpConfigEntry.PeerStream)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.PeerStream = data
		}
	}
	{
		data, d := encodeReadWriteRatesConfig(rateLimitIpConfigEntry.Peering)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Peering = data
		}
	}
	{
		data, d := encodeReadWriteRatesConfig(rateLimitIpConfigEntry.DataPlane)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.DataPlane = data
		}
	}
	{
		data, d := encodeReadWriteRatesConfig(rateLimitIpConfigEntry.DNS)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.DNS = data
		}
	}
	{
		data, d := encodeReadWriteRatesConfig(rateLimitIpConfigEntry.Subscribe)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Subscribe = data
		}
	}
	{
		data, d := encodeReadWriteRatesConfig(rateLimitIpConfigEntry.Resource)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Resource = data
		}
	}
	res.Partition = types.StringValue(rateLimitIpConfigEntry.Partition)
	res.Namespace = types.StringValue(rateLimitIpConfigEntry.Namespace)
	return &res, diags
}

func EncodeSamenessGroupConfigEntry(samenessGroupConfigEntry *api.SamenessGroupConfigEntry) (*SamenessGroupConfigEntry, diag.Diagnostics) {
	if samenessGroupConfigEntry == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := SamenessGroupConfigEntry{}
	res.Name = types.StringValue(samenessGroupConfigEntry.Name)
	res.Partition = types.StringValue(samenessGroupConfigEntry.Partition)
	res.DefaultForFailover = types.BoolValue(samenessGroupConfigEntry.DefaultForFailover)
	res.IncludeLocal = types.BoolValue(samenessGroupConfigEntry.IncludeLocal)
	if samenessGroupConfigEntry.Members != nil {
		res.Members = make([]*SamenessGroupMember, len(samenessGroupConfigEntry.Members))
		for i, attr := range samenessGroupConfigEntry.Members {
			{
				data, d := encodeSamenessGroupMember(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Members[i] = data
				}
			}
		}
	}
	if samenessGroupConfigEntry.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range samenessGroupConfigEntry.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	return &res, diags
}

func EncodeServiceConfigEntry(serviceConfigEntry *structs.ServiceConfigEntry) (*ServiceConfigEntry, diag.Diagnostics) {
	if serviceConfigEntry == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceConfigEntry{}
	res.ID = types.StringValue(serviceConfigEntry.ID)
	res.Name = types.StringValue(serviceConfigEntry.Entry.Name)
	res.Partition = types.StringValue(serviceConfigEntry.Entry.Partition)
	res.Namespace = types.StringValue(serviceConfigEntry.Entry.Namespace)
	res.Protocol = types.StringValue(serviceConfigEntry.Entry.Protocol)
	res.Mode = types.StringValue(string(serviceConfigEntry.Entry.Mode))
	{
		data, d := encodeTransparentProxyConfig(serviceConfigEntry.Entry.TransparentProxy)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.TransparentProxy = data
		}
	}
	res.MutualTLSMode = types.StringValue(string(serviceConfigEntry.Entry.MutualTLSMode))
	{
		data, d := encodeMeshGatewayConfig(&serviceConfigEntry.Entry.MeshGateway)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.MeshGateway = data
		}
	}
	{
		data, d := encodeExposeConfig(&serviceConfigEntry.Entry.Expose)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Expose = data
		}
	}
	res.ExternalSNI = types.StringValue(serviceConfigEntry.Entry.ExternalSNI)
	{
		data, d := encodeUpstreamConfiguration(serviceConfigEntry.Entry.UpstreamConfig)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.UpstreamConfig = data
		}
	}
	{
		data, d := encodeDestinationConfig(serviceConfigEntry.Entry.Destination)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Destination = data
		}
	}
	res.MaxInboundConnections = types.Int64Value(int64(serviceConfigEntry.Entry.MaxInboundConnections))
	res.LocalConnectTimeoutMs = types.Int64Value(int64(serviceConfigEntry.Entry.LocalConnectTimeoutMs))
	res.LocalRequestTimeoutMs = types.Int64Value(int64(serviceConfigEntry.Entry.LocalRequestTimeoutMs))
	res.BalanceInboundConnections = types.StringValue(serviceConfigEntry.Entry.BalanceInboundConnections)
	if serviceConfigEntry.Entry.EnvoyExtensions != nil {
		res.EnvoyExtensions = make([]*EnvoyExtension, len(serviceConfigEntry.Entry.EnvoyExtensions))
		for i, attr := range serviceConfigEntry.Entry.EnvoyExtensions {
			{
				data, d := encodeEnvoyExtension(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.EnvoyExtensions[i] = data
				}
			}
		}
	}
	if serviceConfigEntry.Entry.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range serviceConfigEntry.Entry.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	return &res, diags
}

func EncodeServiceHealth(serviceHealth *structs.ServiceHealth) (*ServiceHealth, diag.Diagnostics) {
	if serviceHealth == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceHealth{}
	res.ID = types.StringValue(serviceHealth.ID)
	if serviceHealth.Services != nil {
		res.Services = make([]*ServiceEntry, len(serviceHealth.Services))
		for i, attr := range serviceHealth.Services {
			{
				data, d := encodeServiceEntry(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Services[i] = data
				}
			}
		}
	}
	return &res, diags
}

func EncodeServiceIntentionsConfigEntry(serviceIntentionsConfigEntry *api.ServiceIntentionsConfigEntry) (*ServiceIntentionsConfigEntry, diag.Diagnostics) {
	if serviceIntentionsConfigEntry == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceIntentionsConfigEntry{}
	res.Name = types.StringValue(serviceIntentionsConfigEntry.Name)
	res.Partition = types.StringValue(serviceIntentionsConfigEntry.Partition)
	res.Namespace = types.StringValue(serviceIntentionsConfigEntry.Namespace)
	if serviceIntentionsConfigEntry.Sources != nil {
		res.Sources = make([]*SourceIntention, len(serviceIntentionsConfigEntry.Sources))
		for i, attr := range serviceIntentionsConfigEntry.Sources {
			{
				data, d := encodeSourceIntention(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Sources[i] = data
				}
			}
		}
	}
	{
		data, d := encodeIntentionJWTRequirement(serviceIntentionsConfigEntry.JWT)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.JWT = data
		}
	}
	if serviceIntentionsConfigEntry.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range serviceIntentionsConfigEntry.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	return &res, diags
}

func EncodeServiceResolverConfigEntry(serviceResolverConfigEntry *api.ServiceResolverConfigEntry) (*ServiceResolverConfigEntry, diag.Diagnostics) {
	if serviceResolverConfigEntry == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceResolverConfigEntry{}
	res.Name = types.StringValue(serviceResolverConfigEntry.Name)
	res.Partition = types.StringValue(serviceResolverConfigEntry.Partition)
	res.Namespace = types.StringValue(serviceResolverConfigEntry.Namespace)
	res.DefaultSubset = types.StringValue(serviceResolverConfigEntry.DefaultSubset)
	if serviceResolverConfigEntry.Subsets != nil {
		res.Subsets = map[string]*ServiceResolverSubset{}
		for k, v := range serviceResolverConfigEntry.Subsets {
			{
				data, d := encodeServiceResolverSubset(&v)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Subsets[k] = data
				}
			}
		}
	}
	{
		data, d := encodeServiceResolverRedirect(serviceResolverConfigEntry.Redirect)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Redirect = data
		}
	}
	if serviceResolverConfigEntry.Failover != nil {
		res.Failover = map[string]*ServiceResolverFailover{}
		for k, v := range serviceResolverConfigEntry.Failover {
			{
				data, d := encodeServiceResolverFailover(&v)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Failover[k] = data
				}
			}
		}
	}
	res.ConnectTimeout = types.StringValue(serviceResolverConfigEntry.ConnectTimeout.String())
	res.RequestTimeout = types.StringValue(serviceResolverConfigEntry.RequestTimeout.String())
	{
		data, d := encodeServiceResolverPrioritizeByLocality(serviceResolverConfigEntry.PrioritizeByLocality)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.PrioritizeByLocality = data
		}
	}
	{
		data, d := encodeLoadBalancer(serviceResolverConfigEntry.LoadBalancer)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.LoadBalancer = data
		}
	}
	if serviceResolverConfigEntry.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range serviceResolverConfigEntry.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	return &res, diags
}

func EncodeServiceRouterConfigEntry(serviceRouterConfigEntry *structs.ServiceRouterConfigEntry) (*ServiceRouterConfigEntry, diag.Diagnostics) {
	if serviceRouterConfigEntry == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceRouterConfigEntry{}
	res.ID = types.StringValue(serviceRouterConfigEntry.ID)
	res.Name = types.StringValue(serviceRouterConfigEntry.Entry.Name)
	res.Partition = types.StringValue(serviceRouterConfigEntry.Entry.Partition)
	res.Namespace = types.StringValue(serviceRouterConfigEntry.Entry.Namespace)
	if serviceRouterConfigEntry.Entry.Routes != nil {
		res.Routes = make([]*ServiceRoute, len(serviceRouterConfigEntry.Entry.Routes))
		for i, attr := range serviceRouterConfigEntry.Entry.Routes {
			{
				data, d := encodeServiceRoute(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Routes[i] = data
				}
			}
		}
	}
	if serviceRouterConfigEntry.Entry.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range serviceRouterConfigEntry.Entry.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	return &res, diags
}

func EncodeServiceSplitterConfigEntry(serviceSplitterConfigEntry *api.ServiceSplitterConfigEntry) (*ServiceSplitterConfigEntry, diag.Diagnostics) {
	if serviceSplitterConfigEntry == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceSplitterConfigEntry{}
	res.Name = types.StringValue(serviceSplitterConfigEntry.Name)
	res.Partition = types.StringValue(serviceSplitterConfigEntry.Partition)
	res.Namespace = types.StringValue(serviceSplitterConfigEntry.Namespace)
	if serviceSplitterConfigEntry.Splits != nil {
		res.Splits = make([]*ServiceSplit, len(serviceSplitterConfigEntry.Splits))
		for i, attr := range serviceSplitterConfigEntry.Splits {
			{
				data, d := encodeServiceSplit(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Splits[i] = data
				}
			}
		}
	}
	if serviceSplitterConfigEntry.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range serviceSplitterConfigEntry.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	return &res, diags
}

func EncodeTCPRouteConfigEntry(tcpRouteConfigEntry *api.TCPRouteConfigEntry) (*TCPRouteConfigEntry, diag.Diagnostics) {
	if tcpRouteConfigEntry == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := TCPRouteConfigEntry{}
	res.Name = types.StringValue(tcpRouteConfigEntry.Name)
	if tcpRouteConfigEntry.Parents != nil {
		res.Parents = make([]*ResourceReference, len(tcpRouteConfigEntry.Parents))
		for i, attr := range tcpRouteConfigEntry.Parents {
			{
				data, d := encodeResourceReference(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Parents[i] = data
				}
			}
		}
	}
	if tcpRouteConfigEntry.Services != nil {
		res.Services = make([]*TCPService, len(tcpRouteConfigEntry.Services))
		for i, attr := range tcpRouteConfigEntry.Services {
			{
				data, d := encodeTCPService(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Services[i] = data
				}
			}
		}
	}
	if tcpRouteConfigEntry.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range tcpRouteConfigEntry.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	{
		data, d := encodeConfigEntryStatus(&tcpRouteConfigEntry.Status)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Status = data
		}
	}
	res.Partition = types.StringValue(tcpRouteConfigEntry.Partition)
	res.Namespace = types.StringValue(tcpRouteConfigEntry.Namespace)
	return &res, diags
}

func EncodeTerminatingGatewayConfigEntry(terminatingGatewayConfigEntry *api.TerminatingGatewayConfigEntry) (*TerminatingGatewayConfigEntry, diag.Diagnostics) {
	if terminatingGatewayConfigEntry == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := TerminatingGatewayConfigEntry{}
	res.Name = types.StringValue(terminatingGatewayConfigEntry.Name)
	if terminatingGatewayConfigEntry.Services != nil {
		res.Services = make([]*LinkedService, len(terminatingGatewayConfigEntry.Services))
		for i, attr := range terminatingGatewayConfigEntry.Services {
			{
				data, d := encodeLinkedService(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Services[i] = data
				}
			}
		}
	}
	if terminatingGatewayConfigEntry.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range terminatingGatewayConfigEntry.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	res.Partition = types.StringValue(terminatingGatewayConfigEntry.Partition)
	res.Namespace = types.StringValue(terminatingGatewayConfigEntry.Namespace)
	return &res, diags
}

func encodeACLAuthMethodNamespaceRule(aclAuthMethodNamespaceRule *api.ACLAuthMethodNamespaceRule) (*ACLAuthMethodNamespaceRule, diag.Diagnostics) {
	if aclAuthMethodNamespaceRule == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ACLAuthMethodNamespaceRule{}
	res.Selector = types.StringValue(aclAuthMethodNamespaceRule.Selector)
	res.BindNamespace = types.StringValue(aclAuthMethodNamespaceRule.BindNamespace)
	return &res, diags
}

func encodeACLLink(aclLink *api.ACLLink) (*ACLLink, diag.Diagnostics) {
	if aclLink == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ACLLink{}
	res.ID = types.StringValue(aclLink.ID)
	res.Name = types.StringValue(aclLink.Name)
	return &res, diags
}

func encodeACLServiceIdentity(aclServiceIdentity *api.ACLServiceIdentity) (*ACLServiceIdentity, diag.Diagnostics) {
	if aclServiceIdentity == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ACLServiceIdentity{}
	res.ServiceName = types.StringValue(aclServiceIdentity.ServiceName)
	if aclServiceIdentity.Datacenters != nil {
		res.Datacenters = make([]types.String, len(aclServiceIdentity.Datacenters))
		for i, attr := range aclServiceIdentity.Datacenters {
			res.Datacenters[i] = types.StringValue(attr)
		}
	}
	return &res, diags
}

func encodeACLNodeIdentity(aclNodeIdentity *api.ACLNodeIdentity) (*ACLNodeIdentity, diag.Diagnostics) {
	if aclNodeIdentity == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ACLNodeIdentity{}
	res.NodeName = types.StringValue(aclNodeIdentity.NodeName)
	res.Datacenter = types.StringValue(aclNodeIdentity.Datacenter)
	return &res, diags
}

func encodeAPIGatewayListener(apiGatewayListener *api.APIGatewayListener) (*APIGatewayListener, diag.Diagnostics) {
	if apiGatewayListener == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := APIGatewayListener{}
	res.Name = types.StringValue(apiGatewayListener.Name)
	res.Hostname = types.StringValue(apiGatewayListener.Hostname)
	res.Port = types.Int64Value(int64(apiGatewayListener.Port))
	res.Protocol = types.StringValue(apiGatewayListener.Protocol)
	{
		data, d := encodeAPIGatewayTLSConfiguration(&apiGatewayListener.TLS)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.TLS = data
		}
	}
	return &res, diags
}

func encodeConfigEntryStatus(configEntryStatus *api.ConfigEntryStatus) (*ConfigEntryStatus, diag.Diagnostics) {
	if configEntryStatus == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ConfigEntryStatus{}
	if configEntryStatus.Conditions != nil {
		res.Conditions = make([]*Condition, len(configEntryStatus.Conditions))
		for i, attr := range configEntryStatus.Conditions {
			{
				data, d := encodeCondition(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Conditions[i] = data
				}
			}
		}
	}
	return &res, diags
}

func encodeServerHealth(serverHealth *api.ServerHealth) (*ServerHealth, diag.Diagnostics) {
	if serverHealth == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServerHealth{}
	res.ID = types.StringValue(serverHealth.ID)
	res.Name = types.StringValue(serverHealth.Name)
	res.Address = types.StringValue(serverHealth.Address)
	res.SerfStatus = types.StringValue(serverHealth.SerfStatus)
	res.Version = types.StringValue(serverHealth.Version)
	res.Leader = types.BoolValue(serverHealth.Leader)
	res.LastTerm = types.Int64Value(int64(serverHealth.LastTerm))
	res.LastIndex = types.Int64Value(int64(serverHealth.LastIndex))
	res.Healthy = types.BoolValue(serverHealth.Healthy)
	res.Voter = types.BoolValue(serverHealth.Voter)
	res.StableSince = types.StringValue(serverHealth.StableSince.Format(time.RFC3339))
	return &res, diags
}

func encodeAgentService(agentService *api.AgentService) (*AgentService, diag.Diagnostics) {
	if agentService == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := AgentService{}
	res.ID = types.StringValue(agentService.ID)
	return &res, diags
}

func encodeLocality(locality *api.Locality) (*Locality, diag.Diagnostics) {
	if locality == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Locality{}
	res.Region = types.StringValue(locality.Region)
	res.Zone = types.StringValue(locality.Zone)
	return &res, diags
}

func encodeServiceAddress(serviceAddress *api.ServiceAddress) (*ServiceAddress, diag.Diagnostics) {
	if serviceAddress == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceAddress{}
	res.Address = types.StringValue(serviceAddress.Address)
	res.Port = types.Int64Value(int64(serviceAddress.Port))
	return &res, diags
}

func encodeWeights(weights *api.Weights) (*Weights, diag.Diagnostics) {
	if weights == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Weights{}
	res.Passing = types.Int64Value(int64(weights.Passing))
	res.Warning = types.Int64Value(int64(weights.Warning))
	return &res, diags
}

func encodeAgentServiceConnectProxyConfig(agentServiceConnectProxyConfig *api.AgentServiceConnectProxyConfig) (*AgentServiceConnectProxyConfig, diag.Diagnostics) {
	if agentServiceConnectProxyConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := AgentServiceConnectProxyConfig{}
	if agentServiceConnectProxyConfig.EnvoyExtensions != nil {
		res.EnvoyExtensions = make([]*EnvoyExtension, len(agentServiceConnectProxyConfig.EnvoyExtensions))
		for i, attr := range agentServiceConnectProxyConfig.EnvoyExtensions {
			{
				data, d := encodeEnvoyExtension(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.EnvoyExtensions[i] = data
				}
			}
		}
	}
	res.DestinationServiceName = types.StringValue(agentServiceConnectProxyConfig.DestinationServiceName)
	res.DestinationServiceID = types.StringValue(agentServiceConnectProxyConfig.DestinationServiceID)
	res.LocalServiceAddress = types.StringValue(agentServiceConnectProxyConfig.LocalServiceAddress)
	res.LocalServicePort = types.Int64Value(int64(agentServiceConnectProxyConfig.LocalServicePort))
	res.LocalServiceSocketPath = types.StringValue(agentServiceConnectProxyConfig.LocalServiceSocketPath)
	res.Mode = types.StringValue(string(agentServiceConnectProxyConfig.Mode))
	{
		data, d := encodeTransparentProxyConfig(agentServiceConnectProxyConfig.TransparentProxy)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.TransparentProxy = data
		}
	}
	if agentServiceConnectProxyConfig.Config != nil {
		data, err := json.Marshal(agentServiceConnectProxyConfig.Config)
		if err != nil {
			panic(err)
		}
		res.Config = types.StringValue(string(data))
	}
	if agentServiceConnectProxyConfig.Upstreams != nil {
		res.Upstreams = make([]*Upstream, len(agentServiceConnectProxyConfig.Upstreams))
		for i, attr := range agentServiceConnectProxyConfig.Upstreams {
			{
				data, d := encodeUpstream(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Upstreams[i] = data
				}
			}
		}
	}
	{
		data, d := encodeMeshGatewayConfig(&agentServiceConnectProxyConfig.MeshGateway)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.MeshGateway = data
		}
	}
	{
		data, d := encodeExposeConfig(&agentServiceConnectProxyConfig.Expose)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Expose = data
		}
	}
	{
		data, d := encodeAccessLogsConfig(agentServiceConnectProxyConfig.AccessLogs)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.AccessLogs = data
		}
	}
	return &res, diags
}

func encodeHealthCheck(healthCheck *api.HealthCheck) (*HealthCheck, diag.Diagnostics) {
	if healthCheck == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := HealthCheck{}
	res.Node = types.StringValue(healthCheck.Node)
	res.CheckID = types.StringValue(healthCheck.CheckID)
	res.Name = types.StringValue(healthCheck.Name)
	res.Status = types.StringValue(healthCheck.Status)
	res.Notes = types.StringValue(healthCheck.Notes)
	res.Output = types.StringValue(healthCheck.Output)
	res.ServiceID = types.StringValue(healthCheck.ServiceID)
	res.ServiceName = types.StringValue(healthCheck.ServiceName)
	if healthCheck.ServiceTags != nil {
		res.ServiceTags = make([]types.String, len(healthCheck.ServiceTags))
		for i, attr := range healthCheck.ServiceTags {
			res.ServiceTags[i] = types.StringValue(attr)
		}
	}
	res.Type = types.StringValue(healthCheck.Type)
	res.Namespace = types.StringValue(healthCheck.Namespace)
	res.Partition = types.StringValue(healthCheck.Partition)
	res.ExposedPort = types.Int64Value(int64(healthCheck.ExposedPort))
	res.PeerName = types.StringValue(healthCheck.PeerName)
	{
		data, d := encodeHealthCheckDefinition(&healthCheck.Definition)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Definition = data
		}
	}
	return &res, diags
}

func encodeHttpBasicAuth(httpBasicAuth *api.HttpBasicAuth) (*HttpBasicAuth, diag.Diagnostics) {
	if httpBasicAuth == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := HttpBasicAuth{}
	res.Username = types.StringValue(httpBasicAuth.Username)
	res.Password = types.StringValue(httpBasicAuth.Password)
	return &res, diags
}

func encodeTLSConfig(tlsConfig *api.TLSConfig) (*TLSConfig, diag.Diagnostics) {
	if tlsConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := TLSConfig{}
	res.Address = types.StringValue(tlsConfig.Address)
	res.CAFile = types.StringValue(tlsConfig.CAFile)
	res.CAPath = types.StringValue(tlsConfig.CAPath)
	res.CAPem = types.StringValue(string(tlsConfig.CAPem))
	res.CertFile = types.StringValue(tlsConfig.CertFile)
	res.CertPEM = types.StringValue(string(tlsConfig.CertPEM))
	res.KeyFile = types.StringValue(tlsConfig.KeyFile)
	res.KeyPEM = types.StringValue(string(tlsConfig.KeyPEM))
	res.InsecureSkipVerify = types.BoolValue(tlsConfig.InsecureSkipVerify)
	return &res, diags
}

func encodeExportedService(exportedService *api.ExportedService) (*ExportedService, diag.Diagnostics) {
	if exportedService == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ExportedService{}
	res.Name = types.StringValue(exportedService.Name)
	res.Namespace = types.StringValue(exportedService.Namespace)
	if exportedService.Consumers != nil {
		res.Consumers = make([]*ServiceConsumer, len(exportedService.Consumers))
		for i, attr := range exportedService.Consumers {
			{
				data, d := encodeServiceConsumer(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Consumers[i] = data
				}
			}
		}
	}
	return &res, diags
}

func encodeResourceReference(resourceReference *api.ResourceReference) (*ResourceReference, diag.Diagnostics) {
	if resourceReference == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ResourceReference{}
	res.Kind = types.StringValue(resourceReference.Kind)
	res.Name = types.StringValue(resourceReference.Name)
	res.SectionName = types.StringValue(resourceReference.SectionName)
	res.Partition = types.StringValue(resourceReference.Partition)
	res.Namespace = types.StringValue(resourceReference.Namespace)
	return &res, diags
}

func encodeHTTPRouteRule(httpRouteRule *api.HTTPRouteRule) (*HTTPRouteRule, diag.Diagnostics) {
	if httpRouteRule == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := HTTPRouteRule{}
	{
		data, d := encodeHTTPFilters(&httpRouteRule.Filters)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Filters = data
		}
	}
	if httpRouteRule.Matches != nil {
		res.Matches = make([]*HTTPMatch, len(httpRouteRule.Matches))
		for i, attr := range httpRouteRule.Matches {
			{
				data, d := encodeHTTPMatch(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Matches[i] = data
				}
			}
		}
	}
	if httpRouteRule.Services != nil {
		res.Services = make([]*HTTPService, len(httpRouteRule.Services))
		for i, attr := range httpRouteRule.Services {
			{
				data, d := encodeHTTPService(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Services[i] = data
				}
			}
		}
	}
	return &res, diags
}

func encodeGatewayTLSConfig(gatewayTlsConfig *api.GatewayTLSConfig) (*GatewayTLSConfig, diag.Diagnostics) {
	if gatewayTlsConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := GatewayTLSConfig{}
	res.Enabled = types.BoolValue(gatewayTlsConfig.Enabled)
	{
		data, d := encodeGatewayTLSSDSConfig(gatewayTlsConfig.SDS)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.SDS = data
		}
	}
	res.TLSMinVersion = types.StringValue(gatewayTlsConfig.TLSMinVersion)
	res.TLSMaxVersion = types.StringValue(gatewayTlsConfig.TLSMaxVersion)
	if gatewayTlsConfig.CipherSuites != nil {
		res.CipherSuites = make([]types.String, len(gatewayTlsConfig.CipherSuites))
		for i, attr := range gatewayTlsConfig.CipherSuites {
			res.CipherSuites[i] = types.StringValue(attr)
		}
	}
	return &res, diags
}

func encodeIngressListener(ingressListener *api.IngressListener) (*IngressListener, diag.Diagnostics) {
	if ingressListener == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := IngressListener{}
	res.Port = types.Int64Value(int64(ingressListener.Port))
	res.Protocol = types.StringValue(ingressListener.Protocol)
	if ingressListener.Services != nil {
		res.Services = make([]*IngressService, len(ingressListener.Services))
		for i, attr := range ingressListener.Services {
			{
				data, d := encodeIngressService(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Services[i] = data
				}
			}
		}
	}
	{
		data, d := encodeGatewayTLSConfig(ingressListener.TLS)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.TLS = data
		}
	}
	return &res, diags
}

func encodeIngressServiceConfig(ingressServiceConfig *api.IngressServiceConfig) (*IngressServiceConfig, diag.Diagnostics) {
	if ingressServiceConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := IngressServiceConfig{}
	return &res, diags
}

func encodeJSONWebKeySet(jsonWebKeySet *api.JSONWebKeySet) (*JSONWebKeySet, diag.Diagnostics) {
	if jsonWebKeySet == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := JSONWebKeySet{}
	{
		data, d := encodeLocalJWKS(jsonWebKeySet.Local)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Local = data
		}
	}
	{
		data, d := encodeRemoteJWKS(jsonWebKeySet.Remote)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Remote = data
		}
	}
	return &res, diags
}

func encodeJWTLocation(jwtLocation *api.JWTLocation) (*JWTLocation, diag.Diagnostics) {
	if jwtLocation == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := JWTLocation{}
	{
		data, d := encodeJWTLocationHeader(jwtLocation.Header)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Header = data
		}
	}
	{
		data, d := encodeJWTLocationQueryParam(jwtLocation.QueryParam)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.QueryParam = data
		}
	}
	{
		data, d := encodeJWTLocationCookie(jwtLocation.Cookie)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Cookie = data
		}
	}
	return &res, diags
}

func encodeJWTForwardingConfig(jwtForwardingConfig *api.JWTForwardingConfig) (*JWTForwardingConfig, diag.Diagnostics) {
	if jwtForwardingConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := JWTForwardingConfig{}
	res.HeaderName = types.StringValue(jwtForwardingConfig.HeaderName)
	res.PadForwardPayloadHeader = types.BoolValue(jwtForwardingConfig.PadForwardPayloadHeader)
	return &res, diags
}

func encodeJWTCacheConfig(jwtCacheConfig *api.JWTCacheConfig) (*JWTCacheConfig, diag.Diagnostics) {
	if jwtCacheConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := JWTCacheConfig{}
	res.Size = types.Int64Value(int64(jwtCacheConfig.Size))
	return &res, diags
}

func encodeKVPair(kvPair *api.KVPair) (*KVPair, diag.Diagnostics) {
	if kvPair == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := KVPair{}
	res.Key = types.StringValue(kvPair.Key)
	res.Flags = types.Int64Value(int64(kvPair.Flags))
	res.Value = types.StringValue(string(kvPair.Value))
	res.Namespace = types.StringValue(kvPair.Namespace)
	res.Partition = types.StringValue(kvPair.Partition)
	return &res, diags
}

func encodeTransparentProxyMeshConfig(transparentProxyMeshConfig *api.TransparentProxyMeshConfig) (*TransparentProxyMeshConfig, diag.Diagnostics) {
	if transparentProxyMeshConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := TransparentProxyMeshConfig{}
	res.MeshDestinationsOnly = types.BoolValue(transparentProxyMeshConfig.MeshDestinationsOnly)
	return &res, diags
}

func encodeMeshTLSConfig(meshTlsConfig *api.MeshTLSConfig) (*MeshTLSConfig, diag.Diagnostics) {
	if meshTlsConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := MeshTLSConfig{}
	{
		data, d := encodeMeshDirectionalTLSConfig(meshTlsConfig.Incoming)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Incoming = data
		}
	}
	{
		data, d := encodeMeshDirectionalTLSConfig(meshTlsConfig.Outgoing)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Outgoing = data
		}
	}
	return &res, diags
}

func encodeMeshHTTPConfig(meshHttpConfig *api.MeshHTTPConfig) (*MeshHTTPConfig, diag.Diagnostics) {
	if meshHttpConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := MeshHTTPConfig{}
	res.SanitizeXForwardedClientCert = types.BoolValue(meshHttpConfig.SanitizeXForwardedClientCert)
	return &res, diags
}

func encodePeeringMeshConfig(peeringMeshConfig *api.PeeringMeshConfig) (*PeeringMeshConfig, diag.Diagnostics) {
	if peeringMeshConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := PeeringMeshConfig{}
	res.PeerThroughMeshGateways = types.BoolValue(peeringMeshConfig.PeerThroughMeshGateways)
	return &res, diags
}

func encodeNamespaceACLConfig(namespaceAclConfig *api.NamespaceACLConfig) (*NamespaceACLConfig, diag.Diagnostics) {
	if namespaceAclConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := NamespaceACLConfig{}
	if namespaceAclConfig.PolicyDefaults != nil {
		res.PolicyDefaults = make([]*ACLLink, len(namespaceAclConfig.PolicyDefaults))
		for i, attr := range namespaceAclConfig.PolicyDefaults {
			{
				data, d := encodeACLLink(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.PolicyDefaults[i] = data
				}
			}
		}
	}
	if namespaceAclConfig.RoleDefaults != nil {
		res.RoleDefaults = make([]*ACLLink, len(namespaceAclConfig.RoleDefaults))
		for i, attr := range namespaceAclConfig.RoleDefaults {
			{
				data, d := encodeACLLink(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.RoleDefaults[i] = data
				}
			}
		}
	}
	return &res, diags
}

func encodeSerfMember(serfMember *api.SerfMember) (*SerfMember, diag.Diagnostics) {
	if serfMember == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := SerfMember{}
	res.ID = types.StringValue(serfMember.ID)
	res.Name = types.StringValue(serfMember.Name)
	res.Port = types.Int64Value(int64(serfMember.Port))
	res.Datacenter = types.StringValue(serfMember.Datacenter)
	res.Role = types.StringValue(serfMember.Role)
	res.Build = types.StringValue(serfMember.Build)
	res.Protocol = types.Int64Value(int64(serfMember.Protocol))
	res.Status = types.StringValue(serfMember.Status)
	res.RTT = types.StringValue(serfMember.RTT.String())
	return &res, diags
}

func encodeNode(node *api.Node) (*Node, diag.Diagnostics) {
	if node == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Node{}
	res.ID = types.StringValue(node.ID)
	res.Node = types.StringValue(node.Node)
	res.Address = types.StringValue(node.Address)
	res.Datacenter = types.StringValue(node.Datacenter)
	if node.TaggedAddresses != nil {
		res.TaggedAddresses = map[string]types.String{}
		for k, v := range node.TaggedAddresses {
			res.TaggedAddresses[k] = types.StringValue(v)
		}
	}
	if node.Meta != nil {
		res.Meta = map[string]types.String{}
		for k, v := range node.Meta {
			res.Meta[k] = types.StringValue(v)
		}
	}
	res.Partition = types.StringValue(node.Partition)
	res.PeerName = types.StringValue(node.PeerName)
	{
		data, d := encodeLocality(node.Locality)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Locality = data
		}
	}
	return &res, diags
}

func encodePeeringStreamStatus(peeringStreamStatus *api.PeeringStreamStatus) (*PeeringStreamStatus, diag.Diagnostics) {
	if peeringStreamStatus == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := PeeringStreamStatus{}
	if peeringStreamStatus.ImportedServices != nil {
		res.ImportedServices = make([]types.String, len(peeringStreamStatus.ImportedServices))
		for i, attr := range peeringStreamStatus.ImportedServices {
			res.ImportedServices[i] = types.StringValue(attr)
		}
	}
	if peeringStreamStatus.ExportedServices != nil {
		res.ExportedServices = make([]types.String, len(peeringStreamStatus.ExportedServices))
		for i, attr := range peeringStreamStatus.ExportedServices {
			res.ExportedServices[i] = types.StringValue(attr)
		}
	}
	if peeringStreamStatus.LastHeartbeat != nil {
		res.LastHeartbeat = types.StringValue(peeringStreamStatus.LastHeartbeat.Format(time.RFC3339))
	}
	if peeringStreamStatus.LastReceive != nil {
		res.LastReceive = types.StringValue(peeringStreamStatus.LastReceive.Format(time.RFC3339))
	}
	if peeringStreamStatus.LastSend != nil {
		res.LastSend = types.StringValue(peeringStreamStatus.LastSend.Format(time.RFC3339))
	}
	return &res, diags
}

func encodePeeringRemoteInfo(peeringRemoteInfo *api.PeeringRemoteInfo) (*PeeringRemoteInfo, diag.Diagnostics) {
	if peeringRemoteInfo == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := PeeringRemoteInfo{}
	res.Partition = types.StringValue(peeringRemoteInfo.Partition)
	res.Datacenter = types.StringValue(peeringRemoteInfo.Datacenter)
	{
		data, d := encodeLocality(peeringRemoteInfo.Locality)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Locality = data
		}
	}
	return &res, diags
}

func encodeServiceQuery(serviceQuery *api.ServiceQuery) (*ServiceQuery, diag.Diagnostics) {
	if serviceQuery == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceQuery{}
	res.Service = types.StringValue(serviceQuery.Service)
	res.SamenessGroup = types.StringValue(serviceQuery.SamenessGroup)
	res.Namespace = types.StringValue(serviceQuery.Namespace)
	res.Partition = types.StringValue(serviceQuery.Partition)
	res.Near = types.StringValue(serviceQuery.Near)
	{
		data, d := encodeQueryFailoverOptions(&serviceQuery.Failover)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Failover = data
		}
	}
	if serviceQuery.IgnoreCheckIDs != nil {
		res.IgnoreCheckIDs = make([]types.String, len(serviceQuery.IgnoreCheckIDs))
		for i, attr := range serviceQuery.IgnoreCheckIDs {
			res.IgnoreCheckIDs[i] = types.StringValue(attr)
		}
	}
	res.OnlyPassing = types.BoolValue(serviceQuery.OnlyPassing)
	if serviceQuery.Tags != nil {
		res.Tags = make([]types.String, len(serviceQuery.Tags))
		for i, attr := range serviceQuery.Tags {
			res.Tags[i] = types.StringValue(attr)
		}
	}
	if serviceQuery.NodeMeta != nil {
		res.NodeMeta = map[string]types.String{}
		for k, v := range serviceQuery.NodeMeta {
			res.NodeMeta[k] = types.StringValue(v)
		}
	}
	if serviceQuery.ServiceMeta != nil {
		res.ServiceMeta = map[string]types.String{}
		for k, v := range serviceQuery.ServiceMeta {
			res.ServiceMeta[k] = types.StringValue(v)
		}
	}
	res.Connect = types.BoolValue(serviceQuery.Connect)
	return &res, diags
}

func encodeQueryDNSOptions(queryDnsOptions *api.QueryDNSOptions) (*QueryDNSOptions, diag.Diagnostics) {
	if queryDnsOptions == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := QueryDNSOptions{}
	res.TTL = types.StringValue(queryDnsOptions.TTL)
	return &res, diags
}

func encodeQueryTemplate(queryTemplate *api.QueryTemplate) (*QueryTemplate, diag.Diagnostics) {
	if queryTemplate == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := QueryTemplate{}
	res.Type = types.StringValue(queryTemplate.Type)
	res.Regexp = types.StringValue(queryTemplate.Regexp)
	res.RemoveEmptyTags = types.BoolValue(queryTemplate.RemoveEmptyTags)
	return &res, diags
}

func encodeTransparentProxyConfig(transparentProxyConfig *api.TransparentProxyConfig) (*TransparentProxyConfig, diag.Diagnostics) {
	if transparentProxyConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := TransparentProxyConfig{}
	res.OutboundListenerPort = types.Int64Value(int64(transparentProxyConfig.OutboundListenerPort))
	res.DialedDirectly = types.BoolValue(transparentProxyConfig.DialedDirectly)
	return &res, diags
}

func encodeMeshGatewayConfig(meshGatewayConfig *api.MeshGatewayConfig) (*MeshGatewayConfig, diag.Diagnostics) {
	if meshGatewayConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := MeshGatewayConfig{}
	res.Mode = types.StringValue(string(meshGatewayConfig.Mode))
	return &res, diags
}

func encodeExposeConfig(exposeConfig *api.ExposeConfig) (*ExposeConfig, diag.Diagnostics) {
	if exposeConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ExposeConfig{}
	res.Checks = types.BoolValue(exposeConfig.Checks)
	if exposeConfig.Paths != nil {
		res.Paths = make([]*ExposePath, len(exposeConfig.Paths))
		for i, attr := range exposeConfig.Paths {
			{
				data, d := encodeExposePath(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Paths[i] = data
				}
			}
		}
	}
	return &res, diags
}

func encodeAccessLogsConfig(accessLogsConfig *api.AccessLogsConfig) (*AccessLogsConfig, diag.Diagnostics) {
	if accessLogsConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := AccessLogsConfig{}
	res.Enabled = types.BoolValue(accessLogsConfig.Enabled)
	res.DisableListenerLogs = types.BoolValue(accessLogsConfig.DisableListenerLogs)
	res.Type = types.StringValue(string(accessLogsConfig.Type))
	res.Path = types.StringValue(accessLogsConfig.Path)
	res.JSONFormat = types.StringValue(accessLogsConfig.JSONFormat)
	res.TextFormat = types.StringValue(accessLogsConfig.TextFormat)
	return &res, diags
}

func encodeEnvoyExtension(envoyExtension *api.EnvoyExtension) (*EnvoyExtension, diag.Diagnostics) {
	if envoyExtension == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := EnvoyExtension{}
	res.Name = types.StringValue(envoyExtension.Name)
	res.Required = types.BoolValue(envoyExtension.Required)
	if envoyExtension.Arguments != nil {
		data, err := json.Marshal(envoyExtension.Arguments)
		if err != nil {
			panic(err)
		}
		res.Arguments = types.StringValue(string(data))
	}
	res.ConsulVersion = types.StringValue(envoyExtension.ConsulVersion)
	res.EnvoyVersion = types.StringValue(envoyExtension.EnvoyVersion)
	return &res, diags
}

func encodeServiceResolverFailoverPolicy(serviceResolverFailoverPolicy *api.ServiceResolverFailoverPolicy) (*ServiceResolverFailoverPolicy, diag.Diagnostics) {
	if serviceResolverFailoverPolicy == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceResolverFailoverPolicy{}
	res.Mode = types.StringValue(serviceResolverFailoverPolicy.Mode)
	if serviceResolverFailoverPolicy.Regions != nil {
		res.Regions = make([]types.String, len(serviceResolverFailoverPolicy.Regions))
		for i, attr := range serviceResolverFailoverPolicy.Regions {
			res.Regions[i] = types.StringValue(attr)
		}
	}
	return &res, diags
}

func encodeServiceResolverPrioritizeByLocality(serviceResolverPrioritizeByLocality *api.ServiceResolverPrioritizeByLocality) (*ServiceResolverPrioritizeByLocality, diag.Diagnostics) {
	if serviceResolverPrioritizeByLocality == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceResolverPrioritizeByLocality{}
	res.Mode = types.StringValue(serviceResolverPrioritizeByLocality.Mode)
	return &res, diags
}

func encodeReadWriteRatesConfig(readWriteRatesConfig *api.ReadWriteRatesConfig) (*ReadWriteRatesConfig, diag.Diagnostics) {
	if readWriteRatesConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ReadWriteRatesConfig{}
	res.ReadRate = types.Float64Value(float64(readWriteRatesConfig.ReadRate))
	res.WriteRate = types.Float64Value(float64(readWriteRatesConfig.WriteRate))
	return &res, diags
}

func encodeSamenessGroupMember(samenessGroupMember *api.SamenessGroupMember) (*SamenessGroupMember, diag.Diagnostics) {
	if samenessGroupMember == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := SamenessGroupMember{}
	res.Partition = types.StringValue(samenessGroupMember.Partition)
	res.Peer = types.StringValue(samenessGroupMember.Peer)
	return &res, diags
}

func encodeUpstreamConfiguration(upstreamConfiguration *api.UpstreamConfiguration) (*UpstreamConfiguration, diag.Diagnostics) {
	if upstreamConfiguration == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := UpstreamConfiguration{}
	if upstreamConfiguration.Overrides != nil {
		res.Overrides = make([]*UpstreamConfig, len(upstreamConfiguration.Overrides))
		for i, attr := range upstreamConfiguration.Overrides {
			{
				data, d := encodeUpstreamConfig(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Overrides[i] = data
				}
			}
		}
	}
	{
		data, d := encodeUpstreamConfig(upstreamConfiguration.Defaults)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Defaults = data
		}
	}
	return &res, diags
}

func encodeDestinationConfig(destinationConfig *api.DestinationConfig) (*DestinationConfig, diag.Diagnostics) {
	if destinationConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := DestinationConfig{}
	if destinationConfig.Addresses != nil {
		res.Addresses = make([]types.String, len(destinationConfig.Addresses))
		for i, attr := range destinationConfig.Addresses {
			res.Addresses[i] = types.StringValue(attr)
		}
	}
	res.Port = types.Int64Value(int64(destinationConfig.Port))
	return &res, diags
}

func encodeServiceEntry(serviceEntry *api.ServiceEntry) (*ServiceEntry, diag.Diagnostics) {
	if serviceEntry == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceEntry{}
	return &res, diags
}

func encodeSourceIntention(sourceIntention *api.SourceIntention) (*SourceIntention, diag.Diagnostics) {
	if sourceIntention == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := SourceIntention{}
	res.Name = types.StringValue(sourceIntention.Name)
	res.Peer = types.StringValue(sourceIntention.Peer)
	res.Partition = types.StringValue(sourceIntention.Partition)
	res.Namespace = types.StringValue(sourceIntention.Namespace)
	res.SamenessGroup = types.StringValue(sourceIntention.SamenessGroup)
	res.Action = types.StringValue(string(sourceIntention.Action))
	if sourceIntention.Permissions != nil {
		res.Permissions = make([]*IntentionPermission, len(sourceIntention.Permissions))
		for i, attr := range sourceIntention.Permissions {
			{
				data, d := encodeIntentionPermission(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Permissions[i] = data
				}
			}
		}
	}
	res.Precedence = types.Int64Value(int64(sourceIntention.Precedence))
	res.Type = types.StringValue(string(sourceIntention.Type))
	res.Description = types.StringValue(sourceIntention.Description)
	return &res, diags
}

func encodeIntentionJWTRequirement(intentionJwtRequirement *api.IntentionJWTRequirement) (*IntentionJWTRequirement, diag.Diagnostics) {
	if intentionJwtRequirement == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := IntentionJWTRequirement{}
	if intentionJwtRequirement.Providers != nil {
		res.Providers = make([]*IntentionJWTProvider, len(intentionJwtRequirement.Providers))
		for i, attr := range intentionJwtRequirement.Providers {
			{
				data, d := encodeIntentionJWTProvider(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Providers[i] = data
				}
			}
		}
	}
	return &res, diags
}

func encodeServiceResolverSubset(serviceResolverSubset *api.ServiceResolverSubset) (*ServiceResolverSubset, diag.Diagnostics) {
	if serviceResolverSubset == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceResolverSubset{}
	return &res, diags
}

func encodeServiceResolverRedirect(serviceResolverRedirect *api.ServiceResolverRedirect) (*ServiceResolverRedirect, diag.Diagnostics) {
	if serviceResolverRedirect == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceResolverRedirect{}
	return &res, diags
}

func encodeServiceResolverFailover(serviceResolverFailover *api.ServiceResolverFailover) (*ServiceResolverFailover, diag.Diagnostics) {
	if serviceResolverFailover == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceResolverFailover{}
	return &res, diags
}

func encodeLoadBalancer(loadBalancer *api.LoadBalancer) (*LoadBalancer, diag.Diagnostics) {
	if loadBalancer == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := LoadBalancer{}
	return &res, diags
}

func encodeServiceRoute(serviceRoute *api.ServiceRoute) (*ServiceRoute, diag.Diagnostics) {
	if serviceRoute == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceRoute{}
	{
		data, d := encodeServiceRouteMatch(serviceRoute.Match)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Match = data
		}
	}
	{
		data, d := encodeServiceRouteDestination(serviceRoute.Destination)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Destination = data
		}
	}
	return &res, diags
}

func encodeServiceSplit(serviceSplit *api.ServiceSplit) (*ServiceSplit, diag.Diagnostics) {
	if serviceSplit == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceSplit{}
	res.Weight = types.Float64Value(float64(serviceSplit.Weight))
	res.Service = types.StringValue(serviceSplit.Service)
	res.ServiceSubset = types.StringValue(serviceSplit.ServiceSubset)
	res.Namespace = types.StringValue(serviceSplit.Namespace)
	res.Partition = types.StringValue(serviceSplit.Partition)
	{
		data, d := encodeHTTPHeaderModifiers(serviceSplit.RequestHeaders)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.RequestHeaders = data
		}
	}
	{
		data, d := encodeHTTPHeaderModifiers(serviceSplit.ResponseHeaders)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.ResponseHeaders = data
		}
	}
	return &res, diags
}

func encodeTCPService(tcpService *api.TCPService) (*TCPService, diag.Diagnostics) {
	if tcpService == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := TCPService{}
	res.Name = types.StringValue(tcpService.Name)
	res.Partition = types.StringValue(tcpService.Partition)
	res.Namespace = types.StringValue(tcpService.Namespace)
	return &res, diags
}

func encodeLinkedService(linkedService *api.LinkedService) (*LinkedService, diag.Diagnostics) {
	if linkedService == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := LinkedService{}
	res.Namespace = types.StringValue(linkedService.Namespace)
	res.Name = types.StringValue(linkedService.Name)
	res.CAFile = types.StringValue(linkedService.CAFile)
	res.CertFile = types.StringValue(linkedService.CertFile)
	res.KeyFile = types.StringValue(linkedService.KeyFile)
	res.SNI = types.StringValue(linkedService.SNI)
	return &res, diags
}

func encodeAPIGatewayTLSConfiguration(apiGatewayTlsConfiguration *api.APIGatewayTLSConfiguration) (*APIGatewayTLSConfiguration, diag.Diagnostics) {
	if apiGatewayTlsConfiguration == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := APIGatewayTLSConfiguration{}
	if apiGatewayTlsConfiguration.Certificates != nil {
		res.Certificates = make([]*ResourceReference, len(apiGatewayTlsConfiguration.Certificates))
		for i, attr := range apiGatewayTlsConfiguration.Certificates {
			{
				data, d := encodeResourceReference(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Certificates[i] = data
				}
			}
		}
	}
	res.MaxVersion = types.StringValue(apiGatewayTlsConfiguration.MaxVersion)
	res.MinVersion = types.StringValue(apiGatewayTlsConfiguration.MinVersion)
	if apiGatewayTlsConfiguration.CipherSuites != nil {
		res.CipherSuites = make([]types.String, len(apiGatewayTlsConfiguration.CipherSuites))
		for i, attr := range apiGatewayTlsConfiguration.CipherSuites {
			res.CipherSuites[i] = types.StringValue(attr)
		}
	}
	return &res, diags
}

func encodeCondition(condition *api.Condition) (*Condition, diag.Diagnostics) {
	if condition == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Condition{}
	res.Type = types.StringValue(condition.Type)
	res.Status = types.StringValue(string(condition.Status))
	res.Reason = types.StringValue(condition.Reason)
	res.Message = types.StringValue(condition.Message)
	{
		data, d := encodeResourceReference(condition.Resource)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Resource = data
		}
	}
	if condition.LastTransitionTime != nil {
		res.LastTransitionTime = types.StringValue(condition.LastTransitionTime.Format(time.RFC3339))
	}
	return &res, diags
}

func encodeUpstream(upstream *api.Upstream) (*Upstream, diag.Diagnostics) {
	if upstream == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := Upstream{}
	res.DestinationType = types.StringValue(string(upstream.DestinationType))
	res.DestinationPartition = types.StringValue(upstream.DestinationPartition)
	res.DestinationNamespace = types.StringValue(upstream.DestinationNamespace)
	res.DestinationPeer = types.StringValue(upstream.DestinationPeer)
	res.DestinationName = types.StringValue(upstream.DestinationName)
	res.Datacenter = types.StringValue(upstream.Datacenter)
	res.LocalBindAddress = types.StringValue(upstream.LocalBindAddress)
	res.LocalBindPort = types.Int64Value(int64(upstream.LocalBindPort))
	res.LocalBindSocketPath = types.StringValue(upstream.LocalBindSocketPath)
	res.LocalBindSocketMode = types.StringValue(upstream.LocalBindSocketMode)
	if upstream.Config != nil {
		data, err := json.Marshal(upstream.Config)
		if err != nil {
			panic(err)
		}
		res.Config = types.StringValue(string(data))
	}
	{
		data, d := encodeMeshGatewayConfig(&upstream.MeshGateway)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.MeshGateway = data
		}
	}
	res.CentrallyConfigured = types.BoolValue(upstream.CentrallyConfigured)
	return &res, diags
}

func encodeHealthCheckDefinition(healthCheckDefinition *api.HealthCheckDefinition) (*HealthCheckDefinition, diag.Diagnostics) {
	if healthCheckDefinition == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := HealthCheckDefinition{}
	res.HTTP = types.StringValue(healthCheckDefinition.HTTP)
	if healthCheckDefinition.Header != nil {
		res.Header = map[string][]types.String{}
		for k, v := range healthCheckDefinition.Header {
			if v != nil {
				res.Header[k] = make([]types.String, len(v))
				for i, attr := range v {
					res.Header[k][i] = types.StringValue(attr)
				}
			}
		}
	}
	res.Method = types.StringValue(healthCheckDefinition.Method)
	res.Body = types.StringValue(healthCheckDefinition.Body)
	res.TLSServerName = types.StringValue(healthCheckDefinition.TLSServerName)
	res.TLSSkipVerify = types.BoolValue(healthCheckDefinition.TLSSkipVerify)
	res.TCP = types.StringValue(healthCheckDefinition.TCP)
	res.UDP = types.StringValue(healthCheckDefinition.UDP)
	res.GRPC = types.StringValue(healthCheckDefinition.GRPC)
	res.OSService = types.StringValue(healthCheckDefinition.OSService)
	res.GRPCUseTLS = types.BoolValue(healthCheckDefinition.GRPCUseTLS)
	res.IntervalDuration = types.StringValue(healthCheckDefinition.IntervalDuration.String())
	res.TimeoutDuration = types.StringValue(healthCheckDefinition.TimeoutDuration.String())
	res.DeregisterCriticalServiceAfterDuration = types.StringValue(healthCheckDefinition.DeregisterCriticalServiceAfterDuration.String())
	return &res, diags
}

func encodeServiceConsumer(serviceConsumer *api.ServiceConsumer) (*ServiceConsumer, diag.Diagnostics) {
	if serviceConsumer == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceConsumer{}
	res.Partition = types.StringValue(serviceConsumer.Partition)
	res.Peer = types.StringValue(serviceConsumer.Peer)
	res.SamenessGroup = types.StringValue(serviceConsumer.SamenessGroup)
	return &res, diags
}

func encodeHTTPFilters(httpFilters *api.HTTPFilters) (*HTTPFilters, diag.Diagnostics) {
	if httpFilters == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := HTTPFilters{}
	if httpFilters.Headers != nil {
		res.Headers = make([]*HTTPHeaderFilter, len(httpFilters.Headers))
		for i, attr := range httpFilters.Headers {
			{
				data, d := encodeHTTPHeaderFilter(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Headers[i] = data
				}
			}
		}
	}
	{
		data, d := encodeURLRewrite(httpFilters.URLRewrite)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.URLRewrite = data
		}
	}
	return &res, diags
}

func encodeHTTPMatch(httpMatch *api.HTTPMatch) (*HTTPMatch, diag.Diagnostics) {
	if httpMatch == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := HTTPMatch{}
	if httpMatch.Headers != nil {
		res.Headers = make([]*HTTPHeaderMatch, len(httpMatch.Headers))
		for i, attr := range httpMatch.Headers {
			{
				data, d := encodeHTTPHeaderMatch(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Headers[i] = data
				}
			}
		}
	}
	res.Method = types.StringValue(string(httpMatch.Method))
	{
		data, d := encodeHTTPPathMatch(&httpMatch.Path)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Path = data
		}
	}
	if httpMatch.Query != nil {
		res.Query = make([]*HTTPQueryMatch, len(httpMatch.Query))
		for i, attr := range httpMatch.Query {
			{
				data, d := encodeHTTPQueryMatch(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Query[i] = data
				}
			}
		}
	}
	return &res, diags
}

func encodeHTTPService(httpService *api.HTTPService) (*HTTPService, diag.Diagnostics) {
	if httpService == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := HTTPService{}
	res.Name = types.StringValue(httpService.Name)
	res.Weight = types.Int64Value(int64(httpService.Weight))
	{
		data, d := encodeHTTPFilters(&httpService.Filters)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Filters = data
		}
	}
	res.Partition = types.StringValue(httpService.Partition)
	res.Namespace = types.StringValue(httpService.Namespace)
	return &res, diags
}

func encodeGatewayTLSSDSConfig(gatewayTlssdsConfig *api.GatewayTLSSDSConfig) (*GatewayTLSSDSConfig, diag.Diagnostics) {
	if gatewayTlssdsConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := GatewayTLSSDSConfig{}
	return &res, diags
}

func encodeIngressService(ingressService *api.IngressService) (*IngressService, diag.Diagnostics) {
	if ingressService == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := IngressService{}
	res.Name = types.StringValue(ingressService.Name)
	if ingressService.Hosts != nil {
		res.Hosts = make([]types.String, len(ingressService.Hosts))
		for i, attr := range ingressService.Hosts {
			res.Hosts[i] = types.StringValue(attr)
		}
	}
	res.Namespace = types.StringValue(ingressService.Namespace)
	res.Partition = types.StringValue(ingressService.Partition)
	{
		data, d := encodeGatewayServiceTLSConfig(ingressService.TLS)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.TLS = data
		}
	}
	{
		data, d := encodeHTTPHeaderModifiers(ingressService.RequestHeaders)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.RequestHeaders = data
		}
	}
	{
		data, d := encodeHTTPHeaderModifiers(ingressService.ResponseHeaders)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.ResponseHeaders = data
		}
	}
	if ingressService.MaxConnections != nil {
		res.MaxConnections = types.Int64Value(int64(*ingressService.MaxConnections))
	}
	if ingressService.MaxPendingRequests != nil {
		res.MaxPendingRequests = types.Int64Value(int64(*ingressService.MaxPendingRequests))
	}
	if ingressService.MaxConcurrentRequests != nil {
		res.MaxConcurrentRequests = types.Int64Value(int64(*ingressService.MaxConcurrentRequests))
	}
	{
		data, d := encodePassiveHealthCheck(ingressService.PassiveHealthCheck)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.PassiveHealthCheck = data
		}
	}
	return &res, diags
}

func encodeLocalJWKS(localJwks *api.LocalJWKS) (*LocalJWKS, diag.Diagnostics) {
	if localJwks == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := LocalJWKS{}
	res.JWKS = types.StringValue(localJwks.JWKS)
	res.Filename = types.StringValue(localJwks.Filename)
	return &res, diags
}

func encodeRemoteJWKS(remoteJwks *api.RemoteJWKS) (*RemoteJWKS, diag.Diagnostics) {
	if remoteJwks == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := RemoteJWKS{}
	res.URI = types.StringValue(remoteJwks.URI)
	res.RequestTimeoutMs = types.Int64Value(int64(remoteJwks.RequestTimeoutMs))
	res.CacheDuration = types.StringValue(remoteJwks.CacheDuration.String())
	res.FetchAsynchronously = types.BoolValue(remoteJwks.FetchAsynchronously)
	{
		data, d := encodeJWKSRetryPolicy(remoteJwks.RetryPolicy)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.RetryPolicy = data
		}
	}
	{
		data, d := encodeJWKSCluster(remoteJwks.JWKSCluster)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.JWKSCluster = data
		}
	}
	return &res, diags
}

func encodeJWTLocationHeader(jwtLocationHeader *api.JWTLocationHeader) (*JWTLocationHeader, diag.Diagnostics) {
	if jwtLocationHeader == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := JWTLocationHeader{}
	res.Name = types.StringValue(jwtLocationHeader.Name)
	res.ValuePrefix = types.StringValue(jwtLocationHeader.ValuePrefix)
	res.Forward = types.BoolValue(jwtLocationHeader.Forward)
	return &res, diags
}

func encodeJWTLocationQueryParam(jwtLocationQueryParam *api.JWTLocationQueryParam) (*JWTLocationQueryParam, diag.Diagnostics) {
	if jwtLocationQueryParam == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := JWTLocationQueryParam{}
	res.Name = types.StringValue(jwtLocationQueryParam.Name)
	return &res, diags
}

func encodeJWTLocationCookie(jwtLocationCookie *api.JWTLocationCookie) (*JWTLocationCookie, diag.Diagnostics) {
	if jwtLocationCookie == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := JWTLocationCookie{}
	res.Name = types.StringValue(jwtLocationCookie.Name)
	return &res, diags
}

func encodeMeshDirectionalTLSConfig(meshDirectionalTlsConfig *api.MeshDirectionalTLSConfig) (*MeshDirectionalTLSConfig, diag.Diagnostics) {
	if meshDirectionalTlsConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := MeshDirectionalTLSConfig{}
	res.TLSMinVersion = types.StringValue(meshDirectionalTlsConfig.TLSMinVersion)
	res.TLSMaxVersion = types.StringValue(meshDirectionalTlsConfig.TLSMaxVersion)
	if meshDirectionalTlsConfig.CipherSuites != nil {
		res.CipherSuites = make([]types.String, len(meshDirectionalTlsConfig.CipherSuites))
		for i, attr := range meshDirectionalTlsConfig.CipherSuites {
			res.CipherSuites[i] = types.StringValue(attr)
		}
	}
	return &res, diags
}

func encodeQueryFailoverOptions(queryFailoverOptions *api.QueryFailoverOptions) (*QueryFailoverOptions, diag.Diagnostics) {
	if queryFailoverOptions == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := QueryFailoverOptions{}
	res.NearestN = types.Int64Value(int64(queryFailoverOptions.NearestN))
	if queryFailoverOptions.Datacenters != nil {
		res.Datacenters = make([]types.String, len(queryFailoverOptions.Datacenters))
		for i, attr := range queryFailoverOptions.Datacenters {
			res.Datacenters[i] = types.StringValue(attr)
		}
	}
	if queryFailoverOptions.Targets != nil {
		res.Targets = make([]*QueryFailoverTarget, len(queryFailoverOptions.Targets))
		for i, attr := range queryFailoverOptions.Targets {
			{
				data, d := encodeQueryFailoverTarget(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Targets[i] = data
				}
			}
		}
	}
	return &res, diags
}

func encodeExposePath(exposePath *api.ExposePath) (*ExposePath, diag.Diagnostics) {
	if exposePath == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ExposePath{}
	res.ListenerPort = types.Int64Value(int64(exposePath.ListenerPort))
	res.Path = types.StringValue(exposePath.Path)
	res.LocalPathPort = types.Int64Value(int64(exposePath.LocalPathPort))
	res.Protocol = types.StringValue(exposePath.Protocol)
	res.ParsedFromCheck = types.BoolValue(exposePath.ParsedFromCheck)
	return &res, diags
}

func encodeUpstreamConfig(upstreamConfig *api.UpstreamConfig) (*UpstreamConfig, diag.Diagnostics) {
	if upstreamConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := UpstreamConfig{}
	res.Name = types.StringValue(upstreamConfig.Name)
	res.Partition = types.StringValue(upstreamConfig.Partition)
	res.Namespace = types.StringValue(upstreamConfig.Namespace)
	res.Peer = types.StringValue(upstreamConfig.Peer)
	res.EnvoyListenerJSON = types.StringValue(upstreamConfig.EnvoyListenerJSON)
	res.EnvoyClusterJSON = types.StringValue(upstreamConfig.EnvoyClusterJSON)
	res.Protocol = types.StringValue(upstreamConfig.Protocol)
	res.ConnectTimeoutMs = types.Int64Value(int64(upstreamConfig.ConnectTimeoutMs))
	{
		data, d := encodeUpstreamLimits(upstreamConfig.Limits)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.Limits = data
		}
	}
	{
		data, d := encodePassiveHealthCheck(upstreamConfig.PassiveHealthCheck)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.PassiveHealthCheck = data
		}
	}
	{
		data, d := encodeMeshGatewayConfig(&upstreamConfig.MeshGateway)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.MeshGateway = data
		}
	}
	res.BalanceOutboundConnections = types.StringValue(upstreamConfig.BalanceOutboundConnections)
	return &res, diags
}

func encodeIntentionPermission(intentionPermission *api.IntentionPermission) (*IntentionPermission, diag.Diagnostics) {
	if intentionPermission == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := IntentionPermission{}
	res.Action = types.StringValue(string(intentionPermission.Action))
	{
		data, d := encodeIntentionHTTPPermission(intentionPermission.HTTP)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.HTTP = data
		}
	}
	{
		data, d := encodeIntentionJWTRequirement(intentionPermission.JWT)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.JWT = data
		}
	}
	return &res, diags
}

func encodeIntentionJWTProvider(intentionJwtProvider *api.IntentionJWTProvider) (*IntentionJWTProvider, diag.Diagnostics) {
	if intentionJwtProvider == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := IntentionJWTProvider{}
	res.Name = types.StringValue(intentionJwtProvider.Name)
	if intentionJwtProvider.VerifyClaims != nil {
		res.VerifyClaims = make([]*IntentionJWTClaimVerification, len(intentionJwtProvider.VerifyClaims))
		for i, attr := range intentionJwtProvider.VerifyClaims {
			{
				data, d := encodeIntentionJWTClaimVerification(attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.VerifyClaims[i] = data
				}
			}
		}
	}
	return &res, diags
}

func encodeServiceRouteMatch(serviceRouteMatch *api.ServiceRouteMatch) (*ServiceRouteMatch, diag.Diagnostics) {
	if serviceRouteMatch == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceRouteMatch{}
	{
		data, d := encodeServiceRouteHTTPMatch(serviceRouteMatch.HTTP)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.HTTP = data
		}
	}
	return &res, diags
}

func encodeServiceRouteDestination(serviceRouteDestination *api.ServiceRouteDestination) (*ServiceRouteDestination, diag.Diagnostics) {
	if serviceRouteDestination == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceRouteDestination{}
	res.Service = types.StringValue(serviceRouteDestination.Service)
	res.ServiceSubset = types.StringValue(serviceRouteDestination.ServiceSubset)
	res.Namespace = types.StringValue(serviceRouteDestination.Namespace)
	res.Partition = types.StringValue(serviceRouteDestination.Partition)
	res.PrefixRewrite = types.StringValue(serviceRouteDestination.PrefixRewrite)
	res.RequestTimeout = types.StringValue(serviceRouteDestination.RequestTimeout.String())
	res.IdleTimeout = types.StringValue(serviceRouteDestination.IdleTimeout.String())
	res.NumRetries = types.Int64Value(int64(serviceRouteDestination.NumRetries))
	res.RetryOnConnectFailure = types.BoolValue(serviceRouteDestination.RetryOnConnectFailure)
	if serviceRouteDestination.RetryOnStatusCodes != nil {
		res.RetryOnStatusCodes = make([]types.Int64, len(serviceRouteDestination.RetryOnStatusCodes))
		for i, attr := range serviceRouteDestination.RetryOnStatusCodes {
			res.RetryOnStatusCodes[i] = types.Int64Value(int64(attr))
		}
	}
	if serviceRouteDestination.RetryOn != nil {
		res.RetryOn = make([]types.String, len(serviceRouteDestination.RetryOn))
		for i, attr := range serviceRouteDestination.RetryOn {
			res.RetryOn[i] = types.StringValue(attr)
		}
	}
	{
		data, d := encodeHTTPHeaderModifiers(serviceRouteDestination.RequestHeaders)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.RequestHeaders = data
		}
	}
	{
		data, d := encodeHTTPHeaderModifiers(serviceRouteDestination.ResponseHeaders)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.ResponseHeaders = data
		}
	}
	return &res, diags
}

func encodeHTTPHeaderModifiers(httpHeaderModifiers *api.HTTPHeaderModifiers) (*HTTPHeaderModifiers, diag.Diagnostics) {
	if httpHeaderModifiers == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := HTTPHeaderModifiers{}
	if httpHeaderModifiers.Add != nil {
		res.Add = map[string]types.String{}
		for k, v := range httpHeaderModifiers.Add {
			res.Add[k] = types.StringValue(v)
		}
	}
	if httpHeaderModifiers.Set != nil {
		res.Set = map[string]types.String{}
		for k, v := range httpHeaderModifiers.Set {
			res.Set[k] = types.StringValue(v)
		}
	}
	if httpHeaderModifiers.Remove != nil {
		res.Remove = make([]types.String, len(httpHeaderModifiers.Remove))
		for i, attr := range httpHeaderModifiers.Remove {
			res.Remove[i] = types.StringValue(attr)
		}
	}
	return &res, diags
}

func encodeHTTPHeaderFilter(httpHeaderFilter *api.HTTPHeaderFilter) (*HTTPHeaderFilter, diag.Diagnostics) {
	if httpHeaderFilter == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := HTTPHeaderFilter{}
	if httpHeaderFilter.Add != nil {
		res.Add = map[string]types.String{}
		for k, v := range httpHeaderFilter.Add {
			res.Add[k] = types.StringValue(v)
		}
	}
	if httpHeaderFilter.Remove != nil {
		res.Remove = make([]types.String, len(httpHeaderFilter.Remove))
		for i, attr := range httpHeaderFilter.Remove {
			res.Remove[i] = types.StringValue(attr)
		}
	}
	if httpHeaderFilter.Set != nil {
		res.Set = map[string]types.String{}
		for k, v := range httpHeaderFilter.Set {
			res.Set[k] = types.StringValue(v)
		}
	}
	return &res, diags
}

func encodeURLRewrite(urlRewrite *api.URLRewrite) (*URLRewrite, diag.Diagnostics) {
	if urlRewrite == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := URLRewrite{}
	res.Path = types.StringValue(urlRewrite.Path)
	return &res, diags
}

func encodeHTTPHeaderMatch(httpHeaderMatch *api.HTTPHeaderMatch) (*HTTPHeaderMatch, diag.Diagnostics) {
	if httpHeaderMatch == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := HTTPHeaderMatch{}
	res.Match = types.StringValue(string(httpHeaderMatch.Match))
	res.Name = types.StringValue(httpHeaderMatch.Name)
	res.Value = types.StringValue(httpHeaderMatch.Value)
	return &res, diags
}

func encodeHTTPPathMatch(httpPathMatch *api.HTTPPathMatch) (*HTTPPathMatch, diag.Diagnostics) {
	if httpPathMatch == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := HTTPPathMatch{}
	res.Match = types.StringValue(string(httpPathMatch.Match))
	res.Value = types.StringValue(httpPathMatch.Value)
	return &res, diags
}

func encodeHTTPQueryMatch(httpQueryMatch *api.HTTPQueryMatch) (*HTTPQueryMatch, diag.Diagnostics) {
	if httpQueryMatch == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := HTTPQueryMatch{}
	res.Match = types.StringValue(string(httpQueryMatch.Match))
	res.Name = types.StringValue(httpQueryMatch.Name)
	res.Value = types.StringValue(httpQueryMatch.Value)
	return &res, diags
}

func encodeGatewayServiceTLSConfig(gatewayServiceTlsConfig *api.GatewayServiceTLSConfig) (*GatewayServiceTLSConfig, diag.Diagnostics) {
	if gatewayServiceTlsConfig == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := GatewayServiceTLSConfig{}
	{
		data, d := encodeGatewayTLSSDSConfig(gatewayServiceTlsConfig.SDS)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.SDS = data
		}
	}
	return &res, diags
}

func encodePassiveHealthCheck(passiveHealthCheck *api.PassiveHealthCheck) (*PassiveHealthCheck, diag.Diagnostics) {
	if passiveHealthCheck == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := PassiveHealthCheck{}
	res.Interval = types.StringValue(passiveHealthCheck.Interval.String())
	res.MaxFailures = types.Int64Value(int64(passiveHealthCheck.MaxFailures))
	if passiveHealthCheck.EnforcingConsecutive5xx != nil {
		res.EnforcingConsecutive5xx = types.Int64Value(int64(*passiveHealthCheck.EnforcingConsecutive5xx))
	}
	if passiveHealthCheck.MaxEjectionPercent != nil {
		res.MaxEjectionPercent = types.Int64Value(int64(*passiveHealthCheck.MaxEjectionPercent))
	}
	if passiveHealthCheck.BaseEjectionTime != nil {
		res.BaseEjectionTime = types.StringValue(passiveHealthCheck.BaseEjectionTime.String())
	}
	return &res, diags
}

func encodeJWKSRetryPolicy(jwksRetryPolicy *api.JWKSRetryPolicy) (*JWKSRetryPolicy, diag.Diagnostics) {
	if jwksRetryPolicy == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := JWKSRetryPolicy{}
	res.NumRetries = types.Int64Value(int64(jwksRetryPolicy.NumRetries))
	{
		data, d := encodeRetryPolicyBackOff(jwksRetryPolicy.RetryPolicyBackOff)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.RetryPolicyBackOff = data
		}
	}
	return &res, diags
}

func encodeJWKSCluster(jwksCluster *api.JWKSCluster) (*JWKSCluster, diag.Diagnostics) {
	if jwksCluster == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := JWKSCluster{}
	res.DiscoveryType = types.StringValue(string(jwksCluster.DiscoveryType))
	{
		data, d := encodeJWKSTLSCertificate(jwksCluster.TLSCertificates)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.TLSCertificates = data
		}
	}
	res.ConnectTimeout = types.StringValue(jwksCluster.ConnectTimeout.String())
	return &res, diags
}

func encodeQueryFailoverTarget(queryFailoverTarget *api.QueryFailoverTarget) (*QueryFailoverTarget, diag.Diagnostics) {
	if queryFailoverTarget == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := QueryFailoverTarget{}
	res.Peer = types.StringValue(queryFailoverTarget.Peer)
	res.Datacenter = types.StringValue(queryFailoverTarget.Datacenter)
	res.Partition = types.StringValue(queryFailoverTarget.Partition)
	res.Namespace = types.StringValue(queryFailoverTarget.Namespace)
	return &res, diags
}

func encodeUpstreamLimits(upstreamLimits *api.UpstreamLimits) (*UpstreamLimits, diag.Diagnostics) {
	if upstreamLimits == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := UpstreamLimits{}
	if upstreamLimits.MaxConnections != nil {
		res.MaxConnections = types.Int64Value(int64(*upstreamLimits.MaxConnections))
	}
	if upstreamLimits.MaxPendingRequests != nil {
		res.MaxPendingRequests = types.Int64Value(int64(*upstreamLimits.MaxPendingRequests))
	}
	if upstreamLimits.MaxConcurrentRequests != nil {
		res.MaxConcurrentRequests = types.Int64Value(int64(*upstreamLimits.MaxConcurrentRequests))
	}
	return &res, diags
}

func encodeIntentionHTTPPermission(intentionHttpPermission *api.IntentionHTTPPermission) (*IntentionHTTPPermission, diag.Diagnostics) {
	if intentionHttpPermission == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := IntentionHTTPPermission{}
	return &res, diags
}

func encodeIntentionJWTClaimVerification(intentionJwtClaimVerification *api.IntentionJWTClaimVerification) (*IntentionJWTClaimVerification, diag.Diagnostics) {
	if intentionJwtClaimVerification == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := IntentionJWTClaimVerification{}
	if intentionJwtClaimVerification.Path != nil {
		res.Path = make([]types.String, len(intentionJwtClaimVerification.Path))
		for i, attr := range intentionJwtClaimVerification.Path {
			res.Path[i] = types.StringValue(attr)
		}
	}
	res.Value = types.StringValue(intentionJwtClaimVerification.Value)
	return &res, diags
}

func encodeServiceRouteHTTPMatch(serviceRouteHttpMatch *api.ServiceRouteHTTPMatch) (*ServiceRouteHTTPMatch, diag.Diagnostics) {
	if serviceRouteHttpMatch == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceRouteHTTPMatch{}
	res.PathExact = types.StringValue(serviceRouteHttpMatch.PathExact)
	res.PathPrefix = types.StringValue(serviceRouteHttpMatch.PathPrefix)
	res.PathRegex = types.StringValue(serviceRouteHttpMatch.PathRegex)
	if serviceRouteHttpMatch.Header != nil {
		res.Header = make([]*ServiceRouteHTTPMatchHeader, len(serviceRouteHttpMatch.Header))
		for i, attr := range serviceRouteHttpMatch.Header {
			{
				data, d := encodeServiceRouteHTTPMatchHeader(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.Header[i] = data
				}
			}
		}
	}
	if serviceRouteHttpMatch.QueryParam != nil {
		res.QueryParam = make([]*ServiceRouteHTTPMatchQueryParam, len(serviceRouteHttpMatch.QueryParam))
		for i, attr := range serviceRouteHttpMatch.QueryParam {
			{
				data, d := encodeServiceRouteHTTPMatchQueryParam(&attr)
				diags.Append(d...)
				if diags.HasError() {
					return nil, diags
				}
				if data != nil {
					res.QueryParam[i] = data
				}
			}
		}
	}
	if serviceRouteHttpMatch.Methods != nil {
		res.Methods = make([]types.String, len(serviceRouteHttpMatch.Methods))
		for i, attr := range serviceRouteHttpMatch.Methods {
			res.Methods[i] = types.StringValue(attr)
		}
	}
	return &res, diags
}

func encodeRetryPolicyBackOff(retryPolicyBackOff *api.RetryPolicyBackOff) (*RetryPolicyBackOff, diag.Diagnostics) {
	if retryPolicyBackOff == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := RetryPolicyBackOff{}
	return &res, diags
}

func encodeJWKSTLSCertificate(jwkstlsCertificate *api.JWKSTLSCertificate) (*JWKSTLSCertificate, diag.Diagnostics) {
	if jwkstlsCertificate == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := JWKSTLSCertificate{}
	{
		data, d := encodeJWKSTLSCertProviderInstance(jwkstlsCertificate.CaCertificateProviderInstance)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.CaCertificateProviderInstance = data
		}
	}
	{
		data, d := encodeJWKSTLSCertTrustedCA(jwkstlsCertificate.TrustedCA)
		diags.Append(d...)
		if diags.HasError() {
			return nil, diags
		}
		if data != nil {
			res.TrustedCA = data
		}
	}
	return &res, diags
}

func encodeServiceRouteHTTPMatchHeader(serviceRouteHttpMatchHeader *api.ServiceRouteHTTPMatchHeader) (*ServiceRouteHTTPMatchHeader, diag.Diagnostics) {
	if serviceRouteHttpMatchHeader == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceRouteHTTPMatchHeader{}
	res.Name = types.StringValue(serviceRouteHttpMatchHeader.Name)
	res.Present = types.BoolValue(serviceRouteHttpMatchHeader.Present)
	res.Exact = types.StringValue(serviceRouteHttpMatchHeader.Exact)
	res.Prefix = types.StringValue(serviceRouteHttpMatchHeader.Prefix)
	res.Suffix = types.StringValue(serviceRouteHttpMatchHeader.Suffix)
	res.Regex = types.StringValue(serviceRouteHttpMatchHeader.Regex)
	res.Invert = types.BoolValue(serviceRouteHttpMatchHeader.Invert)
	return &res, diags
}

func encodeServiceRouteHTTPMatchQueryParam(serviceRouteHttpMatchQueryParam *api.ServiceRouteHTTPMatchQueryParam) (*ServiceRouteHTTPMatchQueryParam, diag.Diagnostics) {
	if serviceRouteHttpMatchQueryParam == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := ServiceRouteHTTPMatchQueryParam{}
	res.Name = types.StringValue(serviceRouteHttpMatchQueryParam.Name)
	res.Present = types.BoolValue(serviceRouteHttpMatchQueryParam.Present)
	res.Exact = types.StringValue(serviceRouteHttpMatchQueryParam.Exact)
	res.Regex = types.StringValue(serviceRouteHttpMatchQueryParam.Regex)
	return &res, diags
}

func encodeJWKSTLSCertProviderInstance(jwkstlsCertProviderInstance *api.JWKSTLSCertProviderInstance) (*JWKSTLSCertProviderInstance, diag.Diagnostics) {
	if jwkstlsCertProviderInstance == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := JWKSTLSCertProviderInstance{}
	res.InstanceName = types.StringValue(jwkstlsCertProviderInstance.InstanceName)
	res.CertificateName = types.StringValue(jwkstlsCertProviderInstance.CertificateName)
	return &res, diags
}

func encodeJWKSTLSCertTrustedCA(jwkstlsCertTrustedCa *api.JWKSTLSCertTrustedCA) (*JWKSTLSCertTrustedCA, diag.Diagnostics) {
	if jwkstlsCertTrustedCa == nil {
		return nil, nil
	}

	var diags diag.Diagnostics
	res := JWKSTLSCertTrustedCA{}
	res.Filename = types.StringValue(jwkstlsCertTrustedCa.Filename)
	res.EnvironmentVariable = types.StringValue(jwkstlsCertTrustedCa.EnvironmentVariable)
	res.InlineString = types.StringValue(jwkstlsCertTrustedCa.InlineString)
	res.InlineBytes = types.StringValue(string(jwkstlsCertTrustedCa.InlineBytes))
	return &res, diags
}
