/*
Code generated by github-terraform-generator; DO NOT EDIT.
Any modifications will be overwritten
*/

package resource

import (
	schema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	booldefault "github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	int64default "github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	stringdefault "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	validator "github.com/hashicorp/terraform-plugin-framework/schema/validator"
	types "github.com/hashicorp/terraform-plugin-framework/types"
)

func aclAuthMethodSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"name": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "The name of the ACL auth method.",
			},
			"type": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "The type of the ACL auth method.",
			},
			"display_name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The display name for this ACL auth method.",
				Default:             stringdefault.StaticString(""),
			},
			"description": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The description for this ACL auth method.",
				Default:             stringdefault.StaticString(""),
			},
			"max_token_ttl": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The maximum time-to-live of the tokens this auth method produces.",
				Default:             stringdefault.StaticString("0s"),
			},
			"token_locality": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "token_locality defines the kind of token that this auth method produces. This can be either 'local' or 'global'. If empty 'local' is assumed.",
				Default:             stringdefault.StaticString(""),
			},
			"config": schema.StringAttribute{
				Optional:            true,
				MarkdownDescription: "The configuration for this ACL auth method. This should only contain primitive values and containers (such as lists and maps).",
			},
			"namespace_rules": &schema.ListNestedAttribute{
				Optional:            true,
				MarkdownDescription: "namespace_rules apply only on auth methods defined in the default namespace. Namespacing is a Consul Enterprise feature.",
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"selector": schema.StringAttribute{
							Optional:            true,
							MarkdownDescription: "selector is an expression that matches against verified identity attributes returned from the auth method during login.",
						},
						"bind_namespace": schema.StringAttribute{
							Optional:            true,
							MarkdownDescription: "bind_namespace is the target namespace of the binding. Can be lightly templated using HIL `${foo}` syntax from available field names. If empty it's created in the same namespace as the auth method.",
						},
					}},
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The namespace this ACL auth method is associated with. Namespacing is a Consul Enterprise feature.",
				Default:             stringdefault.StaticString(""),
			},
			"partition": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The partition this ACL auth method is associated with. Partitions are a Consul Enterprise feature.",
				Default:             stringdefault.StaticString(""),
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func aclBindingRuleSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"description": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"auth_method": schema.StringAttribute{
				Required: true,
			},
			"selector": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"bind_type": schema.StringAttribute{
				Required: true,
			},
			"bind_name": schema.StringAttribute{
				Required: true,
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"partition": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func aclPolicySchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"name": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "The name of this ACL policy.",
			},
			"description": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The description of this ACL policy.",
				Default:             stringdefault.StaticString(""),
			},
			"rules": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "The rules of this ACL policy.",
			},
			"datacenters": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				MarkdownDescription: "The datacenters this ACL policy is valid in.",
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The namespace the ACL policy is associated with. Namespacing is a Consul Enterprise feature.",
				Default:             stringdefault.StaticString(""),
			},
			"partition": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The partition the ACL policy is associated with. Partitions are a Consul Enterprise feature.",
				Default:             stringdefault.StaticString(""),
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func aclRoleSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"name": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "The name of this ACL role.",
			},
			"description": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The description of this ACL role.",
				Default:             stringdefault.StaticString(""),
			},
			"policies": &schema.ListNestedAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The policies associated with this ACL role.",
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"id": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							MarkdownDescription: "The ID of the ACL policy associated with this role.",
							Validators:          []validator.String{NewMutuallyExclusiveValidator("name")},
						},
						"name": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							MarkdownDescription: "The name of the ACL policy associated with this role.",
							Validators:          []validator.String{NewMutuallyExclusiveValidator("id")},
						},
					}},
			},
			"service_identities": &schema.ListNestedAttribute{
				Optional:            true,
				MarkdownDescription: "The services associated with this ACL role.",
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"service_name": schema.StringAttribute{
							Required:            true,
							MarkdownDescription: "The service associated with this ACL role.",
						},
						"datacenters": schema.ListAttribute{
							ElementType: types.StringType,
							Optional:    true,
						},
					}},
			},
			"node_identities": &schema.ListNestedAttribute{
				Optional:            true,
				MarkdownDescription: "The nodes associated with this ACL role.",
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"node_name": schema.StringAttribute{
							Required:            true,
							MarkdownDescription: "The node associated with this ACL role.",
						},
						"datacenter": schema.StringAttribute{
							Optional: true,
						},
					}},
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The namespace the ACL role is associated with. Namespacing is a Consul Enterprise feature.",
				Default:             stringdefault.StaticString(""),
			},
			"partition": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The partition the ACL role is associated with. Partitions are a Consul Enterprise feature.",
				Default:             stringdefault.StaticString(""),
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func aclTokenSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"accessor_id": schema.StringAttribute{
				Computed: true,
			},
			"description": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"policies": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"id": schema.StringAttribute{
							Optional:   true,
							Computed:   true,
							Validators: []validator.String{NewMutuallyExclusiveValidator("name")},
						},
						"name": schema.StringAttribute{
							Optional:   true,
							Computed:   true,
							Validators: []validator.String{NewMutuallyExclusiveValidator("id")},
						},
					}},
			},
			"roles": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"id": schema.StringAttribute{
							Optional:   true,
							Computed:   true,
							Validators: []validator.String{NewMutuallyExclusiveValidator("name")},
						},
						"name": schema.StringAttribute{
							Optional:   true,
							Computed:   true,
							Validators: []validator.String{NewMutuallyExclusiveValidator("id")},
						},
					}},
			},
			"service_identities": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"service_name": schema.StringAttribute{
							Required: true,
						},
						"datacenters": schema.ListAttribute{
							ElementType: types.StringType,
							Optional:    true,
						},
					}},
			},
			"node_identities": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"node_name": schema.StringAttribute{
							Required: true,
						},
						"datacenter": schema.StringAttribute{
							Optional: true,
						},
					}},
			},
			"local": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `false`",
				Default:             booldefault.StaticBool(false),
			},
			"auth_method": schema.StringAttribute{
				Computed: true,
			},
			"expiration_ttl": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"0s\"`",
				Default:             stringdefault.StaticString("0s"),
			},
			"expiration_time": schema.StringAttribute{
				Computed: true,
			},
			"create_time": schema.StringAttribute{
				Computed: true,
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"partition": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"auth_method_namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func aclTokenPolicyAttachmentSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"token_id": schema.StringAttribute{
				Required: true,
			},
			"policy": &schema.SingleNestedAttribute{
				Required: true,
				Attributes: map[string]schema.Attribute{
					"id": schema.StringAttribute{
						Optional:   true,
						Computed:   true,
						Validators: []validator.String{NewMutuallyExclusiveValidator("name")},
					},
					"name": schema.StringAttribute{
						Optional:   true,
						Computed:   true,
						Validators: []validator.String{NewMutuallyExclusiveValidator("id")},
					},
				},
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func aclTokenRoleAttachmentSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"token_id": schema.StringAttribute{
				Required: true,
			},
			"role": &schema.SingleNestedAttribute{
				Required: true,
				Attributes: map[string]schema.Attribute{
					"id": schema.StringAttribute{
						Optional:   true,
						Computed:   true,
						Validators: []validator.String{NewMutuallyExclusiveValidator("name")},
					},
					"name": schema.StringAttribute{
						Optional:   true,
						Computed:   true,
						Validators: []validator.String{NewMutuallyExclusiveValidator("id")},
					},
				},
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func adminPartitionSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				Required: true,
			},
			"description": schema.StringAttribute{
				Optional: true,
			},
			"deleted_at": schema.StringAttribute{
				Optional: true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func apiGatewayConfigEntrySchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				Optional: true,
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"listeners": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							Optional: true,
						},
						"hostname": schema.StringAttribute{
							Optional: true,
						},
						"port": schema.Int64Attribute{
							Optional: true,
						},
						"protocol": schema.StringAttribute{
							Optional: true,
						},
						"tls": &schema.SingleNestedAttribute{
							Optional: true,
							Attributes: map[string]schema.Attribute{
								"certificates": &schema.ListNestedAttribute{
									Optional: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"kind": schema.StringAttribute{
												Optional: true,
											},
											"name": schema.StringAttribute{
												Optional: true,
											},
											"section_name": schema.StringAttribute{
												Optional: true,
											},
											"partition": schema.StringAttribute{
												Optional: true,
											},
											"namespace": schema.StringAttribute{
												Optional: true,
											},
										}},
								},
								"max_version": schema.StringAttribute{
									Optional: true,
								},
								"min_version": schema.StringAttribute{
									Optional: true,
								},
								"cipher_suites": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
								},
							},
						},
					}},
			},
			"status": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"conditions": &schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"type": schema.StringAttribute{
									Optional: true,
								},
								"status": schema.StringAttribute{
									Optional: true,
								},
								"reason": schema.StringAttribute{
									Optional: true,
								},
								"message": schema.StringAttribute{
									Optional: true,
								},
								"resource": &schema.SingleNestedAttribute{
									Optional: true,
									Attributes: map[string]schema.Attribute{
										"kind": schema.StringAttribute{
											Optional: true,
										},
										"name": schema.StringAttribute{
											Optional: true,
										},
										"section_name": schema.StringAttribute{
											Optional: true,
										},
										"partition": schema.StringAttribute{
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											Optional: true,
										},
									},
								},
								"last_transition_time": schema.StringAttribute{
									Optional: true,
								},
							}},
					},
				},
			},
			"partition": schema.StringAttribute{
				Optional: true,
			},
			"namespace": schema.StringAttribute{
				Optional: true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func areaSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"peer_datacenter": schema.StringAttribute{
				Required: true,
			},
			"retry_join": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"use_tls": schema.BoolAttribute{
				Optional: true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func autopilotConfigSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"cleanup_dead_servers": schema.BoolAttribute{
				Optional: true,
				Computed: true,
			},
			"max_trailing_logs": schema.Int64Attribute{
				Optional: true,
				Computed: true,
			},
			"min_quorum": schema.Int64Attribute{
				Optional: true,
				Computed: true,
			},
			"redundancy_zone_tag": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"disable_upgrade_migration": schema.BoolAttribute{
				Optional: true,
				Computed: true,
			},
			"upgrade_version_tag": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func catalogServiceSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Optional: true,
			},
			"node": schema.StringAttribute{
				Optional: true,
			},
			"address": schema.StringAttribute{
				Optional: true,
			},
			"datacenter": schema.StringAttribute{
				Optional: true,
			},
			"tagged_addresses": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"node_meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"service_id": schema.StringAttribute{
				Optional: true,
			},
			"service_name": schema.StringAttribute{
				Optional: true,
			},
			"service_address": schema.StringAttribute{
				Optional: true,
			},
			"service_tagged_addresses": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"address": schema.StringAttribute{
							Optional: true,
						},
						"port": schema.Int64Attribute{
							Optional: true,
						},
					},
				},
			},
			"service_tags": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"service_meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"service_port": schema.Int64Attribute{
				Optional: true,
			},
			"service_weights": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"passing": schema.Int64Attribute{
						Optional: true,
					},
					"warning": schema.Int64Attribute{
						Optional: true,
					},
				},
			},
			"service_enable_tag_override": schema.BoolAttribute{
				Optional: true,
			},
			"service_proxy": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"envoy_extensions": &schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Optional: true,
								},
								"required": schema.BoolAttribute{
									Optional: true,
								},
								"arguments": schema.StringAttribute{
									Optional: true,
								},
								"consul_version": schema.StringAttribute{
									Optional: true,
								},
								"envoy_version": schema.StringAttribute{
									Optional: true,
								},
							}},
					},
					"destination_service_name": schema.StringAttribute{
						Optional: true,
					},
					"destination_service_id": schema.StringAttribute{
						Optional: true,
					},
					"local_service_address": schema.StringAttribute{
						Optional: true,
					},
					"local_service_port": schema.Int64Attribute{
						Optional: true,
					},
					"local_service_socket_path": schema.StringAttribute{
						Optional: true,
					},
					"mode": schema.StringAttribute{
						Optional: true,
					},
					"transparent_proxy": &schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"outbound_listener_port": schema.Int64Attribute{
								Optional: true,
							},
							"dialed_directly": schema.BoolAttribute{
								Optional: true,
							},
						},
					},
					"config": schema.StringAttribute{
						Optional: true,
					},
					"upstreams": &schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"destination_type": schema.StringAttribute{
									Optional: true,
								},
								"destination_partition": schema.StringAttribute{
									Optional: true,
								},
								"destination_namespace": schema.StringAttribute{
									Optional: true,
								},
								"destination_peer": schema.StringAttribute{
									Optional: true,
								},
								"destination_name": schema.StringAttribute{
									Optional: true,
								},
								"datacenter": schema.StringAttribute{
									Optional: true,
								},
								"local_bind_address": schema.StringAttribute{
									Optional: true,
								},
								"local_bind_port": schema.Int64Attribute{
									Optional: true,
								},
								"local_bind_socket_path": schema.StringAttribute{
									Optional: true,
								},
								"local_bind_socket_mode": schema.StringAttribute{
									Optional: true,
								},
								"config": schema.StringAttribute{
									Optional: true,
								},
								"mesh_gateway": &schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"mode": schema.StringAttribute{
											Optional: true,
										},
									},
								},
								"centrally_configured": schema.BoolAttribute{
									Optional: true,
								},
							}},
					},
					"mesh_gateway": &schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"mode": schema.StringAttribute{
								Optional: true,
							},
						},
					},
					"expose": &schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"checks": schema.BoolAttribute{
								Optional: true,
							},
							"paths": &schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"listener_port": schema.Int64Attribute{
											Optional: true,
										},
										"path": schema.StringAttribute{
											Optional: true,
										},
										"local_path_port": schema.Int64Attribute{
											Optional: true,
										},
										"protocol": schema.StringAttribute{
											Optional: true,
										},
										"parsed_from_check": schema.BoolAttribute{
											Optional: true,
										},
									}},
							},
						},
					},
					"access_logs": &schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional: true,
							},
							"disable_listener_logs": schema.BoolAttribute{
								Optional: true,
							},
							"type": schema.StringAttribute{
								Optional: true,
							},
							"path": schema.StringAttribute{
								Optional: true,
							},
							"json_format": schema.StringAttribute{
								Optional: true,
							},
							"text_format": schema.StringAttribute{
								Optional: true,
							},
						},
					},
				},
			},
			"service_locality": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"region": schema.StringAttribute{
						Optional: true,
					},
					"zone": schema.StringAttribute{
						Optional: true,
					},
				},
			},
			"create_index": schema.Int64Attribute{
				Optional: true,
			},
			"checks": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"node": schema.StringAttribute{
							Optional: true,
						},
						"check_id": schema.StringAttribute{
							Optional: true,
						},
						"name": schema.StringAttribute{
							Optional: true,
						},
						"status": schema.StringAttribute{
							Optional: true,
						},
						"notes": schema.StringAttribute{
							Optional: true,
						},
						"output": schema.StringAttribute{
							Optional: true,
						},
						"service_id": schema.StringAttribute{
							Optional: true,
						},
						"service_name": schema.StringAttribute{
							Optional: true,
						},
						"service_tags": schema.ListAttribute{
							ElementType: types.StringType,
							Optional:    true,
						},
						"type": schema.StringAttribute{
							Optional: true,
						},
						"namespace": schema.StringAttribute{
							Optional: true,
						},
						"partition": schema.StringAttribute{
							Optional: true,
						},
						"exposed_port": schema.Int64Attribute{
							Optional: true,
						},
						"peer_name": schema.StringAttribute{
							Optional: true,
						},
						"definition": &schema.SingleNestedAttribute{
							Optional: true,
							Attributes: map[string]schema.Attribute{
								"http": schema.StringAttribute{
									Optional: true,
								},
								"header": schema.MapAttribute{
									ElementType: types.ListType{
										ElemType: types.StringType,
									},
									Optional: true,
								},
								"method": schema.StringAttribute{
									Optional: true,
								},
								"body": schema.StringAttribute{
									Optional: true,
								},
								"tls_server_name": schema.StringAttribute{
									Optional: true,
								},
								"tls_skip_verify": schema.BoolAttribute{
									Optional: true,
								},
								"tcp": schema.StringAttribute{
									Optional: true,
								},
								"udp": schema.StringAttribute{
									Optional: true,
								},
								"grpc": schema.StringAttribute{
									Optional: true,
								},
								"os_service": schema.StringAttribute{
									Optional: true,
								},
								"grpc_use_tls": schema.BoolAttribute{
									Optional: true,
								},
								"interval_duration": schema.StringAttribute{
									Optional: true,
								},
								"timeout_duration": schema.StringAttribute{
									Optional: true,
								},
								"deregister_critical_service_after_duration": schema.StringAttribute{
									Optional: true,
								},
							},
						},
					}},
			},
			"modify_index": schema.Int64Attribute{
				Optional: true,
			},
			"namespace": schema.StringAttribute{
				Optional: true,
			},
			"partition": schema.StringAttribute{
				Optional: true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func certificateAuthoritySchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"connect_provider": schema.StringAttribute{
				Required: true,
			},
			"config": schema.StringAttribute{
				Optional: true,
			},
			"state": schema.MapAttribute{
				ElementType: types.StringType,
				Computed:    true,
			},
			"force_without_cross_signing": schema.BoolAttribute{
				Optional: true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func configEntrySchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"kind": schema.StringAttribute{
				Optional: true,
			},
			"name": schema.StringAttribute{
				Optional: true,
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"partition": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"config": schema.StringAttribute{
				Optional: true,
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func exportedServicesConfigEntrySchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				Optional: true,
			},
			"partition": schema.StringAttribute{
				Optional: true,
			},
			"services": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							Optional: true,
						},
						"namespace": schema.StringAttribute{
							Optional: true,
						},
						"consumers": &schema.ListNestedAttribute{
							Optional: true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"partition": schema.StringAttribute{
										Optional: true,
									},
									"peer": schema.StringAttribute{
										Optional: true,
									},
									"sameness_group": schema.StringAttribute{
										Optional: true,
									},
								}},
						},
					}},
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func httpRouteConfigEntrySchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				Optional: true,
			},
			"parents": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"kind": schema.StringAttribute{
							Optional: true,
						},
						"name": schema.StringAttribute{
							Optional: true,
						},
						"section_name": schema.StringAttribute{
							Optional: true,
						},
						"partition": schema.StringAttribute{
							Optional: true,
						},
						"namespace": schema.StringAttribute{
							Optional: true,
						},
					}},
			},
			"rules": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"filters": &schema.SingleNestedAttribute{
							Optional: true,
							Attributes: map[string]schema.Attribute{
								"headers": &schema.ListNestedAttribute{
									Optional: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"add": schema.MapAttribute{
												ElementType: types.StringType,
												Optional:    true,
											},
											"remove": schema.ListAttribute{
												ElementType: types.StringType,
												Optional:    true,
											},
											"set": schema.MapAttribute{
												ElementType: types.StringType,
												Optional:    true,
											},
										}},
								},
								"url_rewrite": &schema.SingleNestedAttribute{
									Optional: true,
									Attributes: map[string]schema.Attribute{
										"path": schema.StringAttribute{
											Optional: true,
										},
									},
								},
							},
						},
						"matches": &schema.ListNestedAttribute{
							Optional: true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"headers": &schema.ListNestedAttribute{
										Optional: true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"match": schema.StringAttribute{
													Optional: true,
												},
												"name": schema.StringAttribute{
													Optional: true,
												},
												"value": schema.StringAttribute{
													Optional: true,
												},
											}},
									},
									"method": schema.StringAttribute{
										Optional: true,
									},
									"path": &schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"match": schema.StringAttribute{
												Optional: true,
											},
											"value": schema.StringAttribute{
												Optional: true,
											},
										},
									},
									"query": &schema.ListNestedAttribute{
										Optional: true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"match": schema.StringAttribute{
													Optional: true,
												},
												"name": schema.StringAttribute{
													Optional: true,
												},
												"value": schema.StringAttribute{
													Optional: true,
												},
											}},
									},
								}},
						},
						"services": &schema.ListNestedAttribute{
							Optional: true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										Optional: true,
									},
									"weight": schema.Int64Attribute{
										Optional: true,
									},
									"filters": &schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"headers": &schema.ListNestedAttribute{
												Optional: true,
												NestedObject: schema.NestedAttributeObject{
													Attributes: map[string]schema.Attribute{
														"add": schema.MapAttribute{
															ElementType: types.StringType,
															Optional:    true,
														},
														"remove": schema.ListAttribute{
															ElementType: types.StringType,
															Optional:    true,
														},
														"set": schema.MapAttribute{
															ElementType: types.StringType,
															Optional:    true,
														},
													}},
											},
											"url_rewrite": &schema.SingleNestedAttribute{
												Optional: true,
												Attributes: map[string]schema.Attribute{
													"path": schema.StringAttribute{
														Optional: true,
													},
												},
											},
										},
									},
									"partition": schema.StringAttribute{
										Optional: true,
									},
									"namespace": schema.StringAttribute{
										Optional: true,
									},
								}},
						},
					}},
			},
			"hostnames": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"partition": schema.StringAttribute{
				Optional: true,
			},
			"namespace": schema.StringAttribute{
				Optional: true,
			},
			"status": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"conditions": &schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"type": schema.StringAttribute{
									Optional: true,
								},
								"status": schema.StringAttribute{
									Optional: true,
								},
								"reason": schema.StringAttribute{
									Optional: true,
								},
								"message": schema.StringAttribute{
									Optional: true,
								},
								"resource": &schema.SingleNestedAttribute{
									Optional: true,
									Attributes: map[string]schema.Attribute{
										"kind": schema.StringAttribute{
											Optional: true,
										},
										"name": schema.StringAttribute{
											Optional: true,
										},
										"section_name": schema.StringAttribute{
											Optional: true,
										},
										"partition": schema.StringAttribute{
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											Optional: true,
										},
									},
								},
								"last_transition_time": schema.StringAttribute{
									Optional: true,
								},
							}},
					},
				},
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func ingressGatewayConfigEntrySchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				Optional: true,
			},
			"partition": schema.StringAttribute{
				Optional: true,
			},
			"namespace": schema.StringAttribute{
				Optional: true,
			},
			"tls": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional: true,
					},
					"sds": &schema.SingleNestedAttribute{
						Optional:   true,
						Attributes: map[string]schema.Attribute{},
					},
					"tls_min_version": schema.StringAttribute{
						Optional: true,
					},
					"tls_max_version": schema.StringAttribute{
						Optional: true,
					},
					"cipher_suites": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
				},
			},
			"listeners": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"port": schema.Int64Attribute{
							Optional: true,
						},
						"protocol": schema.StringAttribute{
							Optional: true,
						},
						"services": &schema.ListNestedAttribute{
							Optional: true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										Optional: true,
									},
									"hosts": schema.ListAttribute{
										ElementType: types.StringType,
										Optional:    true,
									},
									"namespace": schema.StringAttribute{
										Optional: true,
									},
									"partition": schema.StringAttribute{
										Optional: true,
									},
									"tls": &schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"sds": &schema.SingleNestedAttribute{
												Optional:   true,
												Attributes: map[string]schema.Attribute{},
											},
										},
									},
									"request_headers": &schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"add": schema.MapAttribute{
												ElementType: types.StringType,
												Optional:    true,
											},
											"set": schema.MapAttribute{
												ElementType: types.StringType,
												Optional:    true,
											},
											"remove": schema.ListAttribute{
												ElementType: types.StringType,
												Optional:    true,
											},
										},
									},
									"response_headers": &schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"add": schema.MapAttribute{
												ElementType: types.StringType,
												Optional:    true,
											},
											"set": schema.MapAttribute{
												ElementType: types.StringType,
												Optional:    true,
											},
											"remove": schema.ListAttribute{
												ElementType: types.StringType,
												Optional:    true,
											},
										},
									},
									"max_connections": schema.Int64Attribute{
										Optional: true,
									},
									"max_pending_requests": schema.Int64Attribute{
										Optional: true,
									},
									"max_concurrent_requests": schema.Int64Attribute{
										Optional: true,
									},
									"passive_health_check": &schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"interval": schema.StringAttribute{
												Optional: true,
											},
											"max_failures": schema.Int64Attribute{
												Optional: true,
											},
											"enforcing_consecutive5xx": schema.Int64Attribute{
												Optional: true,
											},
											"max_ejection_percent": schema.Int64Attribute{
												Optional: true,
											},
											"base_ejection_time": schema.StringAttribute{
												Optional: true,
											},
										},
									},
								}},
						},
						"tls": &schema.SingleNestedAttribute{
							Optional: true,
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									Optional: true,
								},
								"sds": &schema.SingleNestedAttribute{
									Optional:   true,
									Attributes: map[string]schema.Attribute{},
								},
								"tls_min_version": schema.StringAttribute{
									Optional: true,
								},
								"tls_max_version": schema.StringAttribute{
									Optional: true,
								},
								"cipher_suites": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
								},
							},
						},
					}},
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"defaults": &schema.SingleNestedAttribute{
				Optional:   true,
				Attributes: map[string]schema.Attribute{},
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func inlineCertificateConfigEntrySchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				Optional: true,
			},
			"certificate": schema.StringAttribute{
				Optional: true,
			},
			"private_key": schema.StringAttribute{
				Optional: true,
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"partition": schema.StringAttribute{
				Optional: true,
			},
			"namespace": schema.StringAttribute{
				Optional: true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func jwtProviderConfigEntrySchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				Optional: true,
			},
			"json_web_key_set": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"local": &schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"jwks": schema.StringAttribute{
								Optional: true,
							},
							"filename": schema.StringAttribute{
								Optional: true,
							},
						},
					},
					"remote": &schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"uri": schema.StringAttribute{
								Optional: true,
							},
							"request_timeout_ms": schema.Int64Attribute{
								Optional: true,
							},
							"cache_duration": schema.StringAttribute{
								Optional: true,
							},
							"fetch_asynchronously": schema.BoolAttribute{
								Optional: true,
							},
							"retry_policy": &schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"num_retries": schema.Int64Attribute{
										Optional: true,
									},
									"retry_policy_back_off": &schema.SingleNestedAttribute{
										Optional:   true,
										Attributes: map[string]schema.Attribute{},
									},
								},
							},
							"jwks_cluster": &schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"discovery_type": schema.StringAttribute{
										Optional: true,
									},
									"tls_certificates": &schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"ca_certificate_provider_instance": &schema.SingleNestedAttribute{
												Optional: true,
												Attributes: map[string]schema.Attribute{
													"instance_name": schema.StringAttribute{
														Optional: true,
													},
													"certificate_name": schema.StringAttribute{
														Optional: true,
													},
												},
											},
											"trusted_ca": &schema.SingleNestedAttribute{
												Optional: true,
												Attributes: map[string]schema.Attribute{
													"filename": schema.StringAttribute{
														Optional: true,
													},
													"environment_variable": schema.StringAttribute{
														Optional: true,
													},
													"inline_string": schema.StringAttribute{
														Optional: true,
													},
													"inline_bytes": schema.StringAttribute{
														Optional: true,
													},
												},
											},
										},
									},
									"connect_timeout": schema.StringAttribute{
										Optional: true,
									},
								},
							},
						},
					},
				},
			},
			"issuer": schema.StringAttribute{
				Optional: true,
			},
			"audiences": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"locations": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"header": &schema.SingleNestedAttribute{
							Optional: true,
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Optional: true,
								},
								"value_prefix": schema.StringAttribute{
									Optional: true,
								},
								"forward": schema.BoolAttribute{
									Optional: true,
								},
							},
						},
						"query_param": &schema.SingleNestedAttribute{
							Optional: true,
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						"cookie": &schema.SingleNestedAttribute{
							Optional: true,
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Optional: true,
								},
							},
						},
					}},
			},
			"forwarding": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"header_name": schema.StringAttribute{
						Optional: true,
					},
					"pad_forward_payload_header": schema.BoolAttribute{
						Optional: true,
					},
				},
			},
			"clock_skew_seconds": schema.Int64Attribute{
				Optional: true,
			},
			"cache_config": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"size": schema.Int64Attribute{
						Optional: true,
					},
				},
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"partition": schema.StringAttribute{
				Optional: true,
			},
			"namespace": schema.StringAttribute{
				Optional: true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func meshConfigEntrySchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"partition": schema.StringAttribute{
				Optional: true,
			},
			"namespace": schema.StringAttribute{
				Optional: true,
			},
			"transparent_proxy": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"mesh_destinations_only": schema.BoolAttribute{
						Optional: true,
					},
				},
			},
			"allow_enabling_permissive_mutual_tls": schema.BoolAttribute{
				Optional: true,
			},
			"tls": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"incoming": &schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"tls_min_version": schema.StringAttribute{
								Optional: true,
							},
							"tls_max_version": schema.StringAttribute{
								Optional: true,
							},
							"cipher_suites": schema.ListAttribute{
								ElementType: types.StringType,
								Optional:    true,
							},
						},
					},
					"outgoing": &schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"tls_min_version": schema.StringAttribute{
								Optional: true,
							},
							"tls_max_version": schema.StringAttribute{
								Optional: true,
							},
							"cipher_suites": schema.ListAttribute{
								ElementType: types.StringType,
								Optional:    true,
							},
						},
					},
				},
			},
			"http": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"sanitize_x_forwarded_client_cert": schema.BoolAttribute{
						Optional: true,
					},
				},
			},
			"peering": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"peer_through_mesh_gateways": schema.BoolAttribute{
						Optional: true,
					},
				},
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func namespaceSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				Required: true,
			},
			"description": schema.StringAttribute{
				Optional: true,
			},
			"ac_ls": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"policy_defaults": &schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"id": schema.StringAttribute{
									Optional:   true,
									Computed:   true,
									Validators: []validator.String{NewMutuallyExclusiveValidator("name")},
								},
								"name": schema.StringAttribute{
									Optional:   true,
									Computed:   true,
									Validators: []validator.String{NewMutuallyExclusiveValidator("id")},
								},
							}},
					},
					"role_defaults": &schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"id": schema.StringAttribute{
									Optional:   true,
									Computed:   true,
									Validators: []validator.String{NewMutuallyExclusiveValidator("name")},
								},
								"name": schema.StringAttribute{
									Optional:   true,
									Computed:   true,
									Validators: []validator.String{NewMutuallyExclusiveValidator("id")},
								},
							}},
					},
				},
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"deleted_at": schema.StringAttribute{
				Optional: true,
			},
			"partition": schema.StringAttribute{
				Optional: true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func namespacePolicyAttachmentSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"namespace": schema.StringAttribute{
				Required: true,
			},
			"policy": &schema.SingleNestedAttribute{
				Required: true,
				Attributes: map[string]schema.Attribute{
					"id": schema.StringAttribute{
						Optional:   true,
						Computed:   true,
						Validators: []validator.String{NewMutuallyExclusiveValidator("name")},
					},
					"name": schema.StringAttribute{
						Optional:   true,
						Computed:   true,
						Validators: []validator.String{NewMutuallyExclusiveValidator("id")},
					},
				},
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func namespaceRoleAttachmentSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"namespace": schema.StringAttribute{
				Required: true,
			},
			"role": &schema.SingleNestedAttribute{
				Required: true,
				Attributes: map[string]schema.Attribute{
					"id": schema.StringAttribute{
						Optional:   true,
						Computed:   true,
						Validators: []validator.String{NewMutuallyExclusiveValidator("name")},
					},
					"name": schema.StringAttribute{
						Optional:   true,
						Computed:   true,
						Validators: []validator.String{NewMutuallyExclusiveValidator("id")},
					},
				},
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func nodeSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"services": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"id": schema.StringAttribute{
							Optional: true,
						},
					},
				},
			},
			"id": schema.StringAttribute{
				Optional: true,
			},
			"node": schema.StringAttribute{
				Optional: true,
			},
			"address": schema.StringAttribute{
				Optional: true,
			},
			"datacenter": schema.StringAttribute{
				Optional: true,
			},
			"tagged_addresses": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"partition": schema.StringAttribute{
				Optional: true,
			},
			"peer_name": schema.StringAttribute{
				Optional: true,
			},
			"locality": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"region": schema.StringAttribute{
						Optional: true,
					},
					"zone": schema.StringAttribute{
						Optional: true,
					},
				},
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func peeringSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"peering_token": schema.StringAttribute{
				Optional:  true,
				Sensitive: true,
			},
			"id": schema.StringAttribute{
				Optional: true,
			},
			"name": schema.StringAttribute{
				Optional: true,
			},
			"partition": schema.StringAttribute{
				Optional: true,
			},
			"deleted_at": schema.StringAttribute{
				Optional: true,
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"state": schema.StringAttribute{
				Optional: true,
			},
			"peer_id": schema.StringAttribute{
				Optional: true,
			},
			"peer_ca_pems": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"peer_server_name": schema.StringAttribute{
				Optional: true,
			},
			"peer_server_addresses": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"stream_status": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"imported_services": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"exported_services": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"last_heartbeat": schema.StringAttribute{
						Optional: true,
					},
					"last_receive": schema.StringAttribute{
						Optional: true,
					},
					"last_send": schema.StringAttribute{
						Optional: true,
					},
				},
			},
			"remote": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"partition": schema.StringAttribute{
						Optional: true,
					},
					"datacenter": schema.StringAttribute{
						Optional: true,
					},
					"locality": &schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"region": schema.StringAttribute{
								Optional: true,
							},
							"zone": schema.StringAttribute{
								Optional: true,
							},
						},
					},
				},
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func peeringTokenSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"peer_name": schema.StringAttribute{
				Optional: true,
			},
			"partition": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"server_external_addresses": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"peering_token": schema.StringAttribute{
				Computed: true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func preparedQueryDefinitionSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"name": schema.StringAttribute{
				Optional: true,
			},
			"session": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"token": schema.StringAttribute{
				Optional: true,
			},
			"service": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						Optional: true,
					},
					"sameness_group": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						MarkdownDescription: "This defaults to `\"\"`",
						Default:             stringdefault.StaticString(""),
					},
					"namespace": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						MarkdownDescription: "This defaults to `\"\"`",
						Default:             stringdefault.StaticString(""),
					},
					"partition": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						MarkdownDescription: "This defaults to `\"\"`",
						Default:             stringdefault.StaticString(""),
					},
					"near": schema.StringAttribute{
						Optional: true,
					},
					"failover": &schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"nearest_n": schema.Int64Attribute{
								Optional: true,
							},
							"datacenters": schema.ListAttribute{
								ElementType: types.StringType,
								Optional:    true,
							},
							"targets": &schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"peer": schema.StringAttribute{
											Optional: true,
										},
										"datacenter": schema.StringAttribute{
											Optional: true,
										},
										"partition": schema.StringAttribute{
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											Optional: true,
										},
									}},
							},
						},
					},
					"ignore_check_ids": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"only_passing": schema.BoolAttribute{
						Optional: true,
					},
					"tags": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"node_meta": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"service_meta": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"connect": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						MarkdownDescription: "This defaults to `false`",
						Default:             booldefault.StaticBool(false),
					},
				},
			},
			"dns": &schema.SingleNestedAttribute{
				Optional: true,
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"ttl": schema.StringAttribute{
						Optional: true,
					},
				},
			},
			"template": &schema.SingleNestedAttribute{
				Optional: true,
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"type": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						MarkdownDescription: "This defaults to `\"\"`",
						Default:             stringdefault.StaticString(""),
					},
					"regexp": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						MarkdownDescription: "This defaults to `\"\"`",
						Default:             stringdefault.StaticString(""),
					},
					"remove_empty_tags": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						MarkdownDescription: "This defaults to `false`",
						Default:             booldefault.StaticBool(false),
					},
				},
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func proxyConfigEntrySchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"name": schema.StringAttribute{
				Optional: true,
			},
			"partition": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"mode": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"transparent_proxy": &schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"outbound_listener_port": schema.Int64Attribute{
						Optional: true,
					},
					"dialed_directly": schema.BoolAttribute{
						Optional: true,
					},
				},
			},
			"mutual_tls_mode": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"config": schema.StringAttribute{
				Optional: true,
			},
			"mesh_gateway": &schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"mode": schema.StringAttribute{
						Optional: true,
					},
				},
			},
			"expose": &schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"checks": schema.BoolAttribute{
						Optional: true,
					},
					"paths": &schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"listener_port": schema.Int64Attribute{
									Optional: true,
								},
								"path": schema.StringAttribute{
									Optional: true,
								},
								"local_path_port": schema.Int64Attribute{
									Optional: true,
								},
								"protocol": schema.StringAttribute{
									Optional: true,
								},
								"parsed_from_check": schema.BoolAttribute{
									Optional: true,
								},
							}},
					},
				},
			},
			"access_logs": &schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional: true,
					},
					"disable_listener_logs": schema.BoolAttribute{
						Optional: true,
					},
					"type": schema.StringAttribute{
						Optional: true,
					},
					"path": schema.StringAttribute{
						Optional: true,
					},
					"json_format": schema.StringAttribute{
						Optional: true,
					},
					"text_format": schema.StringAttribute{
						Optional: true,
					},
				},
			},
			"envoy_extensions": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							Optional: true,
						},
						"required": schema.BoolAttribute{
							Optional: true,
						},
						"arguments": schema.StringAttribute{
							Optional: true,
						},
						"consul_version": schema.StringAttribute{
							Optional: true,
						},
						"envoy_version": schema.StringAttribute{
							Optional: true,
						},
					}},
			},
			"failover_policy": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"mode": schema.StringAttribute{
						Optional: true,
					},
					"regions": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
				},
			},
			"prioritize_by_locality": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"mode": schema.StringAttribute{
						Optional: true,
					},
				},
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func rateLimitIpConfigEntrySchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				Optional: true,
			},
			"mode": schema.StringAttribute{
				Optional: true,
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"read_rate": schema.Float64Attribute{
				Optional: true,
			},
			"write_rate": schema.Float64Attribute{
				Optional: true,
			},
			"acl": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"read_rate": schema.Float64Attribute{
						Optional: true,
					},
					"write_rate": schema.Float64Attribute{
						Optional: true,
					},
				},
			},
			"catalog": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"read_rate": schema.Float64Attribute{
						Optional: true,
					},
					"write_rate": schema.Float64Attribute{
						Optional: true,
					},
				},
			},
			"config_entry": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"read_rate": schema.Float64Attribute{
						Optional: true,
					},
					"write_rate": schema.Float64Attribute{
						Optional: true,
					},
				},
			},
			"connect_ca": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"read_rate": schema.Float64Attribute{
						Optional: true,
					},
					"write_rate": schema.Float64Attribute{
						Optional: true,
					},
				},
			},
			"coordinate": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"read_rate": schema.Float64Attribute{
						Optional: true,
					},
					"write_rate": schema.Float64Attribute{
						Optional: true,
					},
				},
			},
			"discovery_chain": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"read_rate": schema.Float64Attribute{
						Optional: true,
					},
					"write_rate": schema.Float64Attribute{
						Optional: true,
					},
				},
			},
			"server_discovery": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"read_rate": schema.Float64Attribute{
						Optional: true,
					},
					"write_rate": schema.Float64Attribute{
						Optional: true,
					},
				},
			},
			"health": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"read_rate": schema.Float64Attribute{
						Optional: true,
					},
					"write_rate": schema.Float64Attribute{
						Optional: true,
					},
				},
			},
			"intention": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"read_rate": schema.Float64Attribute{
						Optional: true,
					},
					"write_rate": schema.Float64Attribute{
						Optional: true,
					},
				},
			},
			"kv": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"read_rate": schema.Float64Attribute{
						Optional: true,
					},
					"write_rate": schema.Float64Attribute{
						Optional: true,
					},
				},
			},
			"tenancy": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"read_rate": schema.Float64Attribute{
						Optional: true,
					},
					"write_rate": schema.Float64Attribute{
						Optional: true,
					},
				},
			},
			"prepared_query": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"read_rate": schema.Float64Attribute{
						Optional: true,
					},
					"write_rate": schema.Float64Attribute{
						Optional: true,
					},
				},
			},
			"session": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"read_rate": schema.Float64Attribute{
						Optional: true,
					},
					"write_rate": schema.Float64Attribute{
						Optional: true,
					},
				},
			},
			"txn": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"read_rate": schema.Float64Attribute{
						Optional: true,
					},
					"write_rate": schema.Float64Attribute{
						Optional: true,
					},
				},
			},
			"auto_config": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"read_rate": schema.Float64Attribute{
						Optional: true,
					},
					"write_rate": schema.Float64Attribute{
						Optional: true,
					},
				},
			},
			"federation_state": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"read_rate": schema.Float64Attribute{
						Optional: true,
					},
					"write_rate": schema.Float64Attribute{
						Optional: true,
					},
				},
			},
			"internal": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"read_rate": schema.Float64Attribute{
						Optional: true,
					},
					"write_rate": schema.Float64Attribute{
						Optional: true,
					},
				},
			},
			"peer_stream": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"read_rate": schema.Float64Attribute{
						Optional: true,
					},
					"write_rate": schema.Float64Attribute{
						Optional: true,
					},
				},
			},
			"peering": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"read_rate": schema.Float64Attribute{
						Optional: true,
					},
					"write_rate": schema.Float64Attribute{
						Optional: true,
					},
				},
			},
			"data_plane": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"read_rate": schema.Float64Attribute{
						Optional: true,
					},
					"write_rate": schema.Float64Attribute{
						Optional: true,
					},
				},
			},
			"dns": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"read_rate": schema.Float64Attribute{
						Optional: true,
					},
					"write_rate": schema.Float64Attribute{
						Optional: true,
					},
				},
			},
			"subscribe": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"read_rate": schema.Float64Attribute{
						Optional: true,
					},
					"write_rate": schema.Float64Attribute{
						Optional: true,
					},
				},
			},
			"resource": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"read_rate": schema.Float64Attribute{
						Optional: true,
					},
					"write_rate": schema.Float64Attribute{
						Optional: true,
					},
				},
			},
			"partition": schema.StringAttribute{
				Optional: true,
			},
			"namespace": schema.StringAttribute{
				Optional: true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func samenessGroupConfigEntrySchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				Optional: true,
			},
			"partition": schema.StringAttribute{
				Optional: true,
			},
			"default_for_failover": schema.BoolAttribute{
				Optional: true,
			},
			"include_local": schema.BoolAttribute{
				Optional: true,
			},
			"members": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"partition": schema.StringAttribute{
							Optional: true,
						},
						"peer": schema.StringAttribute{
							Optional: true,
						},
					}},
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func serviceConfigEntrySchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"name": schema.StringAttribute{
				Optional: true,
			},
			"partition": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"protocol": schema.StringAttribute{
				Optional: true,
			},
			"mode": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"transparent_proxy": &schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"outbound_listener_port": schema.Int64Attribute{
						Optional: true,
					},
					"dialed_directly": schema.BoolAttribute{
						Optional: true,
					},
				},
			},
			"mutual_tls_mode": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"mesh_gateway": &schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"mode": schema.StringAttribute{
						Optional: true,
					},
				},
			},
			"expose": &schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"checks": schema.BoolAttribute{
						Optional: true,
					},
					"paths": &schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"listener_port": schema.Int64Attribute{
									Optional: true,
								},
								"path": schema.StringAttribute{
									Optional: true,
								},
								"local_path_port": schema.Int64Attribute{
									Optional: true,
								},
								"protocol": schema.StringAttribute{
									Optional: true,
								},
								"parsed_from_check": schema.BoolAttribute{
									Optional: true,
								},
							}},
					},
				},
			},
			"external_sni": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"upstream_config": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"overrides": &schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Optional: true,
								},
								"partition": schema.StringAttribute{
									Optional: true,
								},
								"namespace": schema.StringAttribute{
									Optional: true,
								},
								"peer": schema.StringAttribute{
									Optional: true,
								},
								"envoy_listener_json": schema.StringAttribute{
									Optional: true,
								},
								"envoy_cluster_json": schema.StringAttribute{
									Optional: true,
								},
								"protocol": schema.StringAttribute{
									Optional: true,
								},
								"connect_timeout_ms": schema.Int64Attribute{
									Optional: true,
								},
								"limits": &schema.SingleNestedAttribute{
									Optional: true,
									Attributes: map[string]schema.Attribute{
										"max_connections": schema.Int64Attribute{
											Optional: true,
										},
										"max_pending_requests": schema.Int64Attribute{
											Optional: true,
										},
										"max_concurrent_requests": schema.Int64Attribute{
											Optional: true,
										},
									},
								},
								"passive_health_check": &schema.SingleNestedAttribute{
									Optional: true,
									Attributes: map[string]schema.Attribute{
										"interval": schema.StringAttribute{
											Optional: true,
										},
										"max_failures": schema.Int64Attribute{
											Optional: true,
										},
										"enforcing_consecutive5xx": schema.Int64Attribute{
											Optional: true,
										},
										"max_ejection_percent": schema.Int64Attribute{
											Optional: true,
										},
										"base_ejection_time": schema.StringAttribute{
											Optional: true,
										},
									},
								},
								"mesh_gateway": &schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"mode": schema.StringAttribute{
											Optional: true,
										},
									},
								},
								"balance_outbound_connections": schema.StringAttribute{
									Optional: true,
								},
							}},
					},
					"defaults": &schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								Optional: true,
							},
							"partition": schema.StringAttribute{
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								Optional: true,
							},
							"peer": schema.StringAttribute{
								Optional: true,
							},
							"envoy_listener_json": schema.StringAttribute{
								Optional: true,
							},
							"envoy_cluster_json": schema.StringAttribute{
								Optional: true,
							},
							"protocol": schema.StringAttribute{
								Optional: true,
							},
							"connect_timeout_ms": schema.Int64Attribute{
								Optional: true,
							},
							"limits": &schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"max_connections": schema.Int64Attribute{
										Optional: true,
									},
									"max_pending_requests": schema.Int64Attribute{
										Optional: true,
									},
									"max_concurrent_requests": schema.Int64Attribute{
										Optional: true,
									},
								},
							},
							"passive_health_check": &schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"interval": schema.StringAttribute{
										Optional: true,
									},
									"max_failures": schema.Int64Attribute{
										Optional: true,
									},
									"enforcing_consecutive5xx": schema.Int64Attribute{
										Optional: true,
									},
									"max_ejection_percent": schema.Int64Attribute{
										Optional: true,
									},
									"base_ejection_time": schema.StringAttribute{
										Optional: true,
									},
								},
							},
							"mesh_gateway": &schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"mode": schema.StringAttribute{
										Optional: true,
									},
								},
							},
							"balance_outbound_connections": schema.StringAttribute{
								Optional: true,
							},
						},
					},
				},
			},
			"destination": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"addresses": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"port": schema.Int64Attribute{
						Optional: true,
					},
				},
			},
			"max_inbound_connections": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to 0",
				Default:             int64default.StaticInt64(0),
			},
			"local_connect_timeout_ms": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to 0",
				Default:             int64default.StaticInt64(0),
			},
			"local_request_timeout_ms": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to 0",
				Default:             int64default.StaticInt64(0),
			},
			"balance_inbound_connections": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"envoy_extensions": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							Optional: true,
						},
						"required": schema.BoolAttribute{
							Optional: true,
						},
						"arguments": schema.StringAttribute{
							Optional: true,
						},
						"consul_version": schema.StringAttribute{
							Optional: true,
						},
						"envoy_version": schema.StringAttribute{
							Optional: true,
						},
					}},
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func serviceIntentionsConfigEntrySchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				Optional: true,
			},
			"partition": schema.StringAttribute{
				Optional: true,
			},
			"namespace": schema.StringAttribute{
				Optional: true,
			},
			"sources": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							Optional: true,
						},
						"peer": schema.StringAttribute{
							Optional: true,
						},
						"partition": schema.StringAttribute{
							Optional: true,
						},
						"namespace": schema.StringAttribute{
							Optional: true,
						},
						"sameness_group": schema.StringAttribute{
							Optional: true,
						},
						"action": schema.StringAttribute{
							Optional: true,
						},
						"permissions": &schema.ListNestedAttribute{
							Optional: true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"action": schema.StringAttribute{
										Optional: true,
									},
									"http": &schema.SingleNestedAttribute{
										Optional:   true,
										Attributes: map[string]schema.Attribute{},
									},
									"jwt": &schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"providers": &schema.ListNestedAttribute{
												Optional: true,
												NestedObject: schema.NestedAttributeObject{
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															Optional: true,
														},
														"verify_claims": &schema.ListNestedAttribute{
															Optional: true,
															NestedObject: schema.NestedAttributeObject{
																Attributes: map[string]schema.Attribute{
																	"path": schema.ListAttribute{
																		ElementType: types.StringType,
																		Optional:    true,
																	},
																	"value": schema.StringAttribute{
																		Optional: true,
																	},
																}},
														},
													}},
											},
										},
									},
								}},
						},
						"precedence": schema.Int64Attribute{
							Optional: true,
						},
						"type": schema.StringAttribute{
							Optional: true,
						},
						"description": schema.StringAttribute{
							Optional: true,
						},
					}},
			},
			"jwt": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"providers": &schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Optional: true,
								},
								"verify_claims": &schema.ListNestedAttribute{
									Optional: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"path": schema.ListAttribute{
												ElementType: types.StringType,
												Optional:    true,
											},
											"value": schema.StringAttribute{
												Optional: true,
											},
										}},
								},
							}},
					},
				},
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func serviceResolverConfigEntrySchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				Optional: true,
			},
			"partition": schema.StringAttribute{
				Optional: true,
			},
			"namespace": schema.StringAttribute{
				Optional: true,
			},
			"default_subset": schema.StringAttribute{
				Optional: true,
			},
			"subsets": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{},
				},
			},
			"redirect": &schema.SingleNestedAttribute{
				Optional:   true,
				Attributes: map[string]schema.Attribute{},
			},
			"failover": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{},
				},
			},
			"connect_timeout": schema.StringAttribute{
				Optional: true,
			},
			"request_timeout": schema.StringAttribute{
				Optional: true,
			},
			"prioritize_by_locality": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"mode": schema.StringAttribute{
						Optional: true,
					},
				},
			},
			"load_balancer": &schema.SingleNestedAttribute{
				Optional:   true,
				Attributes: map[string]schema.Attribute{},
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func serviceRouterConfigEntrySchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed: true,
			},
			"name": schema.StringAttribute{
				Optional: true,
			},
			"partition": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "This defaults to `\"\"`",
				Default:             stringdefault.StaticString(""),
			},
			"routes": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"match": &schema.SingleNestedAttribute{
							Optional: true,
							Attributes: map[string]schema.Attribute{
								"http": &schema.SingleNestedAttribute{
									Optional: true,
									Attributes: map[string]schema.Attribute{
										"path_exact": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											MarkdownDescription: "This defaults to `\"\"`",
											Default:             stringdefault.StaticString(""),
										},
										"path_prefix": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											MarkdownDescription: "This defaults to `\"\"`",
											Default:             stringdefault.StaticString(""),
										},
										"path_regex": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											MarkdownDescription: "This defaults to `\"\"`",
											Default:             stringdefault.StaticString(""),
										},
										"header": &schema.ListNestedAttribute{
											Optional: true,
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														Optional: true,
													},
													"present": schema.BoolAttribute{
														Optional: true,
													},
													"exact": schema.StringAttribute{
														Optional: true,
													},
													"prefix": schema.StringAttribute{
														Optional: true,
													},
													"suffix": schema.StringAttribute{
														Optional: true,
													},
													"regex": schema.StringAttribute{
														Optional: true,
													},
													"invert": schema.BoolAttribute{
														Optional: true,
													},
												}},
										},
										"query_param": &schema.ListNestedAttribute{
											Optional: true,
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														Optional: true,
													},
													"present": schema.BoolAttribute{
														Optional: true,
													},
													"exact": schema.StringAttribute{
														Optional: true,
													},
													"regex": schema.StringAttribute{
														Optional: true,
													},
												}},
										},
										"methods": schema.ListAttribute{
											ElementType: types.StringType,
											Optional:    true,
										},
									},
								},
							},
						},
						"destination": &schema.SingleNestedAttribute{
							Optional: true,
							Attributes: map[string]schema.Attribute{
								"service": schema.StringAttribute{
									Optional: true,
								},
								"service_subset": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									MarkdownDescription: "This defaults to `\"\"`",
									Default:             stringdefault.StaticString(""),
								},
								"namespace": schema.StringAttribute{
									Optional: true,
								},
								"partition": schema.StringAttribute{
									Optional: true,
								},
								"prefix_rewrite": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									MarkdownDescription: "This defaults to `\"\"`",
									Default:             stringdefault.StaticString(""),
								},
								"request_timeout": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									MarkdownDescription: "This defaults to `\"0s\"`",
									Default:             stringdefault.StaticString("0s"),
								},
								"idle_timeout": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									MarkdownDescription: "This defaults to `\"0s\"`",
									Default:             stringdefault.StaticString("0s"),
								},
								"num_retries": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									MarkdownDescription: "This defaults to 0",
									Default:             int64default.StaticInt64(0),
								},
								"retry_on_connect_failure": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									MarkdownDescription: "This defaults to `false`",
									Default:             booldefault.StaticBool(false),
								},
								"retry_on_status_codes": schema.ListAttribute{
									ElementType: types.Int64Type,
									Optional:    true,
								},
								"retry_on": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
								},
								"request_headers": &schema.SingleNestedAttribute{
									Optional: true,
									Attributes: map[string]schema.Attribute{
										"add": schema.MapAttribute{
											ElementType: types.StringType,
											Optional:    true,
										},
										"set": schema.MapAttribute{
											ElementType: types.StringType,
											Optional:    true,
										},
										"remove": schema.ListAttribute{
											ElementType: types.StringType,
											Optional:    true,
										},
									},
								},
								"response_headers": &schema.SingleNestedAttribute{
									Optional: true,
									Attributes: map[string]schema.Attribute{
										"add": schema.MapAttribute{
											ElementType: types.StringType,
											Optional:    true,
										},
										"set": schema.MapAttribute{
											ElementType: types.StringType,
											Optional:    true,
										},
										"remove": schema.ListAttribute{
											ElementType: types.StringType,
											Optional:    true,
										},
									},
								},
							},
						},
					}},
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func serviceSplitterConfigEntrySchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				Optional: true,
			},
			"partition": schema.StringAttribute{
				Optional: true,
			},
			"namespace": schema.StringAttribute{
				Optional: true,
			},
			"splits": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"weight": schema.Float64Attribute{
							Optional: true,
						},
						"service": schema.StringAttribute{
							Optional: true,
						},
						"service_subset": schema.StringAttribute{
							Optional: true,
						},
						"namespace": schema.StringAttribute{
							Optional: true,
						},
						"partition": schema.StringAttribute{
							Optional: true,
						},
						"request_headers": &schema.SingleNestedAttribute{
							Optional: true,
							Attributes: map[string]schema.Attribute{
								"add": schema.MapAttribute{
									ElementType: types.StringType,
									Optional:    true,
								},
								"set": schema.MapAttribute{
									ElementType: types.StringType,
									Optional:    true,
								},
								"remove": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
								},
							},
						},
						"response_headers": &schema.SingleNestedAttribute{
							Optional: true,
							Attributes: map[string]schema.Attribute{
								"add": schema.MapAttribute{
									ElementType: types.StringType,
									Optional:    true,
								},
								"set": schema.MapAttribute{
									ElementType: types.StringType,
									Optional:    true,
								},
								"remove": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
								},
							},
						},
					}},
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func tcpRouteConfigEntrySchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				Optional: true,
			},
			"parents": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"kind": schema.StringAttribute{
							Optional: true,
						},
						"name": schema.StringAttribute{
							Optional: true,
						},
						"section_name": schema.StringAttribute{
							Optional: true,
						},
						"partition": schema.StringAttribute{
							Optional: true,
						},
						"namespace": schema.StringAttribute{
							Optional: true,
						},
					}},
			},
			"services": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							Optional: true,
						},
						"partition": schema.StringAttribute{
							Optional: true,
						},
						"namespace": schema.StringAttribute{
							Optional: true,
						},
					}},
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"status": &schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"conditions": &schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"type": schema.StringAttribute{
									Optional: true,
								},
								"status": schema.StringAttribute{
									Optional: true,
								},
								"reason": schema.StringAttribute{
									Optional: true,
								},
								"message": schema.StringAttribute{
									Optional: true,
								},
								"resource": &schema.SingleNestedAttribute{
									Optional: true,
									Attributes: map[string]schema.Attribute{
										"kind": schema.StringAttribute{
											Optional: true,
										},
										"name": schema.StringAttribute{
											Optional: true,
										},
										"section_name": schema.StringAttribute{
											Optional: true,
										},
										"partition": schema.StringAttribute{
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											Optional: true,
										},
									},
								},
								"last_transition_time": schema.StringAttribute{
									Optional: true,
								},
							}},
					},
				},
			},
			"partition": schema.StringAttribute{
				Optional: true,
			},
			"namespace": schema.StringAttribute{
				Optional: true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}

func terminatingGatewayConfigEntrySchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				Optional: true,
			},
			"services": &schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"namespace": schema.StringAttribute{
							Optional: true,
						},
						"name": schema.StringAttribute{
							Optional: true,
						},
						"ca_file": schema.StringAttribute{
							Optional: true,
						},
						"cert_file": schema.StringAttribute{
							Optional: true,
						},
						"key_file": schema.StringAttribute{
							Optional: true,
						},
						"sni": schema.StringAttribute{
							Optional: true,
						},
					}},
			},
			"meta": schema.MapAttribute{
				ElementType: types.StringType,
				Optional:    true,
			},
			"partition": schema.StringAttribute{
				Optional: true,
			},
			"namespace": schema.StringAttribute{
				Optional: true,
			},
		},
		Blocks: map[string]schema.Block{},
	}
}
