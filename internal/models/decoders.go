/*
Code generated by github-terraform-generator; DO NOT EDIT.
Any modifications will be overwritten
*/

package models

import (
	"context"
	"encoding/json"
	api "github.com/hashicorp/consul/api"
	diag "github.com/hashicorp/terraform-plugin-framework/diag"
	path "github.com/hashicorp/terraform-plugin-framework/path"
	structs "github.com/remilapeyre/terraform-provider-consul-next/internal/structs"
	"time"
)

type Getter interface {
	Get(context.Context, interface{}) diag.Diagnostics
}

func DecodeACLAuthMethod(ctx context.Context, getter Getter, aclAuthMethod **structs.ACLAuthMethod) diag.Diagnostics {
	var data *ACLAuthMethod
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeACLAuthMethod(path.Empty(), data, aclAuthMethod)...)
	return diags
}

func DecodeACLBindingRule(ctx context.Context, getter Getter, aclBindingRule **api.ACLBindingRule) diag.Diagnostics {
	var data *ACLBindingRule
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeACLBindingRule(path.Empty(), data, aclBindingRule)...)
	return diags
}

func DecodeACLPolicy(ctx context.Context, getter Getter, aclPolicy **api.ACLPolicy) diag.Diagnostics {
	var data *ACLPolicy
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeACLPolicy(path.Empty(), data, aclPolicy)...)
	return diags
}

func DecodeACLRole(ctx context.Context, getter Getter, aclRole **api.ACLRole) diag.Diagnostics {
	var data *ACLRole
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeACLRole(path.Empty(), data, aclRole)...)
	return diags
}

func DecodeACLToken(ctx context.Context, getter Getter, aclToken **structs.ACLToken) diag.Diagnostics {
	var data *ACLToken
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeACLToken(path.Empty(), data, aclToken)...)
	return diags
}

func DecodeACLTokenPolicyAttachment(ctx context.Context, getter Getter, aclTokenPolicyAttachment **structs.ACLTokenPolicyAttachment) diag.Diagnostics {
	var data *ACLTokenPolicyAttachment
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeACLTokenPolicyAttachment(path.Empty(), data, aclTokenPolicyAttachment)...)
	return diags
}

func DecodeACLTokenRoleAttachment(ctx context.Context, getter Getter, aclTokenRoleAttachment **structs.ACLTokenRoleAttachment) diag.Diagnostics {
	var data *ACLTokenRoleAttachment
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeACLTokenRoleAttachment(path.Empty(), data, aclTokenRoleAttachment)...)
	return diags
}

func DecodeACLTokenSecretID(ctx context.Context, getter Getter, aclTokenSecretId **structs.ACLTokenSecretID) diag.Diagnostics {
	var data *ACLTokenSecretID
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeACLTokenSecretID(path.Empty(), data, aclTokenSecretId)...)
	return diags
}

func DecodeAgentConfig(ctx context.Context, getter Getter, agentConfig **structs.AgentConfig) diag.Diagnostics {
	var data *AgentConfig
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeAgentConfig(path.Empty(), data, agentConfig)...)
	return diags
}

func DecodeArea(ctx context.Context, getter Getter, area **api.Area) diag.Diagnostics {
	var data *Area
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeArea(path.Empty(), data, area)...)
	return diags
}

func DecodeAutopilotConfig(ctx context.Context, getter Getter, autopilotConfig **structs.AutopilotConfig) diag.Diagnostics {
	var data *AutopilotConfig
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeAutopilotConfig(path.Empty(), data, autopilotConfig)...)
	return diags
}

func DecodeAutopilotHealth(ctx context.Context, getter Getter, autopilotHealth **structs.AutopilotHealth) diag.Diagnostics {
	var data *AutopilotHealth
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeAutopilotHealth(path.Empty(), data, autopilotHealth)...)
	return diags
}

func DecodeCAConfig(ctx context.Context, getter Getter, caConfig **structs.CAConfig) diag.Diagnostics {
	var data *CAConfig
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeCAConfig(path.Empty(), data, caConfig)...)
	return diags
}

func DecodeCatalogNode(ctx context.Context, getter Getter, catalogNode **api.CatalogNode) diag.Diagnostics {
	var data *CatalogNode
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeCatalogNode(path.Empty(), data, catalogNode)...)
	return diags
}

func DecodeCatalogService(ctx context.Context, getter Getter, catalogService **api.CatalogService) diag.Diagnostics {
	var data *CatalogService
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeCatalogService(path.Empty(), data, catalogService)...)
	return diags
}

func DecodeConfig(ctx context.Context, getter Getter, config **api.Config) diag.Diagnostics {
	var data *Config
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeConfig(path.Empty(), data, config)...)
	return diags
}

func DecodeConfigEntry(ctx context.Context, getter Getter, configEntry **structs.ConfigEntry) diag.Diagnostics {
	var data *ConfigEntry
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeConfigEntry(path.Empty(), data, configEntry)...)
	return diags
}

func DecodeDatacenters(ctx context.Context, getter Getter, datacenters **structs.Datacenters) diag.Diagnostics {
	var data *Datacenters
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeDatacenters(path.Empty(), data, datacenters)...)
	return diags
}

func DecodeKeyPrefix(ctx context.Context, getter Getter, keyPrefix **structs.KeyPrefix) diag.Diagnostics {
	var data *KeyPrefix
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeKeyPrefix(path.Empty(), data, keyPrefix)...)
	return diags
}

func DecodeKeys(ctx context.Context, getter Getter, keys **structs.Keys) diag.Diagnostics {
	var data *Keys
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeKeys(path.Empty(), data, keys)...)
	return diags
}

func DecodeNamespace(ctx context.Context, getter Getter, namespace **api.Namespace) diag.Diagnostics {
	var data *Namespace
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeNamespace(path.Empty(), data, namespace)...)
	return diags
}

func DecodeNamespacePolicyAttachment(ctx context.Context, getter Getter, namespacePolicyAttachment **structs.NamespacePolicyAttachment) diag.Diagnostics {
	var data *NamespacePolicyAttachment
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeNamespacePolicyAttachment(path.Empty(), data, namespacePolicyAttachment)...)
	return diags
}

func DecodeNamespaceRoleAttachment(ctx context.Context, getter Getter, namespaceRoleAttachment **structs.NamespaceRoleAttachment) diag.Diagnostics {
	var data *NamespaceRoleAttachment
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeNamespaceRoleAttachment(path.Empty(), data, namespaceRoleAttachment)...)
	return diags
}

func DecodeNetworkAreaMembers(ctx context.Context, getter Getter, networkAreaMembers **structs.NetworkAreaMembers) diag.Diagnostics {
	var data *NetworkAreaMembers
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeNetworkAreaMembers(path.Empty(), data, networkAreaMembers)...)
	return diags
}

func DecodeNetworkSegments(ctx context.Context, getter Getter, networkSegments **structs.NetworkSegments) diag.Diagnostics {
	var data *NetworkSegments
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeNetworkSegments(path.Empty(), data, networkSegments)...)
	return diags
}

func DecodeNodes(ctx context.Context, getter Getter, nodes **structs.Nodes) diag.Diagnostics {
	var data *Nodes
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeNodes(path.Empty(), data, nodes)...)
	return diags
}

func DecodeOperatorHealthReply(ctx context.Context, getter Getter, operatorHealthReply **api.OperatorHealthReply) diag.Diagnostics {
	var data *OperatorHealthReply
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeOperatorHealthReply(path.Empty(), data, operatorHealthReply)...)
	return diags
}

func DecodePartition(ctx context.Context, getter Getter, partition **api.Partition) diag.Diagnostics {
	var data *Partition
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodePartition(path.Empty(), data, partition)...)
	return diags
}

func DecodePeering(ctx context.Context, getter Getter, peering **api.Peering) diag.Diagnostics {
	var data *Peering
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodePeering(path.Empty(), data, peering)...)
	return diags
}

func DecodePeeringResource(ctx context.Context, getter Getter, peeringResource **structs.PeeringResource) diag.Diagnostics {
	var data *PeeringResource
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodePeeringResource(path.Empty(), data, peeringResource)...)
	return diags
}

func DecodePeeringToken(ctx context.Context, getter Getter, peeringToken **structs.PeeringToken) diag.Diagnostics {
	var data *PeeringToken
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodePeeringToken(path.Empty(), data, peeringToken)...)
	return diags
}

func DecodePeerings(ctx context.Context, getter Getter, peerings **structs.Peerings) diag.Diagnostics {
	var data *Peerings
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodePeerings(path.Empty(), data, peerings)...)
	return diags
}

func DecodePreparedQueryDefinition(ctx context.Context, getter Getter, preparedQueryDefinition **api.PreparedQueryDefinition) diag.Diagnostics {
	var data *PreparedQueryDefinition
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodePreparedQueryDefinition(path.Empty(), data, preparedQueryDefinition)...)
	return diags
}

func DecodeServiceHealth(ctx context.Context, getter Getter, serviceHealth **structs.ServiceHealth) diag.Diagnostics {
	var data *ServiceHealth
	diags := getter.Get(ctx, &data)
	if diags.HasError() {
		return diags
	}

	diags.Append(decodeServiceHealth(path.Empty(), data, serviceHealth)...)
	return diags
}

func decodeACLAuthMethod(path path.Path, data *ACLAuthMethod, aclAuthMethod **structs.ACLAuthMethod) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &structs.ACLAuthMethod{}
	if *aclAuthMethod == nil {
		*aclAuthMethod = target
	} else {
		target = *aclAuthMethod
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if !data.Name.IsNull() {
		target.Method.Name = data.Name.ValueString()
	}

	if !data.Type.IsNull() {
		target.Method.Type = data.Type.ValueString()
	}

	if !data.DisplayName.IsNull() {
		target.Method.DisplayName = data.DisplayName.ValueString()
	}

	if !data.Description.IsNull() {
		target.Method.Description = data.Description.ValueString()
	}

	if !data.MaxTokenTTL.IsNull() {
		dur, err := time.ParseDuration(data.MaxTokenTTL.ValueString())
		if err != nil {
			diags.Append(diag.NewAttributeErrorDiagnostic(path.AtName("max_token_ttl"), "failed to parse duration", err.Error()))
		}
		target.Method.MaxTokenTTL = dur
	}

	if !data.TokenLocality.IsNull() {
		target.Method.TokenLocality = data.TokenLocality.ValueString()
	}

	if !data.Config.IsNull() {
		var m map[string]interface{}
		if err := json.Unmarshal([]byte(data.Config.ValueString()), &m); err != nil {
			diags.AddAttributeError(path.AtName("config"), "failed to unmarshal json", err.Error())
			return
		}
		target.Method.Config = m
	}

	if data.NamespaceRules != nil {
		target.Method.NamespaceRules = make([]*api.ACLAuthMethodNamespaceRule, len(data.NamespaceRules))
		for i, data := range data.NamespaceRules {
			if data != nil {
				var item *api.ACLAuthMethodNamespaceRule
				diags.Append(decodeACLAuthMethodNamespaceRule(path.AtName("namespace_rules").AtListIndex(i), data, &item)...)

				if diags.HasError() {
					return diags
				}

				target.Method.NamespaceRules[i] = item
			}
		}
	}

	if !data.Namespace.IsNull() {
		target.Method.Namespace = data.Namespace.ValueString()
	}

	if !data.Partition.IsNull() {
		target.Method.Partition = data.Partition.ValueString()
	}

	return diags
}

func decodeACLBindingRule(path path.Path, data *ACLBindingRule, aclBindingRule **api.ACLBindingRule) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.ACLBindingRule{}
	if *aclBindingRule == nil {
		*aclBindingRule = target
	} else {
		target = *aclBindingRule
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if !data.Description.IsNull() {
		target.Description = data.Description.ValueString()
	}

	if !data.AuthMethod.IsNull() {
		target.AuthMethod = data.AuthMethod.ValueString()
	}

	if !data.Selector.IsNull() {
		target.Selector = data.Selector.ValueString()
	}

	if !data.BindType.IsNull() {
		target.BindType = api.BindingRuleBindType(data.BindType.ValueString())
	}

	if !data.BindName.IsNull() {
		target.BindName = data.BindName.ValueString()
	}

	if !data.Namespace.IsNull() {
		target.Namespace = data.Namespace.ValueString()
	}

	if !data.Partition.IsNull() {
		target.Partition = data.Partition.ValueString()
	}

	return diags
}

func decodeACLPolicy(path path.Path, data *ACLPolicy, aclPolicy **api.ACLPolicy) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.ACLPolicy{}
	if *aclPolicy == nil {
		*aclPolicy = target
	} else {
		target = *aclPolicy
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if !data.Name.IsNull() {
		target.Name = data.Name.ValueString()
	}

	if !data.Description.IsNull() {
		target.Description = data.Description.ValueString()
	}

	if !data.Rules.IsNull() {
		target.Rules = data.Rules.ValueString()
	}

	if data.Datacenters != nil {
		target.Datacenters = make([]string, len(data.Datacenters))
		for i, data := range data.Datacenters {
			if !data.IsNull() {
				target.Datacenters[i] = data.ValueString()
			}
		}
	}

	if !data.Namespace.IsNull() {
		target.Namespace = data.Namespace.ValueString()
	}

	if !data.Partition.IsNull() {
		target.Partition = data.Partition.ValueString()
	}

	return diags
}

func decodeACLRole(path path.Path, data *ACLRole, aclRole **api.ACLRole) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.ACLRole{}
	if *aclRole == nil {
		*aclRole = target
	} else {
		target = *aclRole
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if !data.Name.IsNull() {
		target.Name = data.Name.ValueString()
	}

	if !data.Description.IsNull() {
		target.Description = data.Description.ValueString()
	}

	if data.Policies != nil {
		target.Policies = make([]*api.ACLLink, len(data.Policies))
		for i, data := range data.Policies {
			if data != nil {
				var item *api.ACLLink
				diags.Append(decodeACLLink(path.AtName("policies").AtListIndex(i), data, &item)...)

				if diags.HasError() {
					return diags
				}

				target.Policies[i] = item
			}
		}
	}

	if data.ServiceIdentities != nil {
		target.ServiceIdentities = make([]*api.ACLServiceIdentity, len(data.ServiceIdentities))
		for i, data := range data.ServiceIdentities {
			if data != nil {
				var item *api.ACLServiceIdentity
				diags.Append(decodeACLServiceIdentity(path.AtName("service_identities").AtListIndex(i), data, &item)...)

				if diags.HasError() {
					return diags
				}

				target.ServiceIdentities[i] = item
			}
		}
	}

	if data.NodeIdentities != nil {
		target.NodeIdentities = make([]*api.ACLNodeIdentity, len(data.NodeIdentities))
		for i, data := range data.NodeIdentities {
			if data != nil {
				var item *api.ACLNodeIdentity
				diags.Append(decodeACLNodeIdentity(path.AtName("node_identities").AtListIndex(i), data, &item)...)

				if diags.HasError() {
					return diags
				}

				target.NodeIdentities[i] = item
			}
		}
	}

	if !data.Namespace.IsNull() {
		target.Namespace = data.Namespace.ValueString()
	}

	if !data.Partition.IsNull() {
		target.Partition = data.Partition.ValueString()
	}

	return diags
}

func decodeACLToken(path path.Path, data *ACLToken, aclToken **structs.ACLToken) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &structs.ACLToken{}
	if *aclToken == nil {
		*aclToken = target
	} else {
		target = *aclToken
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if !data.AccessorID.IsNull() {
		target.Token.AccessorID = data.AccessorID.ValueString()
	}

	if !data.Description.IsNull() {
		target.Token.Description = data.Description.ValueString()
	}

	if data.Policies != nil {
		target.Token.Policies = make([]*api.ACLLink, len(data.Policies))
		for i, data := range data.Policies {
			if data != nil {
				var item *api.ACLLink
				diags.Append(decodeACLLink(path.AtName("policies").AtListIndex(i), data, &item)...)

				if diags.HasError() {
					return diags
				}

				target.Token.Policies[i] = item
			}
		}
	}

	if data.Roles != nil {
		target.Token.Roles = make([]*api.ACLLink, len(data.Roles))
		for i, data := range data.Roles {
			if data != nil {
				var item *api.ACLLink
				diags.Append(decodeACLLink(path.AtName("roles").AtListIndex(i), data, &item)...)

				if diags.HasError() {
					return diags
				}

				target.Token.Roles[i] = item
			}
		}
	}

	if data.ServiceIdentities != nil {
		target.Token.ServiceIdentities = make([]*api.ACLServiceIdentity, len(data.ServiceIdentities))
		for i, data := range data.ServiceIdentities {
			if data != nil {
				var item *api.ACLServiceIdentity
				diags.Append(decodeACLServiceIdentity(path.AtName("service_identities").AtListIndex(i), data, &item)...)

				if diags.HasError() {
					return diags
				}

				target.Token.ServiceIdentities[i] = item
			}
		}
	}

	if data.NodeIdentities != nil {
		target.Token.NodeIdentities = make([]*api.ACLNodeIdentity, len(data.NodeIdentities))
		for i, data := range data.NodeIdentities {
			if data != nil {
				var item *api.ACLNodeIdentity
				diags.Append(decodeACLNodeIdentity(path.AtName("node_identities").AtListIndex(i), data, &item)...)

				if diags.HasError() {
					return diags
				}

				target.Token.NodeIdentities[i] = item
			}
		}
	}

	if !data.Local.IsNull() {
		target.Token.Local = data.Local.ValueBool()
	}

	if !data.AuthMethod.IsNull() {
		target.Token.AuthMethod = data.AuthMethod.ValueString()
	}

	if !data.ExpirationTTL.IsNull() {
		dur, err := time.ParseDuration(data.ExpirationTTL.ValueString())
		if err != nil {
			diags.Append(diag.NewAttributeErrorDiagnostic(path.AtName("expiration_ttl"), "failed to parse duration", err.Error()))
		}
		target.Token.ExpirationTTL = dur
	}

	if !data.ExpirationTime.IsNull() {
		t, err := time.Parse(time.RFC3339, data.ExpirationTime.ValueString())
		if err != nil {
			diags.Append(diag.NewAttributeErrorDiagnostic(path.AtName("expiration_time"), "failed to parse time string", err.Error()))
		}
		target.Token.ExpirationTime = &t
	}

	if !data.CreateTime.IsNull() {
		t, err := time.Parse(time.RFC3339, data.CreateTime.ValueString())
		if err != nil {
			diags.Append(diag.NewAttributeErrorDiagnostic(path.AtName("create_time"), "failed to parse time string", err.Error()))
		}
		target.Token.CreateTime = t
	}

	if !data.Namespace.IsNull() {
		target.Token.Namespace = data.Namespace.ValueString()
	}

	if !data.Partition.IsNull() {
		target.Token.Partition = data.Partition.ValueString()
	}

	if !data.AuthMethodNamespace.IsNull() {
		target.Token.AuthMethodNamespace = data.AuthMethodNamespace.ValueString()
	}

	return diags
}

func decodeACLTokenPolicyAttachment(path path.Path, data *ACLTokenPolicyAttachment, aclTokenPolicyAttachment **structs.ACLTokenPolicyAttachment) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &structs.ACLTokenPolicyAttachment{}
	if *aclTokenPolicyAttachment == nil {
		*aclTokenPolicyAttachment = target
	} else {
		target = *aclTokenPolicyAttachment
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if !data.TokenID.IsNull() {
		target.TokenID = data.TokenID.ValueString()
	}

	if data.Policy != nil {
		var item *api.ACLLink
		diags.Append(decodeACLLink(path.AtName("policy"), data.Policy, &item)...)

		if diags.HasError() {
			return diags
		}

		target.Policy = *item
	}

	return diags
}

func decodeACLTokenRoleAttachment(path path.Path, data *ACLTokenRoleAttachment, aclTokenRoleAttachment **structs.ACLTokenRoleAttachment) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &structs.ACLTokenRoleAttachment{}
	if *aclTokenRoleAttachment == nil {
		*aclTokenRoleAttachment = target
	} else {
		target = *aclTokenRoleAttachment
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if !data.TokenID.IsNull() {
		target.TokenID = data.TokenID.ValueString()
	}

	if data.Role != nil {
		var item *api.ACLLink
		diags.Append(decodeACLLink(path.AtName("role"), data.Role, &item)...)

		if diags.HasError() {
			return diags
		}

		target.Role = *item
	}

	return diags
}

func decodeACLTokenSecretID(path path.Path, data *ACLTokenSecretID, aclTokenSecretId **structs.ACLTokenSecretID) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &structs.ACLTokenSecretID{}
	if *aclTokenSecretId == nil {
		*aclTokenSecretId = target
	} else {
		target = *aclTokenSecretId
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if !data.AccessorID.IsNull() {
		target.AccessorID = data.AccessorID.ValueString()
	}

	if !data.SecretID.IsNull() {
		target.SecretID = data.SecretID.ValueString()
	}

	if !data.Partition.IsNull() {
		target.Partition = data.Partition.ValueString()
	}

	if !data.Namespace.IsNull() {
		target.Namespace = data.Namespace.ValueString()
	}

	if !data.PGPKey.IsNull() {
		target.PGPKey = data.PGPKey.ValueString()
	}

	return diags
}

func decodeAgentConfig(path path.Path, data *AgentConfig, agentConfig **structs.AgentConfig) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &structs.AgentConfig{}
	if *agentConfig == nil {
		*agentConfig = target
	} else {
		target = *agentConfig
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if !data.Datacenter.IsNull() {
		target.Datacenter = data.Datacenter.ValueString()
	}

	if !data.PrimaryDatacenter.IsNull() {
		target.PrimaryDatacenter = data.PrimaryDatacenter.ValueString()
	}

	if !data.NodeName.IsNull() {
		target.NodeName = data.NodeName.ValueString()
	}

	if !data.NodeID.IsNull() {
		target.NodeID = data.NodeID.ValueString()
	}

	if !data.Partition.IsNull() {
		target.Partition = data.Partition.ValueStringPointer()
	}

	if !data.Revision.IsNull() {
		target.Revision = data.Revision.ValueString()
	}

	if !data.Server.IsNull() {
		target.Server = data.Server.ValueBool()
	}

	if !data.Version.IsNull() {
		target.Version = data.Version.ValueString()
	}

	if !data.BuildDate.IsNull() {
		target.BuildDate = data.BuildDate.ValueString()
	}

	return diags
}

func decodeArea(path path.Path, data *Area, area **api.Area) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.Area{}
	if *area == nil {
		*area = target
	} else {
		target = *area
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if !data.PeerDatacenter.IsNull() {
		target.PeerDatacenter = data.PeerDatacenter.ValueString()
	}

	if data.RetryJoin != nil {
		target.RetryJoin = make([]string, len(data.RetryJoin))
		for i, data := range data.RetryJoin {
			if !data.IsNull() {
				target.RetryJoin[i] = data.ValueString()
			}
		}
	}

	if !data.UseTLS.IsNull() {
		target.UseTLS = data.UseTLS.ValueBool()
	}

	return diags
}

func decodeAutopilotConfig(path path.Path, data *AutopilotConfig, autopilotConfig **structs.AutopilotConfig) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &structs.AutopilotConfig{}
	if *autopilotConfig == nil {
		*autopilotConfig = target
	} else {
		target = *autopilotConfig
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if !data.CleanupDeadServers.IsNull() {
		target.Config.CleanupDeadServers = data.CleanupDeadServers.ValueBool()
	}

	if !data.MaxTrailingLogs.IsNull() {
		i := uint64(data.MaxTrailingLogs.ValueInt64())
		target.Config.MaxTrailingLogs = i
	}

	if !data.MinQuorum.IsNull() {
		i := uint(data.MinQuorum.ValueInt64())
		target.Config.MinQuorum = i
	}

	if !data.RedundancyZoneTag.IsNull() {
		target.Config.RedundancyZoneTag = data.RedundancyZoneTag.ValueString()
	}

	if !data.DisableUpgradeMigration.IsNull() {
		target.Config.DisableUpgradeMigration = data.DisableUpgradeMigration.ValueBool()
	}

	if !data.UpgradeVersionTag.IsNull() {
		target.Config.UpgradeVersionTag = data.UpgradeVersionTag.ValueString()
	}

	return diags
}

func decodeAutopilotHealth(path path.Path, data *AutopilotHealth, autopilotHealth **structs.AutopilotHealth) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &structs.AutopilotHealth{}
	if *autopilotHealth == nil {
		*autopilotHealth = target
	} else {
		target = *autopilotHealth
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if !data.Healthy.IsNull() {
		target.AutopilotHealth.Healthy = data.Healthy.ValueBool()
	}

	if !data.FailureTolerance.IsNull() {
		i := int(data.FailureTolerance.ValueInt64())
		target.AutopilotHealth.FailureTolerance = i
	}

	if data.Servers != nil {
		target.AutopilotHealth.Servers = make([]api.ServerHealth, len(data.Servers))
		for i, data := range data.Servers {
			if data != nil {
				var item *api.ServerHealth
				diags.Append(decodeServerHealth(path.AtName("servers").AtListIndex(i), data, &item)...)

				if diags.HasError() {
					return diags
				}

				target.AutopilotHealth.Servers[i] = *item
			}
		}
	}

	return diags
}

func decodeCAConfig(path path.Path, data *CAConfig, caConfig **structs.CAConfig) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &structs.CAConfig{}
	if *caConfig == nil {
		*caConfig = target
	} else {
		target = *caConfig
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if !data.Provider.IsNull() {
		target.Config.Provider = data.Provider.ValueString()
	}

	if !data.Config.IsNull() {
		var m map[string]interface{}
		if err := json.Unmarshal([]byte(data.Config.ValueString()), &m); err != nil {
			diags.AddAttributeError(path.AtName("config"), "failed to unmarshal json", err.Error())
			return
		}
		target.Config.Config = m
	}

	if data.State != nil {
		target.Config.State = map[string]string{}
		for key, data := range data.State {
			if !data.IsNull() {
				target.Config.State[key] = data.ValueString()
			}
		}
	}

	if !data.ForceWithoutCrossSigning.IsNull() {
		target.Config.ForceWithoutCrossSigning = data.ForceWithoutCrossSigning.ValueBool()
	}

	return diags
}

func decodeCatalogNode(path path.Path, data *CatalogNode, catalogNode **api.CatalogNode) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.CatalogNode{}
	if *catalogNode == nil {
		*catalogNode = target
	} else {
		target = *catalogNode
	}

	if data.Services != nil {
		target.Services = map[string]*api.AgentService{}
		for key, data := range data.Services {
			if data != nil {
				var item *api.AgentService
				diags.Append(decodeAgentService(path.AtName("services").AtMapKey(key), data, &item)...)

				if diags.HasError() {
					return diags
				}

				target.Services[key] = item
			}
		}
	}

	if !data.ID.IsNull() {
		target.Node.ID = data.ID.ValueString()
	}

	if !data.Node.IsNull() {
		target.Node.Node = data.Node.ValueString()
	}

	if !data.Address.IsNull() {
		target.Node.Address = data.Address.ValueString()
	}

	if !data.Datacenter.IsNull() {
		target.Node.Datacenter = data.Datacenter.ValueString()
	}

	if data.TaggedAddresses != nil {
		target.Node.TaggedAddresses = map[string]string{}
		for key, data := range data.TaggedAddresses {
			if !data.IsNull() {
				target.Node.TaggedAddresses[key] = data.ValueString()
			}
		}
	}

	if data.Meta != nil {
		target.Node.Meta = map[string]string{}
		for key, data := range data.Meta {
			if !data.IsNull() {
				target.Node.Meta[key] = data.ValueString()
			}
		}
	}

	if !data.Partition.IsNull() {
		target.Node.Partition = data.Partition.ValueString()
	}

	if !data.PeerName.IsNull() {
		target.Node.PeerName = data.PeerName.ValueString()
	}

	if data.Locality != nil {
		var item *api.Locality
		diags.Append(decodeLocality(path.AtName("locality"), data.Locality, &item)...)

		if diags.HasError() {
			return diags
		}

		target.Node.Locality = item
	}

	return diags
}

func decodeCatalogService(path path.Path, data *CatalogService, catalogService **api.CatalogService) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.CatalogService{}
	if *catalogService == nil {
		*catalogService = target
	} else {
		target = *catalogService
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if !data.Node.IsNull() {
		target.Node = data.Node.ValueString()
	}

	if !data.Address.IsNull() {
		target.Address = data.Address.ValueString()
	}

	if !data.Datacenter.IsNull() {
		target.Datacenter = data.Datacenter.ValueString()
	}

	if data.TaggedAddresses != nil {
		target.TaggedAddresses = map[string]string{}
		for key, data := range data.TaggedAddresses {
			if !data.IsNull() {
				target.TaggedAddresses[key] = data.ValueString()
			}
		}
	}

	if data.NodeMeta != nil {
		target.NodeMeta = map[string]string{}
		for key, data := range data.NodeMeta {
			if !data.IsNull() {
				target.NodeMeta[key] = data.ValueString()
			}
		}
	}

	if !data.ServiceID.IsNull() {
		target.ServiceID = data.ServiceID.ValueString()
	}

	if !data.ServiceName.IsNull() {
		target.ServiceName = data.ServiceName.ValueString()
	}

	if !data.ServiceAddress.IsNull() {
		target.ServiceAddress = data.ServiceAddress.ValueString()
	}

	if data.ServiceTaggedAddresses != nil {
		target.ServiceTaggedAddresses = map[string]api.ServiceAddress{}
		for key, data := range data.ServiceTaggedAddresses {
			if data != nil {
				var item *api.ServiceAddress
				diags.Append(decodeServiceAddress(path.AtName("service_tagged_addresses").AtMapKey(key), data, &item)...)

				if diags.HasError() {
					return diags
				}

				target.ServiceTaggedAddresses[key] = *item
			}
		}
	}

	if data.ServiceTags != nil {
		target.ServiceTags = make([]string, len(data.ServiceTags))
		for i, data := range data.ServiceTags {
			if !data.IsNull() {
				target.ServiceTags[i] = data.ValueString()
			}
		}
	}

	if data.ServiceMeta != nil {
		target.ServiceMeta = map[string]string{}
		for key, data := range data.ServiceMeta {
			if !data.IsNull() {
				target.ServiceMeta[key] = data.ValueString()
			}
		}
	}

	if !data.ServicePort.IsNull() {
		i := int(data.ServicePort.ValueInt64())
		target.ServicePort = i
	}

	if data.ServiceWeights != nil {
		var item *api.Weights
		diags.Append(decodeWeights(path.AtName("service_weights"), data.ServiceWeights, &item)...)

		if diags.HasError() {
			return diags
		}

		target.ServiceWeights = *item
	}

	if !data.ServiceEnableTagOverride.IsNull() {
		target.ServiceEnableTagOverride = data.ServiceEnableTagOverride.ValueBool()
	}

	if data.ServiceProxy != nil {
		var item *api.AgentServiceConnectProxyConfig
		diags.Append(decodeAgentServiceConnectProxyConfig(path.AtName("service_proxy"), data.ServiceProxy, &item)...)

		if diags.HasError() {
			return diags
		}

		target.ServiceProxy = item
	}

	if data.ServiceLocality != nil {
		var item *api.Locality
		diags.Append(decodeLocality(path.AtName("service_locality"), data.ServiceLocality, &item)...)

		if diags.HasError() {
			return diags
		}

		target.ServiceLocality = item
	}

	if !data.CreateIndex.IsNull() {
		i := uint64(data.CreateIndex.ValueInt64())
		target.CreateIndex = i
	}

	if data.Checks != nil {
		target.Checks = make([]*api.HealthCheck, len(data.Checks))
		for i, data := range data.Checks {
			if data != nil {
				var item *api.HealthCheck
				diags.Append(decodeHealthCheck(path.AtName("checks").AtListIndex(i), data, &item)...)

				if diags.HasError() {
					return diags
				}

				target.Checks[i] = item
			}
		}
	}

	if !data.ModifyIndex.IsNull() {
		i := uint64(data.ModifyIndex.ValueInt64())
		target.ModifyIndex = i
	}

	if !data.Namespace.IsNull() {
		target.Namespace = data.Namespace.ValueString()
	}

	if !data.Partition.IsNull() {
		target.Partition = data.Partition.ValueString()
	}

	return diags
}

func decodeConfig(path path.Path, data *Config, config **api.Config) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.Config{}
	if *config == nil {
		*config = target
	} else {
		target = *config
	}

	if !data.Address.IsNull() {
		target.Address = data.Address.ValueString()
	}

	if !data.Scheme.IsNull() {
		target.Scheme = data.Scheme.ValueString()
	}

	if !data.PathPrefix.IsNull() {
		target.PathPrefix = data.PathPrefix.ValueString()
	}

	if !data.Datacenter.IsNull() {
		target.Datacenter = data.Datacenter.ValueString()
	}

	if data.HttpAuth != nil {
		var item *api.HttpBasicAuth
		diags.Append(decodeHttpBasicAuth(path.AtName("http_auth"), data.HttpAuth, &item)...)

		if diags.HasError() {
			return diags
		}

		target.HttpAuth = item
	}

	if !data.Token.IsNull() {
		target.Token = data.Token.ValueString()
	}

	if !data.TokenFile.IsNull() {
		target.TokenFile = data.TokenFile.ValueString()
	}

	if !data.Namespace.IsNull() {
		target.Namespace = data.Namespace.ValueString()
	}

	if !data.Partition.IsNull() {
		target.Partition = data.Partition.ValueString()
	}

	if data.TLSConfig != nil {
		var item *api.TLSConfig
		diags.Append(decodeTLSConfig(path.AtName("tls_config"), data.TLSConfig, &item)...)

		if diags.HasError() {
			return diags
		}

		target.TLSConfig = *item
	}

	return diags
}

func decodeConfigEntry(path path.Path, data *ConfigEntry, configEntry **structs.ConfigEntry) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &structs.ConfigEntry{}
	if *configEntry == nil {
		*configEntry = target
	} else {
		target = *configEntry
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if !data.Kind.IsNull() {
		target.Kind = data.Kind.ValueString()
	}

	if !data.Name.IsNull() {
		target.Name = data.Name.ValueString()
	}

	if !data.Namespace.IsNull() {
		target.Namespace = data.Namespace.ValueString()
	}

	if !data.Partition.IsNull() {
		target.Partition = data.Partition.ValueString()
	}

	if !data.Config.IsNull() {
		var m map[string]interface{}
		if err := json.Unmarshal([]byte(data.Config.ValueString()), &m); err != nil {
			diags.AddAttributeError(path.AtName("config"), "failed to unmarshal json", err.Error())
			return
		}
		target.Config = m
	}

	if data.Meta != nil {
		target.Meta = map[string]string{}
		for key, data := range data.Meta {
			if !data.IsNull() {
				target.Meta[key] = data.ValueString()
			}
		}
	}

	return diags
}

func decodeDatacenters(path path.Path, data *Datacenters, datacenters **structs.Datacenters) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &structs.Datacenters{}
	if *datacenters == nil {
		*datacenters = target
	} else {
		target = *datacenters
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if data.Datacenters != nil {
		target.Datacenters = make([]string, len(data.Datacenters))
		for i, data := range data.Datacenters {
			if !data.IsNull() {
				target.Datacenters[i] = data.ValueString()
			}
		}
	}

	return diags
}

func decodeKeyPrefix(path path.Path, data *KeyPrefix, keyPrefix **structs.KeyPrefix) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &structs.KeyPrefix{}
	if *keyPrefix == nil {
		*keyPrefix = target
	} else {
		target = *keyPrefix
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	return diags
}

func decodeKeys(path path.Path, data *Keys, keys **structs.Keys) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &structs.Keys{}
	if *keys == nil {
		*keys = target
	} else {
		target = *keys
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if data.Keys != nil {
		target.Keys = make([]*api.KVPair, len(data.Keys))
		for i, data := range data.Keys {
			if data != nil {
				var item *api.KVPair
				diags.Append(decodeKVPair(path.AtName("keys").AtListIndex(i), data, &item)...)

				if diags.HasError() {
					return diags
				}

				target.Keys[i] = item
			}
		}
	}

	return diags
}

func decodeNamespace(path path.Path, data *Namespace, namespace **api.Namespace) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.Namespace{}
	if *namespace == nil {
		*namespace = target
	} else {
		target = *namespace
	}

	if !data.Name.IsNull() {
		target.Name = data.Name.ValueString()
	}

	if !data.Description.IsNull() {
		target.Description = data.Description.ValueString()
	}

	if data.ACLs != nil {
		var item *api.NamespaceACLConfig
		diags.Append(decodeNamespaceACLConfig(path.AtName("ac_ls"), data.ACLs, &item)...)

		if diags.HasError() {
			return diags
		}

		target.ACLs = item
	}

	if data.Meta != nil {
		target.Meta = map[string]string{}
		for key, data := range data.Meta {
			if !data.IsNull() {
				target.Meta[key] = data.ValueString()
			}
		}
	}

	if !data.DeletedAt.IsNull() {
		t, err := time.Parse(time.RFC3339, data.DeletedAt.ValueString())
		if err != nil {
			diags.Append(diag.NewAttributeErrorDiagnostic(path.AtName("deleted_at"), "failed to parse time string", err.Error()))
		}
		target.DeletedAt = &t
	}

	if !data.Partition.IsNull() {
		target.Partition = data.Partition.ValueString()
	}

	return diags
}

func decodeNamespacePolicyAttachment(path path.Path, data *NamespacePolicyAttachment, namespacePolicyAttachment **structs.NamespacePolicyAttachment) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &structs.NamespacePolicyAttachment{}
	if *namespacePolicyAttachment == nil {
		*namespacePolicyAttachment = target
	} else {
		target = *namespacePolicyAttachment
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if !data.Namespace.IsNull() {
		target.Namespace = data.Namespace.ValueString()
	}

	if data.Policy != nil {
		var item *api.ACLLink
		diags.Append(decodeACLLink(path.AtName("policy"), data.Policy, &item)...)

		if diags.HasError() {
			return diags
		}

		target.Policy = *item
	}

	return diags
}

func decodeNamespaceRoleAttachment(path path.Path, data *NamespaceRoleAttachment, namespaceRoleAttachment **structs.NamespaceRoleAttachment) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &structs.NamespaceRoleAttachment{}
	if *namespaceRoleAttachment == nil {
		*namespaceRoleAttachment = target
	} else {
		target = *namespaceRoleAttachment
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if !data.Namespace.IsNull() {
		target.Namespace = data.Namespace.ValueString()
	}

	if data.Role != nil {
		var item *api.ACLLink
		diags.Append(decodeACLLink(path.AtName("role"), data.Role, &item)...)

		if diags.HasError() {
			return diags
		}

		target.Role = *item
	}

	return diags
}

func decodeNetworkAreaMembers(path path.Path, data *NetworkAreaMembers, networkAreaMembers **structs.NetworkAreaMembers) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &structs.NetworkAreaMembers{}
	if *networkAreaMembers == nil {
		*networkAreaMembers = target
	} else {
		target = *networkAreaMembers
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if data.Members != nil {
		target.Members = make([]*api.SerfMember, len(data.Members))
		for i, data := range data.Members {
			if data != nil {
				var item *api.SerfMember
				diags.Append(decodeSerfMember(path.AtName("members").AtListIndex(i), data, &item)...)

				if diags.HasError() {
					return diags
				}

				target.Members[i] = item
			}
		}
	}

	return diags
}

func decodeNetworkSegments(path path.Path, data *NetworkSegments, networkSegments **structs.NetworkSegments) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &structs.NetworkSegments{}
	if *networkSegments == nil {
		*networkSegments = target
	} else {
		target = *networkSegments
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if data.Segments != nil {
		target.Segments = make([]string, len(data.Segments))
		for i, data := range data.Segments {
			if !data.IsNull() {
				target.Segments[i] = data.ValueString()
			}
		}
	}

	return diags
}

func decodeNodes(path path.Path, data *Nodes, nodes **structs.Nodes) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &structs.Nodes{}
	if *nodes == nil {
		*nodes = target
	} else {
		target = *nodes
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if data.Nodes != nil {
		target.Nodes = make([]*api.Node, len(data.Nodes))
		for i, data := range data.Nodes {
			if data != nil {
				var item *api.Node
				diags.Append(decodeNode(path.AtName("nodes").AtListIndex(i), data, &item)...)

				if diags.HasError() {
					return diags
				}

				target.Nodes[i] = item
			}
		}
	}

	return diags
}

func decodeOperatorHealthReply(path path.Path, data *OperatorHealthReply, operatorHealthReply **api.OperatorHealthReply) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.OperatorHealthReply{}
	if *operatorHealthReply == nil {
		*operatorHealthReply = target
	} else {
		target = *operatorHealthReply
	}

	if !data.Healthy.IsNull() {
		target.Healthy = data.Healthy.ValueBool()
	}

	if !data.FailureTolerance.IsNull() {
		i := int(data.FailureTolerance.ValueInt64())
		target.FailureTolerance = i
	}

	if data.Servers != nil {
		target.Servers = make([]api.ServerHealth, len(data.Servers))
		for i, data := range data.Servers {
			if data != nil {
				var item *api.ServerHealth
				diags.Append(decodeServerHealth(path.AtName("servers").AtListIndex(i), data, &item)...)

				if diags.HasError() {
					return diags
				}

				target.Servers[i] = *item
			}
		}
	}

	return diags
}

func decodePartition(path path.Path, data *Partition, partition **api.Partition) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.Partition{}
	if *partition == nil {
		*partition = target
	} else {
		target = *partition
	}

	if !data.Name.IsNull() {
		target.Name = data.Name.ValueString()
	}

	if !data.Description.IsNull() {
		target.Description = data.Description.ValueString()
	}

	if !data.DeletedAt.IsNull() {
		t, err := time.Parse(time.RFC3339, data.DeletedAt.ValueString())
		if err != nil {
			diags.Append(diag.NewAttributeErrorDiagnostic(path.AtName("deleted_at"), "failed to parse time string", err.Error()))
		}
		target.DeletedAt = &t
	}

	return diags
}

func decodePeering(path path.Path, data *Peering, peering **api.Peering) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.Peering{}
	if *peering == nil {
		*peering = target
	} else {
		target = *peering
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if !data.Name.IsNull() {
		target.Name = data.Name.ValueString()
	}

	if !data.Partition.IsNull() {
		target.Partition = data.Partition.ValueString()
	}

	if !data.DeletedAt.IsNull() {
		t, err := time.Parse(time.RFC3339, data.DeletedAt.ValueString())
		if err != nil {
			diags.Append(diag.NewAttributeErrorDiagnostic(path.AtName("deleted_at"), "failed to parse time string", err.Error()))
		}
		target.DeletedAt = &t
	}

	if data.Meta != nil {
		target.Meta = map[string]string{}
		for key, data := range data.Meta {
			if !data.IsNull() {
				target.Meta[key] = data.ValueString()
			}
		}
	}

	if !data.State.IsNull() {
		target.State = api.PeeringState(data.State.ValueString())
	}

	if !data.PeerID.IsNull() {
		target.PeerID = data.PeerID.ValueString()
	}

	if data.PeerCAPems != nil {
		target.PeerCAPems = make([]string, len(data.PeerCAPems))
		for i, data := range data.PeerCAPems {
			if !data.IsNull() {
				target.PeerCAPems[i] = data.ValueString()
			}
		}
	}

	if !data.PeerServerName.IsNull() {
		target.PeerServerName = data.PeerServerName.ValueString()
	}

	if data.PeerServerAddresses != nil {
		target.PeerServerAddresses = make([]string, len(data.PeerServerAddresses))
		for i, data := range data.PeerServerAddresses {
			if !data.IsNull() {
				target.PeerServerAddresses[i] = data.ValueString()
			}
		}
	}

	if data.StreamStatus != nil {
		var item *api.PeeringStreamStatus
		diags.Append(decodePeeringStreamStatus(path.AtName("stream_status"), data.StreamStatus, &item)...)

		if diags.HasError() {
			return diags
		}

		target.StreamStatus = *item
	}

	if data.Remote != nil {
		var item *api.PeeringRemoteInfo
		diags.Append(decodePeeringRemoteInfo(path.AtName("remote"), data.Remote, &item)...)

		if diags.HasError() {
			return diags
		}

		target.Remote = *item
	}

	return diags
}

func decodePeeringResource(path path.Path, data *PeeringResource, peeringResource **structs.PeeringResource) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &structs.PeeringResource{}
	if *peeringResource == nil {
		*peeringResource = target
	} else {
		target = *peeringResource
	}

	if !data.PeeringToken.IsNull() {
		target.PeeringToken = data.PeeringToken.ValueString()
	}

	if !data.ID.IsNull() {
		target.Peering.ID = data.ID.ValueString()
	}

	if !data.Name.IsNull() {
		target.Peering.Name = data.Name.ValueString()
	}

	if !data.Partition.IsNull() {
		target.Peering.Partition = data.Partition.ValueString()
	}

	if !data.DeletedAt.IsNull() {
		t, err := time.Parse(time.RFC3339, data.DeletedAt.ValueString())
		if err != nil {
			diags.Append(diag.NewAttributeErrorDiagnostic(path.AtName("deleted_at"), "failed to parse time string", err.Error()))
		}
		target.Peering.DeletedAt = &t
	}

	if data.Meta != nil {
		target.Peering.Meta = map[string]string{}
		for key, data := range data.Meta {
			if !data.IsNull() {
				target.Peering.Meta[key] = data.ValueString()
			}
		}
	}

	if !data.State.IsNull() {
		target.Peering.State = api.PeeringState(data.State.ValueString())
	}

	if !data.PeerID.IsNull() {
		target.Peering.PeerID = data.PeerID.ValueString()
	}

	if data.PeerCAPems != nil {
		target.Peering.PeerCAPems = make([]string, len(data.PeerCAPems))
		for i, data := range data.PeerCAPems {
			if !data.IsNull() {
				target.Peering.PeerCAPems[i] = data.ValueString()
			}
		}
	}

	if !data.PeerServerName.IsNull() {
		target.Peering.PeerServerName = data.PeerServerName.ValueString()
	}

	if data.PeerServerAddresses != nil {
		target.Peering.PeerServerAddresses = make([]string, len(data.PeerServerAddresses))
		for i, data := range data.PeerServerAddresses {
			if !data.IsNull() {
				target.Peering.PeerServerAddresses[i] = data.ValueString()
			}
		}
	}

	if data.StreamStatus != nil {
		var item *api.PeeringStreamStatus
		diags.Append(decodePeeringStreamStatus(path.AtName("stream_status"), data.StreamStatus, &item)...)

		if diags.HasError() {
			return diags
		}

		target.Peering.StreamStatus = *item
	}

	if data.Remote != nil {
		var item *api.PeeringRemoteInfo
		diags.Append(decodePeeringRemoteInfo(path.AtName("remote"), data.Remote, &item)...)

		if diags.HasError() {
			return diags
		}

		target.Peering.Remote = *item
	}

	return diags
}

func decodePeeringToken(path path.Path, data *PeeringToken, peeringToken **structs.PeeringToken) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &structs.PeeringToken{}
	if *peeringToken == nil {
		*peeringToken = target
	} else {
		target = *peeringToken
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if !data.PeerName.IsNull() {
		target.Request.PeerName = data.PeerName.ValueString()
	}

	if !data.Partition.IsNull() {
		target.Request.Partition = data.Partition.ValueString()
	}

	if data.Meta != nil {
		target.Request.Meta = map[string]string{}
		for key, data := range data.Meta {
			if !data.IsNull() {
				target.Request.Meta[key] = data.ValueString()
			}
		}
	}

	if data.ServerExternalAddresses != nil {
		target.Request.ServerExternalAddresses = make([]string, len(data.ServerExternalAddresses))
		for i, data := range data.ServerExternalAddresses {
			if !data.IsNull() {
				target.Request.ServerExternalAddresses[i] = data.ValueString()
			}
		}
	}

	if !data.PeeringToken.IsNull() {
		target.Response.PeeringToken = data.PeeringToken.ValueString()
	}

	return diags
}

func decodePeerings(path path.Path, data *Peerings, peerings **structs.Peerings) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &structs.Peerings{}
	if *peerings == nil {
		*peerings = target
	} else {
		target = *peerings
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if data.Peerings != nil {
		target.Peerings = make([]*api.Peering, len(data.Peerings))
		for i, data := range data.Peerings {
			if data != nil {
				var item *api.Peering
				diags.Append(decodePeering(path.AtName("peerings").AtListIndex(i), data, &item)...)

				if diags.HasError() {
					return diags
				}

				target.Peerings[i] = item
			}
		}
	}

	return diags
}

func decodePreparedQueryDefinition(path path.Path, data *PreparedQueryDefinition, preparedQueryDefinition **api.PreparedQueryDefinition) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.PreparedQueryDefinition{}
	if *preparedQueryDefinition == nil {
		*preparedQueryDefinition = target
	} else {
		target = *preparedQueryDefinition
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if !data.Name.IsNull() {
		target.Name = data.Name.ValueString()
	}

	if !data.Session.IsNull() {
		target.Session = data.Session.ValueString()
	}

	if !data.Token.IsNull() {
		target.Token = data.Token.ValueString()
	}

	if data.Service != nil {
		var item *api.ServiceQuery
		diags.Append(decodeServiceQuery(path.AtName("service"), data.Service, &item)...)

		if diags.HasError() {
			return diags
		}

		target.Service = *item
	}

	if data.DNS != nil {
		var item *api.QueryDNSOptions
		diags.Append(decodeQueryDNSOptions(path.AtName("dns"), data.DNS, &item)...)

		if diags.HasError() {
			return diags
		}

		target.DNS = *item
	}

	if data.Template != nil {
		var item *api.QueryTemplate
		diags.Append(decodeQueryTemplate(path.AtName("template"), data.Template, &item)...)

		if diags.HasError() {
			return diags
		}

		target.Template = *item
	}

	return diags
}

func decodeServiceHealth(path path.Path, data *ServiceHealth, serviceHealth **structs.ServiceHealth) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &structs.ServiceHealth{}
	if *serviceHealth == nil {
		*serviceHealth = target
	} else {
		target = *serviceHealth
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if data.Services != nil {
		target.Services = make([]*api.ServiceEntry, len(data.Services))
		for i, data := range data.Services {
			if data != nil {
				var item *api.ServiceEntry
				diags.Append(decodeServiceEntry(path.AtName("services").AtListIndex(i), data, &item)...)

				if diags.HasError() {
					return diags
				}

				target.Services[i] = item
			}
		}
	}

	return diags
}

func decodeACLAuthMethodNamespaceRule(path path.Path, data *ACLAuthMethodNamespaceRule, aclAuthMethodNamespaceRule **api.ACLAuthMethodNamespaceRule) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.ACLAuthMethodNamespaceRule{}
	if *aclAuthMethodNamespaceRule == nil {
		*aclAuthMethodNamespaceRule = target
	} else {
		target = *aclAuthMethodNamespaceRule
	}

	if !data.Selector.IsNull() {
		target.Selector = data.Selector.ValueString()
	}

	if !data.BindNamespace.IsNull() {
		target.BindNamespace = data.BindNamespace.ValueString()
	}

	return diags
}

func decodeACLLink(path path.Path, data *ACLLink, aclLink **api.ACLLink) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.ACLLink{}
	if *aclLink == nil {
		*aclLink = target
	} else {
		target = *aclLink
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if !data.Name.IsNull() {
		target.Name = data.Name.ValueString()
	}

	return diags
}

func decodeACLServiceIdentity(path path.Path, data *ACLServiceIdentity, aclServiceIdentity **api.ACLServiceIdentity) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.ACLServiceIdentity{}
	if *aclServiceIdentity == nil {
		*aclServiceIdentity = target
	} else {
		target = *aclServiceIdentity
	}

	if !data.ServiceName.IsNull() {
		target.ServiceName = data.ServiceName.ValueString()
	}

	if data.Datacenters != nil {
		target.Datacenters = make([]string, len(data.Datacenters))
		for i, data := range data.Datacenters {
			if !data.IsNull() {
				target.Datacenters[i] = data.ValueString()
			}
		}
	}

	return diags
}

func decodeACLNodeIdentity(path path.Path, data *ACLNodeIdentity, aclNodeIdentity **api.ACLNodeIdentity) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.ACLNodeIdentity{}
	if *aclNodeIdentity == nil {
		*aclNodeIdentity = target
	} else {
		target = *aclNodeIdentity
	}

	if !data.NodeName.IsNull() {
		target.NodeName = data.NodeName.ValueString()
	}

	if !data.Datacenter.IsNull() {
		target.Datacenter = data.Datacenter.ValueString()
	}

	return diags
}

func decodeServerHealth(path path.Path, data *ServerHealth, serverHealth **api.ServerHealth) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.ServerHealth{}
	if *serverHealth == nil {
		*serverHealth = target
	} else {
		target = *serverHealth
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if !data.Name.IsNull() {
		target.Name = data.Name.ValueString()
	}

	if !data.Address.IsNull() {
		target.Address = data.Address.ValueString()
	}

	if !data.SerfStatus.IsNull() {
		target.SerfStatus = data.SerfStatus.ValueString()
	}

	if !data.Version.IsNull() {
		target.Version = data.Version.ValueString()
	}

	if !data.Leader.IsNull() {
		target.Leader = data.Leader.ValueBool()
	}

	if !data.LastTerm.IsNull() {
		i := uint64(data.LastTerm.ValueInt64())
		target.LastTerm = i
	}

	if !data.LastIndex.IsNull() {
		i := uint64(data.LastIndex.ValueInt64())
		target.LastIndex = i
	}

	if !data.Healthy.IsNull() {
		target.Healthy = data.Healthy.ValueBool()
	}

	if !data.Voter.IsNull() {
		target.Voter = data.Voter.ValueBool()
	}

	if !data.StableSince.IsNull() {
		t, err := time.Parse(time.RFC3339, data.StableSince.ValueString())
		if err != nil {
			diags.Append(diag.NewAttributeErrorDiagnostic(path.AtName("stable_since"), "failed to parse time string", err.Error()))
		}
		target.StableSince = t
	}

	return diags
}

func decodeAgentService(path path.Path, data *AgentService, agentService **api.AgentService) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.AgentService{}
	if *agentService == nil {
		*agentService = target
	} else {
		target = *agentService
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	return diags
}

func decodeLocality(path path.Path, data *Locality, locality **api.Locality) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.Locality{}
	if *locality == nil {
		*locality = target
	} else {
		target = *locality
	}

	if !data.Region.IsNull() {
		target.Region = data.Region.ValueString()
	}

	if !data.Zone.IsNull() {
		target.Zone = data.Zone.ValueString()
	}

	return diags
}

func decodeServiceAddress(path path.Path, data *ServiceAddress, serviceAddress **api.ServiceAddress) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.ServiceAddress{}
	if *serviceAddress == nil {
		*serviceAddress = target
	} else {
		target = *serviceAddress
	}

	if !data.Address.IsNull() {
		target.Address = data.Address.ValueString()
	}

	if !data.Port.IsNull() {
		i := int(data.Port.ValueInt64())
		target.Port = i
	}

	return diags
}

func decodeWeights(path path.Path, data *Weights, weights **api.Weights) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.Weights{}
	if *weights == nil {
		*weights = target
	} else {
		target = *weights
	}

	if !data.Passing.IsNull() {
		i := int(data.Passing.ValueInt64())
		target.Passing = i
	}

	if !data.Warning.IsNull() {
		i := int(data.Warning.ValueInt64())
		target.Warning = i
	}

	return diags
}

func decodeAgentServiceConnectProxyConfig(path path.Path, data *AgentServiceConnectProxyConfig, agentServiceConnectProxyConfig **api.AgentServiceConnectProxyConfig) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.AgentServiceConnectProxyConfig{}
	if *agentServiceConnectProxyConfig == nil {
		*agentServiceConnectProxyConfig = target
	} else {
		target = *agentServiceConnectProxyConfig
	}

	if data.EnvoyExtensions != nil {
		target.EnvoyExtensions = make([]api.EnvoyExtension, len(data.EnvoyExtensions))
		for i, data := range data.EnvoyExtensions {
			if data != nil {
				var item *api.EnvoyExtension
				diags.Append(decodeEnvoyExtension(path.AtName("envoy_extensions").AtListIndex(i), data, &item)...)

				if diags.HasError() {
					return diags
				}

				target.EnvoyExtensions[i] = *item
			}
		}
	}

	if !data.DestinationServiceName.IsNull() {
		target.DestinationServiceName = data.DestinationServiceName.ValueString()
	}

	if !data.DestinationServiceID.IsNull() {
		target.DestinationServiceID = data.DestinationServiceID.ValueString()
	}

	if !data.LocalServiceAddress.IsNull() {
		target.LocalServiceAddress = data.LocalServiceAddress.ValueString()
	}

	if !data.LocalServicePort.IsNull() {
		i := int(data.LocalServicePort.ValueInt64())
		target.LocalServicePort = i
	}

	if !data.LocalServiceSocketPath.IsNull() {
		target.LocalServiceSocketPath = data.LocalServiceSocketPath.ValueString()
	}

	if !data.Mode.IsNull() {
		target.Mode = api.ProxyMode(data.Mode.ValueString())
	}

	if data.TransparentProxy != nil {
		var item *api.TransparentProxyConfig
		diags.Append(decodeTransparentProxyConfig(path.AtName("transparent_proxy"), data.TransparentProxy, &item)...)

		if diags.HasError() {
			return diags
		}

		target.TransparentProxy = item
	}

	if !data.Config.IsNull() {
		var m map[string]interface{}
		if err := json.Unmarshal([]byte(data.Config.ValueString()), &m); err != nil {
			diags.AddAttributeError(path.AtName("config"), "failed to unmarshal json", err.Error())
			return
		}
		target.Config = m
	}

	if data.Upstreams != nil {
		target.Upstreams = make([]api.Upstream, len(data.Upstreams))
		for i, data := range data.Upstreams {
			if data != nil {
				var item *api.Upstream
				diags.Append(decodeUpstream(path.AtName("upstreams").AtListIndex(i), data, &item)...)

				if diags.HasError() {
					return diags
				}

				target.Upstreams[i] = *item
			}
		}
	}

	if data.MeshGateway != nil {
		var item *api.MeshGatewayConfig
		diags.Append(decodeMeshGatewayConfig(path.AtName("mesh_gateway"), data.MeshGateway, &item)...)

		if diags.HasError() {
			return diags
		}

		target.MeshGateway = *item
	}

	if data.Expose != nil {
		var item *api.ExposeConfig
		diags.Append(decodeExposeConfig(path.AtName("expose"), data.Expose, &item)...)

		if diags.HasError() {
			return diags
		}

		target.Expose = *item
	}

	if data.AccessLogs != nil {
		var item *api.AccessLogsConfig
		diags.Append(decodeAccessLogsConfig(path.AtName("access_logs"), data.AccessLogs, &item)...)

		if diags.HasError() {
			return diags
		}

		target.AccessLogs = item
	}

	return diags
}

func decodeHealthCheck(path path.Path, data *HealthCheck, healthCheck **api.HealthCheck) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.HealthCheck{}
	if *healthCheck == nil {
		*healthCheck = target
	} else {
		target = *healthCheck
	}

	if !data.Node.IsNull() {
		target.Node = data.Node.ValueString()
	}

	if !data.CheckID.IsNull() {
		target.CheckID = data.CheckID.ValueString()
	}

	if !data.Name.IsNull() {
		target.Name = data.Name.ValueString()
	}

	if !data.Status.IsNull() {
		target.Status = data.Status.ValueString()
	}

	if !data.Notes.IsNull() {
		target.Notes = data.Notes.ValueString()
	}

	if !data.Output.IsNull() {
		target.Output = data.Output.ValueString()
	}

	if !data.ServiceID.IsNull() {
		target.ServiceID = data.ServiceID.ValueString()
	}

	if !data.ServiceName.IsNull() {
		target.ServiceName = data.ServiceName.ValueString()
	}

	if data.ServiceTags != nil {
		target.ServiceTags = make([]string, len(data.ServiceTags))
		for i, data := range data.ServiceTags {
			if !data.IsNull() {
				target.ServiceTags[i] = data.ValueString()
			}
		}
	}

	if !data.Type.IsNull() {
		target.Type = data.Type.ValueString()
	}

	if !data.Namespace.IsNull() {
		target.Namespace = data.Namespace.ValueString()
	}

	if !data.Partition.IsNull() {
		target.Partition = data.Partition.ValueString()
	}

	if !data.ExposedPort.IsNull() {
		i := int(data.ExposedPort.ValueInt64())
		target.ExposedPort = i
	}

	if !data.PeerName.IsNull() {
		target.PeerName = data.PeerName.ValueString()
	}

	if data.Definition != nil {
		var item *api.HealthCheckDefinition
		diags.Append(decodeHealthCheckDefinition(path.AtName("definition"), data.Definition, &item)...)

		if diags.HasError() {
			return diags
		}

		target.Definition = *item
	}

	return diags
}

func decodeHttpBasicAuth(path path.Path, data *HttpBasicAuth, httpBasicAuth **api.HttpBasicAuth) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.HttpBasicAuth{}
	if *httpBasicAuth == nil {
		*httpBasicAuth = target
	} else {
		target = *httpBasicAuth
	}

	if !data.Username.IsNull() {
		target.Username = data.Username.ValueString()
	}

	if !data.Password.IsNull() {
		target.Password = data.Password.ValueString()
	}

	return diags
}

func decodeTLSConfig(path path.Path, data *TLSConfig, tlsConfig **api.TLSConfig) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.TLSConfig{}
	if *tlsConfig == nil {
		*tlsConfig = target
	} else {
		target = *tlsConfig
	}

	if !data.Address.IsNull() {
		target.Address = data.Address.ValueString()
	}

	if !data.CAFile.IsNull() {
		target.CAFile = data.CAFile.ValueString()
	}

	if !data.CAPath.IsNull() {
		target.CAPath = data.CAPath.ValueString()
	}

	if !data.CAPem.IsNull() {
		target.CAPem = []byte(data.CAPem.ValueString())
	}

	if !data.CertFile.IsNull() {
		target.CertFile = data.CertFile.ValueString()
	}

	if !data.CertPEM.IsNull() {
		target.CertPEM = []byte(data.CertPEM.ValueString())
	}

	if !data.KeyFile.IsNull() {
		target.KeyFile = data.KeyFile.ValueString()
	}

	if !data.KeyPEM.IsNull() {
		target.KeyPEM = []byte(data.KeyPEM.ValueString())
	}

	if !data.InsecureSkipVerify.IsNull() {
		target.InsecureSkipVerify = data.InsecureSkipVerify.ValueBool()
	}

	return diags
}

func decodeKVPair(path path.Path, data *KVPair, kvPair **api.KVPair) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.KVPair{}
	if *kvPair == nil {
		*kvPair = target
	} else {
		target = *kvPair
	}

	if !data.Key.IsNull() {
		target.Key = data.Key.ValueString()
	}

	if !data.Flags.IsNull() {
		i := uint64(data.Flags.ValueInt64())
		target.Flags = i
	}

	if !data.Value.IsNull() {
		target.Value = []byte(data.Value.ValueString())
	}

	if !data.Namespace.IsNull() {
		target.Namespace = data.Namespace.ValueString()
	}

	if !data.Partition.IsNull() {
		target.Partition = data.Partition.ValueString()
	}

	return diags
}

func decodeNamespaceACLConfig(path path.Path, data *NamespaceACLConfig, namespaceAclConfig **api.NamespaceACLConfig) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.NamespaceACLConfig{}
	if *namespaceAclConfig == nil {
		*namespaceAclConfig = target
	} else {
		target = *namespaceAclConfig
	}

	if data.PolicyDefaults != nil {
		target.PolicyDefaults = make([]api.ACLLink, len(data.PolicyDefaults))
		for i, data := range data.PolicyDefaults {
			if data != nil {
				var item *api.ACLLink
				diags.Append(decodeACLLink(path.AtName("policy_defaults").AtListIndex(i), data, &item)...)

				if diags.HasError() {
					return diags
				}

				target.PolicyDefaults[i] = *item
			}
		}
	}

	if data.RoleDefaults != nil {
		target.RoleDefaults = make([]api.ACLLink, len(data.RoleDefaults))
		for i, data := range data.RoleDefaults {
			if data != nil {
				var item *api.ACLLink
				diags.Append(decodeACLLink(path.AtName("role_defaults").AtListIndex(i), data, &item)...)

				if diags.HasError() {
					return diags
				}

				target.RoleDefaults[i] = *item
			}
		}
	}

	return diags
}

func decodeSerfMember(path path.Path, data *SerfMember, serfMember **api.SerfMember) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.SerfMember{}
	if *serfMember == nil {
		*serfMember = target
	} else {
		target = *serfMember
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if !data.Name.IsNull() {
		target.Name = data.Name.ValueString()
	}

	if !data.Port.IsNull() {
		i := uint16(data.Port.ValueInt64())
		target.Port = i
	}

	if !data.Datacenter.IsNull() {
		target.Datacenter = data.Datacenter.ValueString()
	}

	if !data.Role.IsNull() {
		target.Role = data.Role.ValueString()
	}

	if !data.Build.IsNull() {
		target.Build = data.Build.ValueString()
	}

	if !data.Protocol.IsNull() {
		i := int(data.Protocol.ValueInt64())
		target.Protocol = i
	}

	if !data.Status.IsNull() {
		target.Status = data.Status.ValueString()
	}

	if !data.RTT.IsNull() {
		dur, err := time.ParseDuration(data.RTT.ValueString())
		if err != nil {
			diags.Append(diag.NewAttributeErrorDiagnostic(path.AtName("rtt"), "failed to parse duration", err.Error()))
		}
		target.RTT = dur
	}

	return diags
}

func decodeNode(path path.Path, data *Node, node **api.Node) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.Node{}
	if *node == nil {
		*node = target
	} else {
		target = *node
	}

	if !data.ID.IsNull() {
		target.ID = data.ID.ValueString()
	}

	if !data.Node.IsNull() {
		target.Node = data.Node.ValueString()
	}

	if !data.Address.IsNull() {
		target.Address = data.Address.ValueString()
	}

	if !data.Datacenter.IsNull() {
		target.Datacenter = data.Datacenter.ValueString()
	}

	if data.TaggedAddresses != nil {
		target.TaggedAddresses = map[string]string{}
		for key, data := range data.TaggedAddresses {
			if !data.IsNull() {
				target.TaggedAddresses[key] = data.ValueString()
			}
		}
	}

	if data.Meta != nil {
		target.Meta = map[string]string{}
		for key, data := range data.Meta {
			if !data.IsNull() {
				target.Meta[key] = data.ValueString()
			}
		}
	}

	if !data.Partition.IsNull() {
		target.Partition = data.Partition.ValueString()
	}

	if !data.PeerName.IsNull() {
		target.PeerName = data.PeerName.ValueString()
	}

	if data.Locality != nil {
		var item *api.Locality
		diags.Append(decodeLocality(path.AtName("locality"), data.Locality, &item)...)

		if diags.HasError() {
			return diags
		}

		target.Locality = item
	}

	return diags
}

func decodePeeringStreamStatus(path path.Path, data *PeeringStreamStatus, peeringStreamStatus **api.PeeringStreamStatus) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.PeeringStreamStatus{}
	if *peeringStreamStatus == nil {
		*peeringStreamStatus = target
	} else {
		target = *peeringStreamStatus
	}

	if data.ImportedServices != nil {
		target.ImportedServices = make([]string, len(data.ImportedServices))
		for i, data := range data.ImportedServices {
			if !data.IsNull() {
				target.ImportedServices[i] = data.ValueString()
			}
		}
	}

	if data.ExportedServices != nil {
		target.ExportedServices = make([]string, len(data.ExportedServices))
		for i, data := range data.ExportedServices {
			if !data.IsNull() {
				target.ExportedServices[i] = data.ValueString()
			}
		}
	}

	if !data.LastHeartbeat.IsNull() {
		t, err := time.Parse(time.RFC3339, data.LastHeartbeat.ValueString())
		if err != nil {
			diags.Append(diag.NewAttributeErrorDiagnostic(path.AtName("last_heartbeat"), "failed to parse time string", err.Error()))
		}
		target.LastHeartbeat = &t
	}

	if !data.LastReceive.IsNull() {
		t, err := time.Parse(time.RFC3339, data.LastReceive.ValueString())
		if err != nil {
			diags.Append(diag.NewAttributeErrorDiagnostic(path.AtName("last_receive"), "failed to parse time string", err.Error()))
		}
		target.LastReceive = &t
	}

	if !data.LastSend.IsNull() {
		t, err := time.Parse(time.RFC3339, data.LastSend.ValueString())
		if err != nil {
			diags.Append(diag.NewAttributeErrorDiagnostic(path.AtName("last_send"), "failed to parse time string", err.Error()))
		}
		target.LastSend = &t
	}

	return diags
}

func decodePeeringRemoteInfo(path path.Path, data *PeeringRemoteInfo, peeringRemoteInfo **api.PeeringRemoteInfo) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.PeeringRemoteInfo{}
	if *peeringRemoteInfo == nil {
		*peeringRemoteInfo = target
	} else {
		target = *peeringRemoteInfo
	}

	if !data.Partition.IsNull() {
		target.Partition = data.Partition.ValueString()
	}

	if !data.Datacenter.IsNull() {
		target.Datacenter = data.Datacenter.ValueString()
	}

	if data.Locality != nil {
		var item *api.Locality
		diags.Append(decodeLocality(path.AtName("locality"), data.Locality, &item)...)

		if diags.HasError() {
			return diags
		}

		target.Locality = item
	}

	return diags
}

func decodeServiceQuery(path path.Path, data *ServiceQuery, serviceQuery **api.ServiceQuery) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.ServiceQuery{}
	if *serviceQuery == nil {
		*serviceQuery = target
	} else {
		target = *serviceQuery
	}

	if !data.Service.IsNull() {
		target.Service = data.Service.ValueString()
	}

	if !data.SamenessGroup.IsNull() {
		target.SamenessGroup = data.SamenessGroup.ValueString()
	}

	if !data.Namespace.IsNull() {
		target.Namespace = data.Namespace.ValueString()
	}

	if !data.Partition.IsNull() {
		target.Partition = data.Partition.ValueString()
	}

	if !data.Near.IsNull() {
		target.Near = data.Near.ValueString()
	}

	if data.Failover != nil {
		var item *api.QueryFailoverOptions
		diags.Append(decodeQueryFailoverOptions(path.AtName("failover"), data.Failover, &item)...)

		if diags.HasError() {
			return diags
		}

		target.Failover = *item
	}

	if data.IgnoreCheckIDs != nil {
		target.IgnoreCheckIDs = make([]string, len(data.IgnoreCheckIDs))
		for i, data := range data.IgnoreCheckIDs {
			if !data.IsNull() {
				target.IgnoreCheckIDs[i] = data.ValueString()
			}
		}
	}

	if !data.OnlyPassing.IsNull() {
		target.OnlyPassing = data.OnlyPassing.ValueBool()
	}

	if data.Tags != nil {
		target.Tags = make([]string, len(data.Tags))
		for i, data := range data.Tags {
			if !data.IsNull() {
				target.Tags[i] = data.ValueString()
			}
		}
	}

	if data.NodeMeta != nil {
		target.NodeMeta = map[string]string{}
		for key, data := range data.NodeMeta {
			if !data.IsNull() {
				target.NodeMeta[key] = data.ValueString()
			}
		}
	}

	if data.ServiceMeta != nil {
		target.ServiceMeta = map[string]string{}
		for key, data := range data.ServiceMeta {
			if !data.IsNull() {
				target.ServiceMeta[key] = data.ValueString()
			}
		}
	}

	if !data.Connect.IsNull() {
		target.Connect = data.Connect.ValueBool()
	}

	return diags
}

func decodeQueryDNSOptions(path path.Path, data *QueryDNSOptions, queryDnsOptions **api.QueryDNSOptions) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.QueryDNSOptions{}
	if *queryDnsOptions == nil {
		*queryDnsOptions = target
	} else {
		target = *queryDnsOptions
	}

	if !data.TTL.IsNull() {
		target.TTL = data.TTL.ValueString()
	}

	return diags
}

func decodeQueryTemplate(path path.Path, data *QueryTemplate, queryTemplate **api.QueryTemplate) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.QueryTemplate{}
	if *queryTemplate == nil {
		*queryTemplate = target
	} else {
		target = *queryTemplate
	}

	if !data.Type.IsNull() {
		target.Type = data.Type.ValueString()
	}

	if !data.Regexp.IsNull() {
		target.Regexp = data.Regexp.ValueString()
	}

	if !data.RemoveEmptyTags.IsNull() {
		target.RemoveEmptyTags = data.RemoveEmptyTags.ValueBool()
	}

	return diags
}

func decodeServiceEntry(path path.Path, data *ServiceEntry, serviceEntry **api.ServiceEntry) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.ServiceEntry{}
	if *serviceEntry == nil {
		*serviceEntry = target
	} else {
		target = *serviceEntry
	}

	return diags
}

func decodeEnvoyExtension(path path.Path, data *EnvoyExtension, envoyExtension **api.EnvoyExtension) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.EnvoyExtension{}
	if *envoyExtension == nil {
		*envoyExtension = target
	} else {
		target = *envoyExtension
	}

	if !data.Name.IsNull() {
		target.Name = data.Name.ValueString()
	}

	if !data.Required.IsNull() {
		target.Required = data.Required.ValueBool()
	}

	if !data.Arguments.IsNull() {
		var m map[string]interface{}
		if err := json.Unmarshal([]byte(data.Arguments.ValueString()), &m); err != nil {
			diags.AddAttributeError(path.AtName("arguments"), "failed to unmarshal json", err.Error())
			return
		}
		target.Arguments = m
	}

	if !data.ConsulVersion.IsNull() {
		target.ConsulVersion = data.ConsulVersion.ValueString()
	}

	if !data.EnvoyVersion.IsNull() {
		target.EnvoyVersion = data.EnvoyVersion.ValueString()
	}

	return diags
}

func decodeTransparentProxyConfig(path path.Path, data *TransparentProxyConfig, transparentProxyConfig **api.TransparentProxyConfig) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.TransparentProxyConfig{}
	if *transparentProxyConfig == nil {
		*transparentProxyConfig = target
	} else {
		target = *transparentProxyConfig
	}

	if !data.OutboundListenerPort.IsNull() {
		i := int(data.OutboundListenerPort.ValueInt64())
		target.OutboundListenerPort = i
	}

	if !data.DialedDirectly.IsNull() {
		target.DialedDirectly = data.DialedDirectly.ValueBool()
	}

	return diags
}

func decodeUpstream(path path.Path, data *Upstream, upstream **api.Upstream) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.Upstream{}
	if *upstream == nil {
		*upstream = target
	} else {
		target = *upstream
	}

	if !data.DestinationType.IsNull() {
		target.DestinationType = api.UpstreamDestType(data.DestinationType.ValueString())
	}

	if !data.DestinationPartition.IsNull() {
		target.DestinationPartition = data.DestinationPartition.ValueString()
	}

	if !data.DestinationNamespace.IsNull() {
		target.DestinationNamespace = data.DestinationNamespace.ValueString()
	}

	if !data.DestinationPeer.IsNull() {
		target.DestinationPeer = data.DestinationPeer.ValueString()
	}

	if !data.DestinationName.IsNull() {
		target.DestinationName = data.DestinationName.ValueString()
	}

	if !data.Datacenter.IsNull() {
		target.Datacenter = data.Datacenter.ValueString()
	}

	if !data.LocalBindAddress.IsNull() {
		target.LocalBindAddress = data.LocalBindAddress.ValueString()
	}

	if !data.LocalBindPort.IsNull() {
		i := int(data.LocalBindPort.ValueInt64())
		target.LocalBindPort = i
	}

	if !data.LocalBindSocketPath.IsNull() {
		target.LocalBindSocketPath = data.LocalBindSocketPath.ValueString()
	}

	if !data.LocalBindSocketMode.IsNull() {
		target.LocalBindSocketMode = data.LocalBindSocketMode.ValueString()
	}

	if !data.Config.IsNull() {
		var m map[string]interface{}
		if err := json.Unmarshal([]byte(data.Config.ValueString()), &m); err != nil {
			diags.AddAttributeError(path.AtName("config"), "failed to unmarshal json", err.Error())
			return
		}
		target.Config = m
	}

	if data.MeshGateway != nil {
		var item *api.MeshGatewayConfig
		diags.Append(decodeMeshGatewayConfig(path.AtName("mesh_gateway"), data.MeshGateway, &item)...)

		if diags.HasError() {
			return diags
		}

		target.MeshGateway = *item
	}

	if !data.CentrallyConfigured.IsNull() {
		target.CentrallyConfigured = data.CentrallyConfigured.ValueBool()
	}

	return diags
}

func decodeMeshGatewayConfig(path path.Path, data *MeshGatewayConfig, meshGatewayConfig **api.MeshGatewayConfig) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.MeshGatewayConfig{}
	if *meshGatewayConfig == nil {
		*meshGatewayConfig = target
	} else {
		target = *meshGatewayConfig
	}

	if !data.Mode.IsNull() {
		target.Mode = api.MeshGatewayMode(data.Mode.ValueString())
	}

	return diags
}

func decodeExposeConfig(path path.Path, data *ExposeConfig, exposeConfig **api.ExposeConfig) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.ExposeConfig{}
	if *exposeConfig == nil {
		*exposeConfig = target
	} else {
		target = *exposeConfig
	}

	if !data.Checks.IsNull() {
		target.Checks = data.Checks.ValueBool()
	}

	if data.Paths != nil {
		target.Paths = make([]api.ExposePath, len(data.Paths))
		for i, data := range data.Paths {
			if data != nil {
				var item *api.ExposePath
				diags.Append(decodeExposePath(path.AtName("paths").AtListIndex(i), data, &item)...)

				if diags.HasError() {
					return diags
				}

				target.Paths[i] = *item
			}
		}
	}

	return diags
}

func decodeAccessLogsConfig(path path.Path, data *AccessLogsConfig, accessLogsConfig **api.AccessLogsConfig) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.AccessLogsConfig{}
	if *accessLogsConfig == nil {
		*accessLogsConfig = target
	} else {
		target = *accessLogsConfig
	}

	if !data.Enabled.IsNull() {
		target.Enabled = data.Enabled.ValueBool()
	}

	if !data.DisableListenerLogs.IsNull() {
		target.DisableListenerLogs = data.DisableListenerLogs.ValueBool()
	}

	if !data.Type.IsNull() {
		target.Type = api.LogSinkType(data.Type.ValueString())
	}

	if !data.Path.IsNull() {
		target.Path = data.Path.ValueString()
	}

	if !data.JSONFormat.IsNull() {
		target.JSONFormat = data.JSONFormat.ValueString()
	}

	if !data.TextFormat.IsNull() {
		target.TextFormat = data.TextFormat.ValueString()
	}

	return diags
}

func decodeHealthCheckDefinition(path path.Path, data *HealthCheckDefinition, healthCheckDefinition **api.HealthCheckDefinition) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.HealthCheckDefinition{}
	if *healthCheckDefinition == nil {
		*healthCheckDefinition = target
	} else {
		target = *healthCheckDefinition
	}

	if !data.HTTP.IsNull() {
		target.HTTP = data.HTTP.ValueString()
	}

	if data.Header != nil {
		target.Header = map[string][]string{}
		for key, data := range data.Header {
			if data != nil {
				target.Header[key] = make([]string, len(data))
				for i, data := range data {
					if !data.IsNull() {
						target.Header[key][i] = data.ValueString()
					}
				}
			}
		}
	}

	if !data.Method.IsNull() {
		target.Method = data.Method.ValueString()
	}

	if !data.Body.IsNull() {
		target.Body = data.Body.ValueString()
	}

	if !data.TLSServerName.IsNull() {
		target.TLSServerName = data.TLSServerName.ValueString()
	}

	if !data.TLSSkipVerify.IsNull() {
		target.TLSSkipVerify = data.TLSSkipVerify.ValueBool()
	}

	if !data.TCP.IsNull() {
		target.TCP = data.TCP.ValueString()
	}

	if !data.UDP.IsNull() {
		target.UDP = data.UDP.ValueString()
	}

	if !data.GRPC.IsNull() {
		target.GRPC = data.GRPC.ValueString()
	}

	if !data.OSService.IsNull() {
		target.OSService = data.OSService.ValueString()
	}

	if !data.GRPCUseTLS.IsNull() {
		target.GRPCUseTLS = data.GRPCUseTLS.ValueBool()
	}

	if !data.IntervalDuration.IsNull() {
		dur, err := time.ParseDuration(data.IntervalDuration.ValueString())
		if err != nil {
			diags.Append(diag.NewAttributeErrorDiagnostic(path.AtName("interval_duration"), "failed to parse duration", err.Error()))
		}
		target.IntervalDuration = dur
	}

	if !data.TimeoutDuration.IsNull() {
		dur, err := time.ParseDuration(data.TimeoutDuration.ValueString())
		if err != nil {
			diags.Append(diag.NewAttributeErrorDiagnostic(path.AtName("timeout_duration"), "failed to parse duration", err.Error()))
		}
		target.TimeoutDuration = dur
	}

	if !data.DeregisterCriticalServiceAfterDuration.IsNull() {
		dur, err := time.ParseDuration(data.DeregisterCriticalServiceAfterDuration.ValueString())
		if err != nil {
			diags.Append(diag.NewAttributeErrorDiagnostic(path.AtName("deregister_critical_service_after_duration"), "failed to parse duration", err.Error()))
		}
		target.DeregisterCriticalServiceAfterDuration = dur
	}

	return diags
}

func decodeQueryFailoverOptions(path path.Path, data *QueryFailoverOptions, queryFailoverOptions **api.QueryFailoverOptions) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.QueryFailoverOptions{}
	if *queryFailoverOptions == nil {
		*queryFailoverOptions = target
	} else {
		target = *queryFailoverOptions
	}

	if !data.NearestN.IsNull() {
		i := int(data.NearestN.ValueInt64())
		target.NearestN = i
	}

	if data.Datacenters != nil {
		target.Datacenters = make([]string, len(data.Datacenters))
		for i, data := range data.Datacenters {
			if !data.IsNull() {
				target.Datacenters[i] = data.ValueString()
			}
		}
	}

	if data.Targets != nil {
		target.Targets = make([]api.QueryFailoverTarget, len(data.Targets))
		for i, data := range data.Targets {
			if data != nil {
				var item *api.QueryFailoverTarget
				diags.Append(decodeQueryFailoverTarget(path.AtName("targets").AtListIndex(i), data, &item)...)

				if diags.HasError() {
					return diags
				}

				target.Targets[i] = *item
			}
		}
	}

	return diags
}

func decodeExposePath(path path.Path, data *ExposePath, exposePath **api.ExposePath) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.ExposePath{}
	if *exposePath == nil {
		*exposePath = target
	} else {
		target = *exposePath
	}

	if !data.ListenerPort.IsNull() {
		i := int(data.ListenerPort.ValueInt64())
		target.ListenerPort = i
	}

	if !data.Path.IsNull() {
		target.Path = data.Path.ValueString()
	}

	if !data.LocalPathPort.IsNull() {
		i := int(data.LocalPathPort.ValueInt64())
		target.LocalPathPort = i
	}

	if !data.Protocol.IsNull() {
		target.Protocol = data.Protocol.ValueString()
	}

	if !data.ParsedFromCheck.IsNull() {
		target.ParsedFromCheck = data.ParsedFromCheck.ValueBool()
	}

	return diags
}

func decodeQueryFailoverTarget(path path.Path, data *QueryFailoverTarget, queryFailoverTarget **api.QueryFailoverTarget) (diags diag.Diagnostics) {
	if data == nil {
		return nil
	}

	target := &api.QueryFailoverTarget{}
	if *queryFailoverTarget == nil {
		*queryFailoverTarget = target
	} else {
		target = *queryFailoverTarget
	}

	if !data.Peer.IsNull() {
		target.Peer = data.Peer.ValueString()
	}

	if !data.Datacenter.IsNull() {
		target.Datacenter = data.Datacenter.ValueString()
	}

	if !data.Partition.IsNull() {
		target.Partition = data.Partition.ValueString()
	}

	if !data.Namespace.IsNull() {
		target.Namespace = data.Namespace.ValueString()
	}

	return diags
}
